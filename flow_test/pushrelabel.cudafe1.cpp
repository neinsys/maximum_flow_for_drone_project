#line 1 "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu"
#pragma section("__nv_managed_data__")
#line 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
#line 1
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false

#line 1
#line 62 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda_runtime.h"
#pragma warning(push)
#pragma warning(disable: 4820)
#line 708 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#line 1472
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\sal.h"
extern "C" {
#line 2967 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\sal.h"
}
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ConcurrencySal.h"
extern "C" {
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ConcurrencySal.h"
}
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 18
extern "C" {
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
typedef unsigned __int64 uintptr_t; 
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
typedef char *va_list; 
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
void __cdecl __va_start(va_list *, ...); 
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
}
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
extern "C++" {
#line 124
template< class _Ty> 
#line 125
struct __vcrt_va_list_is_reference { 
#line 127
enum: bool { __the_value}; 
#line 128
}; 
#line 130
template< class _Ty> 
#line 131
struct __vcrt_va_list_is_reference< _Ty &>  { 
#line 133
enum: bool { __the_value = '\001'}; 
#line 134
}; 
#line 136
template< class _Ty> 
#line 137
struct __vcrt_va_list_is_reference< _Ty &&>  { 
#line 139
enum: bool { __the_value = '\001'}; 
#line 140
}; 
#line 142
template < typename _Ty >
        void __vcrt_va_start_verify_argument_type ( ) throw ( )
        {
            static_assert ( ! __vcrt_va_list_is_reference < _Ty > :: __the_value, "va_start argument must not have reference type and must not be parenthesized" );
        }
#line 147
}
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vadefs.h"
#pragma pack ( pop )
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
typedef unsigned __int64 size_t; 
#include "crt/host_runtime.h"
#line 195
typedef __int64 ptrdiff_t; 
#line 196
typedef __int64 intptr_t; 
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
typedef bool __vcrt_bool; 
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
extern "C++" {
#line 249
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (& _Array)[_SizeOfArray]))[_SizeOfArray]; 
#line 253
}
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
void __cdecl __security_init_cookie(); 
#line 304
void __cdecl __security_check_cookie(uintptr_t _StackCookie); 
#line 305
__declspec(noreturn) void __cdecl __report_gsfailure(uintptr_t _StackCookie); 
#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
extern uintptr_t __security_cookie; 
#line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime.h"
}__pragma( pack ( pop )) 
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
extern "C++" {
#line 127
template< bool _Enable, class _Ty> struct _CrtEnableIf; 
#line 130
template< class _Ty> 
#line 131
struct _CrtEnableIf< true, _Ty>  { 
#line 133
typedef _Ty _Type; 
#line 134
}; 
#line 135
}
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
typedef bool __crt_bool; 
#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
__declspec(dllimport) void __cdecl _invalid_parameter(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); 
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(); 
#line 254
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(); 
#line 256
__declspec(noreturn) 
#line 257
__declspec(dllimport) void __cdecl _invoke_watson(const __wchar_t * _Expression, const __wchar_t * _FunctionName, const __wchar_t * _FileName, unsigned _LineNo, uintptr_t _Reserved); 
#line 482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
typedef int errno_t; 
#line 483
typedef unsigned short wint_t; 
#line 484
typedef unsigned short wctype_t; 
#line 485
typedef long __time32_t; 
#line 486
typedef __int64 __time64_t; 
#line 493
typedef 
#line 488
struct __crt_locale_data_public { 
#line 490
const unsigned short *_locale_pctype; 
#line 491
int _locale_mb_cur_max; 
#line 492
unsigned _locale_lc_codepage; 
#line 493
} __crt_locale_data_public; 
#line 499
typedef 
#line 495
struct __crt_locale_pointers { 
#line 497
struct __crt_locale_data *locinfo; 
#line 498
struct __crt_multibyte_data *mbcinfo; 
#line 499
} __crt_locale_pointers; 
#line 501
typedef __crt_locale_pointers *_locale_t; 
#line 507
typedef 
#line 503
struct _Mbstatet { 
#line 505
unsigned long _Wchar; 
#line 506
unsigned short _Byte, _State; 
#line 507
} _Mbstatet; 
#line 509
typedef _Mbstatet mbstate_t; 
#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
typedef __time64_t time_t; 
#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
typedef size_t rsize_t; 
#line 1982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt.h"
}__pragma( pack ( pop )) 
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_types.h"
#if 0
#line 61
enum cudaRoundMode { 
#line 63
cudaRoundNearest, 
#line 64
cudaRoundZero, 
#line 65
cudaRoundPosInf, 
#line 66
cudaRoundMinInf
#line 67
}; 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 93
struct char1 { 
#line 95
signed char x; 
#line 96
}; 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 98
struct uchar1 { 
#line 100
unsigned char x; 
#line 101
}; 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 104
struct __declspec(align(2)) char2 { 
#line 106
signed char x, y; 
#line 107
}; 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 109
struct __declspec(align(2)) uchar2 { 
#line 111
unsigned char x, y; 
#line 112
}; 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 114
struct char3 { 
#line 116
signed char x, y, z; 
#line 117
}; 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 119
struct uchar3 { 
#line 121
unsigned char x, y, z; 
#line 122
}; 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 124
struct __declspec(align(4)) char4 { 
#line 126
signed char x, y, z, w; 
#line 127
}; 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 129
struct __declspec(align(4)) uchar4 { 
#line 131
unsigned char x, y, z, w; 
#line 132
}; 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 134
struct short1 { 
#line 136
short x; 
#line 137
}; 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 139
struct ushort1 { 
#line 141
unsigned short x; 
#line 142
}; 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 144
struct __declspec(align(4)) short2 { 
#line 146
short x, y; 
#line 147
}; 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 149
struct __declspec(align(4)) ushort2 { 
#line 151
unsigned short x, y; 
#line 152
}; 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 154
struct short3 { 
#line 156
short x, y, z; 
#line 157
}; 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 159
struct ushort3 { 
#line 161
unsigned short x, y, z; 
#line 162
}; 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 164
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 165
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 167
struct int1 { 
#line 169
int x; 
#line 170
}; 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 172
struct uint1 { 
#line 174
unsigned x; 
#line 175
}; 
#endif
#line 177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 177
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 178
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 180
struct int3 { 
#line 182
int x, y, z; 
#line 183
}; 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 185
struct uint3 { 
#line 187
unsigned x, y, z; 
#line 188
}; 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 190
struct __declspec(align(16)) int4 { 
#line 192
int x, y, z, w; 
#line 193
}; 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 195
struct __declspec(align(16)) uint4 { 
#line 197
unsigned x, y, z, w; 
#line 198
}; 
#endif
#line 200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 200
struct long1 { 
#line 202
long x; 
#line 203
}; 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 205
struct ulong1 { 
#line 207
unsigned long x; 
#line 208
}; 
#endif
#line 211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 211
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 212
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 227
struct long3 { 
#line 229
long x, y, z; 
#line 230
}; 
#endif
#line 232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 232
struct ulong3 { 
#line 234
unsigned long x, y, z; 
#line 235
}; 
#endif
#line 237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 237
struct __declspec(align(16)) long4 { 
#line 239
long x, y, z, w; 
#line 240
}; 
#endif
#line 242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 242
struct __declspec(align(16)) ulong4 { 
#line 244
unsigned long x, y, z, w; 
#line 245
}; 
#endif
#line 247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 247
struct float1 { 
#line 249
float x; 
#line 250
}; 
#endif
#line 269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 269
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 274
struct float3 { 
#line 276
float x, y, z; 
#line 277
}; 
#endif
#line 279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 279
struct __declspec(align(16)) float4 { 
#line 281
float x, y, z, w; 
#line 282
}; 
#endif
#line 284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 284
struct longlong1 { 
#line 286
__int64 x; 
#line 287
}; 
#endif
#line 289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 289
struct ulonglong1 { 
#line 291
unsigned __int64 x; 
#line 292
}; 
#endif
#line 294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 294
struct __declspec(align(16)) longlong2 { 
#line 296
__int64 x, y; 
#line 297
}; 
#endif
#line 299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 299
struct __declspec(align(16)) ulonglong2 { 
#line 301
unsigned __int64 x, y; 
#line 302
}; 
#endif
#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 304
struct longlong3 { 
#line 306
__int64 x, y, z; 
#line 307
}; 
#endif
#line 309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 309
struct ulonglong3 { 
#line 311
unsigned __int64 x, y, z; 
#line 312
}; 
#endif
#line 314 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 314
struct __declspec(align(16)) longlong4 { 
#line 316
__int64 x, y, z, w; 
#line 317
}; 
#endif
#line 319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 319
struct __declspec(align(16)) ulonglong4 { 
#line 321
unsigned __int64 x, y, z, w; 
#line 322
}; 
#endif
#line 324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 324
struct double1 { 
#line 326
double x; 
#line 327
}; 
#endif
#line 329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 329
struct __declspec(align(16)) double2 { 
#line 331
double x, y; 
#line 332
}; 
#endif
#line 334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 334
struct double3 { 
#line 336
double x, y, z; 
#line 337
}; 
#endif
#line 339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 339
struct __declspec(align(16)) double4 { 
#line 341
double x, y, z, w; 
#line 342
}; 
#endif
#line 356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef char1 
#line 356
char1; 
#endif
#line 357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 357
uchar1; 
#endif
#line 358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef char2 
#line 358
char2; 
#endif
#line 359 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 359
uchar2; 
#endif
#line 360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef char3 
#line 360
char3; 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 361
uchar3; 
#endif
#line 362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef char4 
#line 362
char4; 
#endif
#line 363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 363
uchar4; 
#endif
#line 364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef short1 
#line 364
short1; 
#endif
#line 365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 365
ushort1; 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef short2 
#line 366
short2; 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 367
ushort2; 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef short3 
#line 368
short3; 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 369
ushort3; 
#endif
#line 370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef short4 
#line 370
short4; 
#endif
#line 371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 371
ushort4; 
#endif
#line 372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef int1 
#line 372
int1; 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uint1 
#line 373
uint1; 
#endif
#line 374 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef int2 
#line 374
int2; 
#endif
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uint2 
#line 375
uint2; 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef int3 
#line 376
int3; 
#endif
#line 377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uint3 
#line 377
uint3; 
#endif
#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef int4 
#line 378
int4; 
#endif
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef uint4 
#line 379
uint4; 
#endif
#line 380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef long1 
#line 380
long1; 
#endif
#line 381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 381
ulong1; 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef long2 
#line 382
long2; 
#endif
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 383
ulong2; 
#endif
#line 384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef long3 
#line 384
long3; 
#endif
#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 385
ulong3; 
#endif
#line 386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef long4 
#line 386
long4; 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 387
ulong4; 
#endif
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef float1 
#line 388
float1; 
#endif
#line 389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef float2 
#line 389
float2; 
#endif
#line 390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef float3 
#line 390
float3; 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef float4 
#line 391
float4; 
#endif
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 392
longlong1; 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 393
ulonglong1; 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 394
longlong2; 
#endif
#line 395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 395
ulonglong2; 
#endif
#line 396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 396
longlong3; 
#endif
#line 397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 397
ulonglong3; 
#endif
#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 398
longlong4; 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 399
ulonglong4; 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef double1 
#line 400
double1; 
#endif
#line 401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef double2 
#line 401
double2; 
#endif
#line 402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef double3 
#line 402
double3; 
#endif
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef double4 
#line 403
double4; 
#endif
#line 411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
#line 411
struct dim3 { 
#line 413
unsigned x, y, z; 
#line 419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
}; 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_types.h"
#if 0
typedef dim3 
#line 421
dim3; 
#endif
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 18
namespace std { 
#line 20
typedef decltype((__nullptr)) nullptr_t; 
#line 21
}
#line 23
using std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h"
__declspec(dllimport) int *__cdecl _errno(); 
#line 33
__declspec(dllimport) errno_t __cdecl _set_errno(int _Value); 
#line 34
__declspec(dllimport) errno_t __cdecl _get_errno(int * _Value); 
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stddef.h"
__declspec(dllimport) extern unsigned long __cdecl __threadid(); 
#line 52
__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(); 
#line 56
}__pragma( pack ( pop )) 
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 171
enum cudaError { 
#line 178
cudaSuccess, 
#line 184
cudaErrorMissingConfiguration, 
#line 190
cudaErrorMemoryAllocation, 
#line 196
cudaErrorInitializationError, 
#line 206
cudaErrorLaunchFailure, 
#line 215
cudaErrorPriorLaunchFailure, 
#line 226
cudaErrorLaunchTimeout, 
#line 235
cudaErrorLaunchOutOfResources, 
#line 241
cudaErrorInvalidDeviceFunction, 
#line 250
cudaErrorInvalidConfiguration, 
#line 256
cudaErrorInvalidDevice, 
#line 262
cudaErrorInvalidValue, 
#line 268
cudaErrorInvalidPitchValue, 
#line 274
cudaErrorInvalidSymbol, 
#line 279
cudaErrorMapBufferObjectFailed, 
#line 284
cudaErrorUnmapBufferObjectFailed, 
#line 290
cudaErrorInvalidHostPointer, 
#line 296
cudaErrorInvalidDevicePointer, 
#line 302
cudaErrorInvalidTexture, 
#line 308
cudaErrorInvalidTextureBinding, 
#line 315
cudaErrorInvalidChannelDescriptor, 
#line 321
cudaErrorInvalidMemcpyDirection, 
#line 331
cudaErrorAddressOfConstant, 
#line 340
cudaErrorTextureFetchFailed, 
#line 349
cudaErrorTextureNotBound, 
#line 358
cudaErrorSynchronizationError, 
#line 364
cudaErrorInvalidFilterSetting, 
#line 370
cudaErrorInvalidNormSetting, 
#line 378
cudaErrorMixedDeviceExecution, 
#line 385
cudaErrorCudartUnloading, 
#line 390
cudaErrorUnknown, 
#line 398
cudaErrorNotYetImplemented, 
#line 407
cudaErrorMemoryValueTooLarge, 
#line 414
cudaErrorInvalidResourceHandle, 
#line 422
cudaErrorNotReady, 
#line 429
cudaErrorInsufficientDriver, 
#line 442
cudaErrorSetOnActiveProcess, 
#line 448
cudaErrorInvalidSurface, 
#line 454
cudaErrorNoDevice, 
#line 460
cudaErrorECCUncorrectable, 
#line 465
cudaErrorSharedObjectSymbolNotFound, 
#line 470
cudaErrorSharedObjectInitFailed, 
#line 476
cudaErrorUnsupportedLimit, 
#line 482
cudaErrorDuplicateVariableName, 
#line 488
cudaErrorDuplicateTextureName, 
#line 494
cudaErrorDuplicateSurfaceName, 
#line 504
cudaErrorDevicesUnavailable, 
#line 509
cudaErrorInvalidKernelImage, 
#line 517
cudaErrorNoKernelImageForDevice, 
#line 530
cudaErrorIncompatibleDriverContext, 
#line 537
cudaErrorPeerAccessAlreadyEnabled, 
#line 544
cudaErrorPeerAccessNotEnabled, 
#line 550
cudaErrorDeviceAlreadyInUse = 54, 
#line 557
cudaErrorProfilerDisabled, 
#line 565
cudaErrorProfilerNotInitialized, 
#line 572
cudaErrorProfilerAlreadyStarted, 
#line 579
cudaErrorProfilerAlreadyStopped, 
#line 587
cudaErrorAssert, 
#line 594
cudaErrorTooManyPeers, 
#line 600
cudaErrorHostMemoryAlreadyRegistered, 
#line 606
cudaErrorHostMemoryNotRegistered, 
#line 611
cudaErrorOperatingSystem, 
#line 617
cudaErrorPeerAccessUnsupported, 
#line 624
cudaErrorLaunchMaxDepthExceeded, 
#line 632
cudaErrorLaunchFileScopedTex, 
#line 640
cudaErrorLaunchFileScopedSurf, 
#line 655
cudaErrorSyncDepthExceeded, 
#line 667
cudaErrorLaunchPendingCountExceeded, 
#line 672
cudaErrorNotPermitted, 
#line 678
cudaErrorNotSupported, 
#line 687
cudaErrorHardwareStackError, 
#line 695
cudaErrorIllegalInstruction, 
#line 704
cudaErrorMisalignedAddress, 
#line 715
cudaErrorInvalidAddressSpace, 
#line 723
cudaErrorInvalidPc, 
#line 731
cudaErrorIllegalAddress, 
#line 737
cudaErrorInvalidPtx, 
#line 742
cudaErrorInvalidGraphicsContext, 
#line 748
cudaErrorNvlinkUncorrectable, 
#line 755
cudaErrorJitCompilerNotFound, 
#line 764
cudaErrorCooperativeLaunchTooLarge, 
#line 769
cudaErrorStartupFailure = 127, 
#line 777
cudaErrorApiFailureBase = 10000
#line 778
}; 
#endif
#line 783 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 783
enum cudaChannelFormatKind { 
#line 785
cudaChannelFormatKindSigned, 
#line 786
cudaChannelFormatKindUnsigned, 
#line 787
cudaChannelFormatKindFloat, 
#line 788
cudaChannelFormatKindNone
#line 789
}; 
#endif
#line 794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 794
struct cudaChannelFormatDesc { 
#line 796
int x; 
#line 797
int y; 
#line 798
int z; 
#line 799
int w; 
#line 800
cudaChannelFormatKind f; 
#line 801
}; 
#endif
#line 806 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 811
typedef const cudaArray *cudaArray_const_t; 
#line 813
struct cudaArray; 
#line 818
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 823
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 825
struct cudaMipmappedArray; 
#line 830
#if 0
#line 830
enum cudaMemoryType { 
#line 832
cudaMemoryTypeHost = 1, 
#line 833
cudaMemoryTypeDevice
#line 834
}; 
#endif
#line 839 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 839
enum cudaMemcpyKind { 
#line 841
cudaMemcpyHostToHost, 
#line 842
cudaMemcpyHostToDevice, 
#line 843
cudaMemcpyDeviceToHost, 
#line 844
cudaMemcpyDeviceToDevice, 
#line 845
cudaMemcpyDefault
#line 846
}; 
#endif
#line 853 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 853
struct cudaPitchedPtr { 
#line 855
void *ptr; 
#line 856
size_t pitch; 
#line 857
size_t xsize; 
#line 858
size_t ysize; 
#line 859
}; 
#endif
#line 866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 866
struct cudaExtent { 
#line 868
size_t width; 
#line 869
size_t height; 
#line 870
size_t depth; 
#line 871
}; 
#endif
#line 878 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 878
struct cudaPos { 
#line 880
size_t x; 
#line 881
size_t y; 
#line 882
size_t z; 
#line 883
}; 
#endif
#line 888 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 888
struct cudaMemcpy3DParms { 
#line 890
cudaArray_t srcArray; 
#line 891
cudaPos srcPos; 
#line 892
cudaPitchedPtr srcPtr; 
#line 894
cudaArray_t dstArray; 
#line 895
cudaPos dstPos; 
#line 896
cudaPitchedPtr dstPtr; 
#line 898
cudaExtent extent; 
#line 899
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 900
}; 
#endif
#line 905 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 905
struct cudaMemcpy3DPeerParms { 
#line 907
cudaArray_t srcArray; 
#line 908
cudaPos srcPos; 
#line 909
cudaPitchedPtr srcPtr; 
#line 910
int srcDevice; 
#line 912
cudaArray_t dstArray; 
#line 913
cudaPos dstPos; 
#line 914
cudaPitchedPtr dstPtr; 
#line 915
int dstDevice; 
#line 917
cudaExtent extent; 
#line 918
}; 
#endif
#line 923 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 928
#if 0
#line 928
enum cudaGraphicsRegisterFlags { 
#line 930
cudaGraphicsRegisterFlagsNone, 
#line 931
cudaGraphicsRegisterFlagsReadOnly, 
#line 932
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 933
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 934
cudaGraphicsRegisterFlagsTextureGather = 8
#line 935
}; 
#endif
#line 940 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 940
enum cudaGraphicsMapFlags { 
#line 942
cudaGraphicsMapFlagsNone, 
#line 943
cudaGraphicsMapFlagsReadOnly, 
#line 944
cudaGraphicsMapFlagsWriteDiscard
#line 945
}; 
#endif
#line 950 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 950
enum cudaGraphicsCubeFace { 
#line 952
cudaGraphicsCubeFacePositiveX, 
#line 953
cudaGraphicsCubeFaceNegativeX, 
#line 954
cudaGraphicsCubeFacePositiveY, 
#line 955
cudaGraphicsCubeFaceNegativeY, 
#line 956
cudaGraphicsCubeFacePositiveZ, 
#line 957
cudaGraphicsCubeFaceNegativeZ
#line 958
}; 
#endif
#line 963 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 963
enum cudaResourceType { 
#line 965
cudaResourceTypeArray, 
#line 966
cudaResourceTypeMipmappedArray, 
#line 967
cudaResourceTypeLinear, 
#line 968
cudaResourceTypePitch2D
#line 969
}; 
#endif
#line 974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 974
enum cudaResourceViewFormat { 
#line 976
cudaResViewFormatNone, 
#line 977
cudaResViewFormatUnsignedChar1, 
#line 978
cudaResViewFormatUnsignedChar2, 
#line 979
cudaResViewFormatUnsignedChar4, 
#line 980
cudaResViewFormatSignedChar1, 
#line 981
cudaResViewFormatSignedChar2, 
#line 982
cudaResViewFormatSignedChar4, 
#line 983
cudaResViewFormatUnsignedShort1, 
#line 984
cudaResViewFormatUnsignedShort2, 
#line 985
cudaResViewFormatUnsignedShort4, 
#line 986
cudaResViewFormatSignedShort1, 
#line 987
cudaResViewFormatSignedShort2, 
#line 988
cudaResViewFormatSignedShort4, 
#line 989
cudaResViewFormatUnsignedInt1, 
#line 990
cudaResViewFormatUnsignedInt2, 
#line 991
cudaResViewFormatUnsignedInt4, 
#line 992
cudaResViewFormatSignedInt1, 
#line 993
cudaResViewFormatSignedInt2, 
#line 994
cudaResViewFormatSignedInt4, 
#line 995
cudaResViewFormatHalf1, 
#line 996
cudaResViewFormatHalf2, 
#line 997
cudaResViewFormatHalf4, 
#line 998
cudaResViewFormatFloat1, 
#line 999
cudaResViewFormatFloat2, 
#line 1000
cudaResViewFormatFloat4, 
#line 1001
cudaResViewFormatUnsignedBlockCompressed1, 
#line 1002
cudaResViewFormatUnsignedBlockCompressed2, 
#line 1003
cudaResViewFormatUnsignedBlockCompressed3, 
#line 1004
cudaResViewFormatUnsignedBlockCompressed4, 
#line 1005
cudaResViewFormatSignedBlockCompressed4, 
#line 1006
cudaResViewFormatUnsignedBlockCompressed5, 
#line 1007
cudaResViewFormatSignedBlockCompressed5, 
#line 1008
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 1009
cudaResViewFormatSignedBlockCompressed6H, 
#line 1010
cudaResViewFormatUnsignedBlockCompressed7
#line 1011
}; 
#endif
#line 1016 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1016
struct cudaResourceDesc { 
#line 1017
cudaResourceType resType; 
#line 1019
union { 
#line 1020
struct { 
#line 1021
cudaArray_t array; 
#line 1022
} array; 
#line 1023
struct { 
#line 1024
cudaMipmappedArray_t mipmap; 
#line 1025
} mipmap; 
#line 1026
struct { 
#line 1027
void *devPtr; 
#line 1028
cudaChannelFormatDesc desc; 
#line 1029
size_t sizeInBytes; 
#line 1030
} linear; 
#line 1031
struct { 
#line 1032
void *devPtr; 
#line 1033
cudaChannelFormatDesc desc; 
#line 1034
size_t width; 
#line 1035
size_t height; 
#line 1036
size_t pitchInBytes; 
#line 1037
} pitch2D; 
#line 1038
} res; 
#line 1039
}; 
#endif
#line 1044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1044
struct cudaResourceViewDesc { 
#line 1046
cudaResourceViewFormat format; 
#line 1047
size_t width; 
#line 1048
size_t height; 
#line 1049
size_t depth; 
#line 1050
unsigned firstMipmapLevel; 
#line 1051
unsigned lastMipmapLevel; 
#line 1052
unsigned firstLayer; 
#line 1053
unsigned lastLayer; 
#line 1054
}; 
#endif
#line 1059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1059
struct cudaPointerAttributes { 
#line 1065
cudaMemoryType memoryType; 
#line 1076
int device; 
#line 1082
void *devicePointer; 
#line 1088
void *hostPointer; 
#line 1093
int isManaged; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1094
}; 
#endif
#line 1099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1099
struct cudaFuncAttributes { 
#line 1106
size_t sharedSizeBytes; 
#line 1112
size_t constSizeBytes; 
#line 1117
size_t localSizeBytes; 
#line 1124
int maxThreadsPerBlock; 
#line 1129
int numRegs; 
#line 1136
int ptxVersion; 
#line 1143
int binaryVersion; 
#line 1149
int cacheModeCA; 
#line 1156
int maxDynamicSharedSizeBytes; 
#line 1163
int preferredShmemCarveout; 
#line 1164
}; 
#endif
#line 1169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1169
enum cudaFuncAttribute { 
#line 1171
cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
#line 1172
cudaFuncAttributePreferredSharedMemoryCarveout, 
#line 1173
cudaFuncAttributeMax
#line 1174
}; 
#endif
#line 1179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1179
enum cudaFuncCache { 
#line 1181
cudaFuncCachePreferNone, 
#line 1182
cudaFuncCachePreferShared, 
#line 1183
cudaFuncCachePreferL1, 
#line 1184
cudaFuncCachePreferEqual
#line 1185
}; 
#endif
#line 1191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1191
enum cudaSharedMemConfig { 
#line 1193
cudaSharedMemBankSizeDefault, 
#line 1194
cudaSharedMemBankSizeFourByte, 
#line 1195
cudaSharedMemBankSizeEightByte
#line 1196
}; 
#endif
#line 1201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1201
enum cudaSharedCarveout { 
#line 1202
cudaSharedmemCarveoutDefault = (-1), 
#line 1203
cudaSharedmemCarveoutMaxShared = 100, 
#line 1204
cudaSharedmemCarveoutMaxL1 = 0
#line 1205
}; 
#endif
#line 1210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1210
enum cudaComputeMode { 
#line 1212
cudaComputeModeDefault, 
#line 1213
cudaComputeModeExclusive, 
#line 1214
cudaComputeModeProhibited, 
#line 1215
cudaComputeModeExclusiveProcess
#line 1216
}; 
#endif
#line 1221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1221
enum cudaLimit { 
#line 1223
cudaLimitStackSize, 
#line 1224
cudaLimitPrintfFifoSize, 
#line 1225
cudaLimitMallocHeapSize, 
#line 1226
cudaLimitDevRuntimeSyncDepth, 
#line 1227
cudaLimitDevRuntimePendingLaunchCount
#line 1228
}; 
#endif
#line 1233 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1233
enum cudaMemoryAdvise { 
#line 1235
cudaMemAdviseSetReadMostly = 1, 
#line 1236
cudaMemAdviseUnsetReadMostly, 
#line 1237
cudaMemAdviseSetPreferredLocation, 
#line 1238
cudaMemAdviseUnsetPreferredLocation, 
#line 1239
cudaMemAdviseSetAccessedBy, 
#line 1240
cudaMemAdviseUnsetAccessedBy
#line 1241
}; 
#endif
#line 1246 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1246
enum cudaMemRangeAttribute { 
#line 1248
cudaMemRangeAttributeReadMostly = 1, 
#line 1249
cudaMemRangeAttributePreferredLocation, 
#line 1250
cudaMemRangeAttributeAccessedBy, 
#line 1251
cudaMemRangeAttributeLastPrefetchLocation
#line 1252
}; 
#endif
#line 1257 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1257
enum cudaOutputMode { 
#line 1259
cudaKeyValuePair, 
#line 1260
cudaCSV
#line 1261
}; 
#endif
#line 1266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1266
enum cudaDeviceAttr { 
#line 1268
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1269
cudaDevAttrMaxBlockDimX, 
#line 1270
cudaDevAttrMaxBlockDimY, 
#line 1271
cudaDevAttrMaxBlockDimZ, 
#line 1272
cudaDevAttrMaxGridDimX, 
#line 1273
cudaDevAttrMaxGridDimY, 
#line 1274
cudaDevAttrMaxGridDimZ, 
#line 1275
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1276
cudaDevAttrTotalConstantMemory, 
#line 1277
cudaDevAttrWarpSize, 
#line 1278
cudaDevAttrMaxPitch, 
#line 1279
cudaDevAttrMaxRegistersPerBlock, 
#line 1280
cudaDevAttrClockRate, 
#line 1281
cudaDevAttrTextureAlignment, 
#line 1282
cudaDevAttrGpuOverlap, 
#line 1283
cudaDevAttrMultiProcessorCount, 
#line 1284
cudaDevAttrKernelExecTimeout, 
#line 1285
cudaDevAttrIntegrated, 
#line 1286
cudaDevAttrCanMapHostMemory, 
#line 1287
cudaDevAttrComputeMode, 
#line 1288
cudaDevAttrMaxTexture1DWidth, 
#line 1289
cudaDevAttrMaxTexture2DWidth, 
#line 1290
cudaDevAttrMaxTexture2DHeight, 
#line 1291
cudaDevAttrMaxTexture3DWidth, 
#line 1292
cudaDevAttrMaxTexture3DHeight, 
#line 1293
cudaDevAttrMaxTexture3DDepth, 
#line 1294
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1295
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1296
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1297
cudaDevAttrSurfaceAlignment, 
#line 1298
cudaDevAttrConcurrentKernels, 
#line 1299
cudaDevAttrEccEnabled, 
#line 1300
cudaDevAttrPciBusId, 
#line 1301
cudaDevAttrPciDeviceId, 
#line 1302
cudaDevAttrTccDriver, 
#line 1303
cudaDevAttrMemoryClockRate, 
#line 1304
cudaDevAttrGlobalMemoryBusWidth, 
#line 1305
cudaDevAttrL2CacheSize, 
#line 1306
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1307
cudaDevAttrAsyncEngineCount, 
#line 1308
cudaDevAttrUnifiedAddressing, 
#line 1309
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1310
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1311
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1312
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1313
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1314
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1315
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1316
cudaDevAttrPciDomainId, 
#line 1317
cudaDevAttrTexturePitchAlignment, 
#line 1318
cudaDevAttrMaxTextureCubemapWidth, 
#line 1319
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1320
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1321
cudaDevAttrMaxSurface1DWidth, 
#line 1322
cudaDevAttrMaxSurface2DWidth, 
#line 1323
cudaDevAttrMaxSurface2DHeight, 
#line 1324
cudaDevAttrMaxSurface3DWidth, 
#line 1325
cudaDevAttrMaxSurface3DHeight, 
#line 1326
cudaDevAttrMaxSurface3DDepth, 
#line 1327
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1328
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1329
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1330
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1331
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1332
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1333
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1334
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1335
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1336
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1337
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1338
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1339
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1340
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1341
cudaDevAttrComputeCapabilityMajor, 
#line 1342
cudaDevAttrComputeCapabilityMinor, 
#line 1343
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1344
cudaDevAttrStreamPrioritiesSupported, 
#line 1345
cudaDevAttrGlobalL1CacheSupported, 
#line 1346
cudaDevAttrLocalL1CacheSupported, 
#line 1347
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
#line 1348
cudaDevAttrMaxRegistersPerMultiprocessor, 
#line 1349
cudaDevAttrManagedMemory, 
#line 1350
cudaDevAttrIsMultiGpuBoard, 
#line 1351
cudaDevAttrMultiGpuBoardGroupID, 
#line 1352
cudaDevAttrHostNativeAtomicSupported, 
#line 1353
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
#line 1354
cudaDevAttrPageableMemoryAccess, 
#line 1355
cudaDevAttrConcurrentManagedAccess, 
#line 1356
cudaDevAttrComputePreemptionSupported, 
#line 1357
cudaDevAttrCanUseHostPointerForRegisteredMem, 
#line 1358
cudaDevAttrReserved92, 
#line 1359
cudaDevAttrReserved93, 
#line 1360
cudaDevAttrReserved94, 
#line 1361
cudaDevAttrCooperativeLaunch, 
#line 1362
cudaDevAttrCooperativeMultiDeviceLaunch, 
#line 1363
cudaDevAttrMaxSharedMemoryPerBlockOptin
#line 1364
}; 
#endif
#line 1370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1370
enum cudaDeviceP2PAttr { 
#line 1371
cudaDevP2PAttrPerformanceRank = 1, 
#line 1372
cudaDevP2PAttrAccessSupported, 
#line 1373
cudaDevP2PAttrNativeAtomicSupported
#line 1374
}; 
#endif
#line 1378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1378
struct cudaDeviceProp { 
#line 1380
char name[256]; 
#line 1381
size_t totalGlobalMem; 
#line 1382
size_t sharedMemPerBlock; 
#line 1383
int regsPerBlock; 
#line 1384
int warpSize; 
#line 1385
size_t memPitch; 
#line 1386
int maxThreadsPerBlock; 
#line 1387
int maxThreadsDim[3]; 
#line 1388
int maxGridSize[3]; 
#line 1389
int clockRate; 
#line 1390
size_t totalConstMem; 
#line 1391
int major; 
#line 1392
int minor; 
#line 1393
size_t textureAlignment; 
#line 1394
size_t texturePitchAlignment; 
#line 1395
int deviceOverlap; 
#line 1396
int multiProcessorCount; 
#line 1397
int kernelExecTimeoutEnabled; 
#line 1398
int integrated; 
#line 1399
int canMapHostMemory; 
#line 1400
int computeMode; 
#line 1401
int maxTexture1D; 
#line 1402
int maxTexture1DMipmap; 
#line 1403
int maxTexture1DLinear; 
#line 1404
int maxTexture2D[2]; 
#line 1405
int maxTexture2DMipmap[2]; 
#line 1406
int maxTexture2DLinear[3]; 
#line 1407
int maxTexture2DGather[2]; 
#line 1408
int maxTexture3D[3]; 
#line 1409
int maxTexture3DAlt[3]; 
#line 1410
int maxTextureCubemap; 
#line 1411
int maxTexture1DLayered[2]; 
#line 1412
int maxTexture2DLayered[3]; 
#line 1413
int maxTextureCubemapLayered[2]; 
#line 1414
int maxSurface1D; 
#line 1415
int maxSurface2D[2]; 
#line 1416
int maxSurface3D[3]; 
#line 1417
int maxSurface1DLayered[2]; 
#line 1418
int maxSurface2DLayered[3]; 
#line 1419
int maxSurfaceCubemap; 
#line 1420
int maxSurfaceCubemapLayered[2]; 
#line 1421
size_t surfaceAlignment; 
#line 1422
int concurrentKernels; 
#line 1423
int ECCEnabled; 
#line 1424
int pciBusID; 
#line 1425
int pciDeviceID; 
#line 1426
int pciDomainID; 
#line 1427
int tccDriver; 
#line 1428
int asyncEngineCount; 
#line 1429
int unifiedAddressing; 
#line 1430
int memoryClockRate; 
#line 1431
int memoryBusWidth; 
#line 1432
int l2CacheSize; 
#line 1433
int maxThreadsPerMultiProcessor; 
#line 1434
int streamPrioritiesSupported; 
#line 1435
int globalL1CacheSupported; 
#line 1436
int localL1CacheSupported; 
#line 1437
size_t sharedMemPerMultiprocessor; 
#line 1438
int regsPerMultiprocessor; 
#line 1439
int managedMemory; 
#line 1440
int isMultiGpuBoard; 
#line 1441
int multiGpuBoardGroupID; 
#line 1442
int hostNativeAtomicSupported; 
#line 1443
int singleToDoublePrecisionPerfRatio; 
#line 1444
int pageableMemoryAccess; 
#line 1445
int concurrentManagedAccess; 
#line 1446
int computePreemptionSupported; 
#line 1447
int canUseHostPointerForRegisteredMem; 
#line 1448
int cooperativeLaunch; 
#line 1449
int cooperativeMultiDeviceLaunch; 
#line 1450
size_t sharedMemPerBlockOptin; 
#line 1451
}; 
#endif
#line 1539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef 
#line 1536
struct cudaIpcEventHandle_st { 
#line 1538
char reserved[64]; 
#line 1539
} cudaIpcEventHandle_t; 
#endif
#line 1547 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef 
#line 1544
struct cudaIpcMemHandle_st { 
#line 1546
char reserved[64]; 
#line 1547
} cudaIpcMemHandle_t; 
#endif
#line 1558 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 1558
cudaError_t; 
#endif
#line 1563 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 1563
cudaStream_t; 
#endif
#line 1568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 1568
cudaEvent_t; 
#endif
#line 1573 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 1573
cudaGraphicsResource_t; 
#endif
#line 1578 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef struct CUuuid_st 
#line 1578
cudaUUID_t; 
#endif
#line 1583 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
typedef cudaOutputMode 
#line 1583
cudaOutputMode_t; 
#endif
#line 1588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1588
enum cudaCGScope { 
#line 1589
cudaCGScopeInvalid, 
#line 1590
cudaCGScopeGrid, 
#line 1591
cudaCGScopeMultiGrid
#line 1592
}; 
#endif
#line 1597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_types.h"
#if 0
#line 1597
struct cudaLaunchParams { 
#line 1599
void *func; 
#line 1600
dim3 gridDim; 
#line 1601
dim3 blockDim; 
#line 1602
void **args; 
#line 1603
size_t sharedMem; 
#line 1604
cudaStream_t stream; 
#line 1605
}; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_types.h"
#if 0
#line 84
enum cudaSurfaceBoundaryMode { 
#line 86
cudaBoundaryModeZero, 
#line 87
cudaBoundaryModeClamp, 
#line 88
cudaBoundaryModeTrap
#line 89
}; 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_types.h"
#if 0
#line 94
enum cudaSurfaceFormatMode { 
#line 96
cudaFormatModeForced, 
#line 97
cudaFormatModeAuto
#line 98
}; 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_types.h"
#if 0
#line 103
struct surfaceReference { 
#line 108
cudaChannelFormatDesc channelDesc; 
#line 109
}; 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 114
cudaSurfaceObject_t; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_types.h"
#if 0
#line 84
enum cudaTextureAddressMode { 
#line 86
cudaAddressModeWrap, 
#line 87
cudaAddressModeClamp, 
#line 88
cudaAddressModeMirror, 
#line 89
cudaAddressModeBorder
#line 90
}; 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_types.h"
#if 0
#line 95
enum cudaTextureFilterMode { 
#line 97
cudaFilterModePoint, 
#line 98
cudaFilterModeLinear
#line 99
}; 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_types.h"
#if 0
#line 104
enum cudaTextureReadMode { 
#line 106
cudaReadModeElementType, 
#line 107
cudaReadModeNormalizedFloat
#line 108
}; 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_types.h"
#if 0
#line 113
struct textureReference { 
#line 118
int normalized; 
#line 122
cudaTextureFilterMode filterMode; 
#line 126
cudaTextureAddressMode addressMode[3]; 
#line 130
cudaChannelFormatDesc channelDesc; 
#line 134
int sRGB; 
#line 138
unsigned maxAnisotropy; 
#line 142
cudaTextureFilterMode mipmapFilterMode; 
#line 146
float mipmapLevelBias; 
#line 150
float minMipmapLevelClamp; 
#line 154
float maxMipmapLevelClamp; 
#line 155
int __cudaReserved[15]; 
#line 156
}; 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_types.h"
#if 0
#line 161
struct cudaTextureDesc { 
#line 166
cudaTextureAddressMode addressMode[3]; 
#line 170
cudaTextureFilterMode filterMode; 
#line 174
cudaTextureReadMode readMode; 
#line 178
int sRGB; 
#line 182
float borderColor[4]; 
#line 186
int normalizedCoords; 
#line 190
unsigned maxAnisotropy; 
#line 194
cudaTextureFilterMode mipmapFilterMode; 
#line 198
float mipmapLevelBias; 
#line 202
float minMipmapLevelClamp; 
#line 206
float maxMipmapLevelClamp; 
#line 207
}; 
#endif
#line 212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 212
cudaTextureObject_t; 
#endif
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\library_types.h"
typedef 
#line 54
enum cudaDataType_t { 
#line 56
CUDA_R_16F = 2, 
#line 57
CUDA_C_16F = 6, 
#line 58
CUDA_R_32F = 0, 
#line 59
CUDA_C_32F = 4, 
#line 60
CUDA_R_64F = 1, 
#line 61
CUDA_C_64F = 5, 
#line 62
CUDA_R_8I = 3, 
#line 63
CUDA_C_8I = 7, 
#line 64
CUDA_R_8U, 
#line 65
CUDA_C_8U, 
#line 66
CUDA_R_32I, 
#line 67
CUDA_C_32I, 
#line 68
CUDA_R_32U, 
#line 69
CUDA_C_32U
#line 70
} cudaDataType; 
#line 78
typedef 
#line 73
enum libraryPropertyType_t { 
#line 75
MAJOR_VERSION, 
#line 76
MINOR_VERSION, 
#line 77
PATCH_LEVEL
#line 78
} libraryPropertyType; 
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_device_runtime_api.h"
extern "C" {
#line 123
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 124
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 125
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 126
extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 127
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 128
extern cudaError_t __stdcall cudaGetLastError(); 
#line 129
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 130
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 131
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 132
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 133
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 134
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 135
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 136
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 137
extern cudaError_t __stdcall cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 138
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 139
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
#line 140
extern cudaError_t __stdcall cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
#line 141
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 142
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 143
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 144
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 145
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 146
extern cudaError_t __stdcall cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 147
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 148
extern cudaError_t __stdcall cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 149
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 150
extern cudaError_t __stdcall cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 151
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 152
extern cudaError_t __stdcall cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 153
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 154
extern cudaError_t __stdcall cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 155
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 156
extern cudaError_t __stdcall cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 157
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 178
extern void *__stdcall cudaGetParameterBuffer(size_t alignment, size_t size); 
#line 206
extern void *__stdcall cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
#line 207
extern cudaError_t __stdcall cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 208
extern cudaError_t __stdcall cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 227
extern cudaError_t __stdcall cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
#line 230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
#line 231
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 233
extern unsigned __int64 __stdcall cudaCGGetIntrinsicHandle(cudaCGScope scope); 
#line 234
extern cudaError_t __stdcall cudaCGSynchronize(unsigned __int64 handle, unsigned flags); 
#line 235
extern cudaError_t __stdcall cudaCGGetSize(unsigned * numThreads, unsigned * numGrids, unsigned __int64 handle); 
#line 236
extern cudaError_t __stdcall cudaCGGetRank(unsigned * threadRank, unsigned * gridRank, unsigned __int64 handle); 
#line 237
}
#line 239
template< class T> static __inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
#line 240
template< class T> static __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
#line 241
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
#line 242
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_runtime_api.h"
extern "C" {
#line 251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceReset(); 
#line 270
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 347
extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit limit, size_t value); 
#line 378
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 410
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 446
extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
#line 489
extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
#line 519
extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 562
extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
#line 587
extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
#line 615
extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
#line 660
extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
#line 698
extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
#line 739
extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
#line 792
extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
#line 825
extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * devPtr); 
#line 865
extern cudaError_t __stdcall cudaThreadExit(); 
#line 889
extern cudaError_t __stdcall cudaThreadSynchronize(); 
#line 936
extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit limit, size_t value); 
#line 967
extern cudaError_t __stdcall cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
#line 1002
extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 1048
extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
#line 1104
extern cudaError_t __stdcall cudaGetLastError(); 
#line 1147
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 1163
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 1179
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 1210
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 1470
extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
#line 1647
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 1683
extern cudaError_t __stdcall cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
#line 1702
extern cudaError_t __stdcall cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
#line 1737
extern cudaError_t __stdcall cudaSetDevice(int device); 
#line 1755
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 1784
extern cudaError_t __stdcall cudaSetValidDevices(int * device_arr, int len); 
#line 1847
extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned flags); 
#line 1890
extern cudaError_t __stdcall cudaGetDeviceFlags(unsigned * flags); 
#line 1928
extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * pStream); 
#line 1958
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 2002
extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
#line 2027
extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
#line 2050
extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
#line 2079
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 2103
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 2117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_runtime_api.h"
typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
#line 2175
extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
#line 2197
extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream); 
#line 2220
extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream); 
#line 2292
extern cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
#line 2329
extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * event); 
#line 2365
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 2403
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
#line 2433
extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t event); 
#line 2462
extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event); 
#line 2488
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 2530
extern cudaError_t __stdcall cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
#line 2593
extern cudaError_t __stdcall cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 2648
extern cudaError_t __stdcall cudaLaunchCooperativeKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 2745
extern cudaError_t __stdcall cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams * launchParamsList, unsigned numDevices, unsigned flags = 0); 
#line 2794
extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
#line 2849
extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
#line 2884
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 2920
extern cudaError_t __stdcall cudaFuncSetAttribute(const void * func, cudaFuncAttribute attr, int value); 
#line 2944
extern cudaError_t __stdcall cudaSetDoubleForDevice(double * d); 
#line 2968
extern cudaError_t __stdcall cudaSetDoubleForHost(double * d); 
#line 3023
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
#line 3067
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
#line 3117
extern cudaError_t __stdcall cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0); 
#line 3146
extern cudaError_t __stdcall cudaSetupArgument(const void * arg, size_t size, size_t offset); 
#line 3187
extern cudaError_t __stdcall cudaLaunch(const void * func); 
#line 3306
extern cudaError_t __stdcall cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
#line 3334
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 3365
extern cudaError_t __stdcall cudaMallocHost(void ** ptr, size_t size); 
#line 3406
extern cudaError_t __stdcall cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
#line 3450
extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
#line 3478
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 3500
extern cudaError_t __stdcall cudaFreeHost(void * ptr); 
#line 3523
extern cudaError_t __stdcall cudaFreeArray(cudaArray_t array); 
#line 3546
extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
#line 3610
extern cudaError_t __stdcall cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
#line 3691
extern cudaError_t __stdcall cudaHostRegister(void * ptr, size_t size, unsigned flags); 
#line 3712
extern cudaError_t __stdcall cudaHostUnregister(void * ptr); 
#line 3755
extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
#line 3775
extern cudaError_t __stdcall cudaHostGetFlags(unsigned * pFlags, void * pHost); 
#line 3812
extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
#line 3949
extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
#line 4086
extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
#line 4113
extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
#line 4216
extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * p); 
#line 4245
extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
#line 4361
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
#line 4385
extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
#line 4406
extern cudaError_t __stdcall cudaMemGetInfo(size_t * free, size_t * total); 
#line 4430
extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
#line 4471
extern cudaError_t __stdcall cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 4504
extern cudaError_t __stdcall cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
#line 4543
extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
#line 4581
extern cudaError_t __stdcall cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
#line 4620
extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 4666
extern cudaError_t __stdcall cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 4713
extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 4760
extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
#line 4805
extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 4846
extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
#line 4887
extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
#line 4941
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 4974
extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
#line 5021
extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5067
extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5127
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5182
extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5236
extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5285
extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5334
extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5361
extern cudaError_t __stdcall cudaMemset(void * devPtr, int value, size_t count); 
#line 5393
extern cudaError_t __stdcall cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
#line 5435
extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
#line 5469
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
#line 5508
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
#line 5557
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
#line 5583
extern cudaError_t __stdcall cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
#line 5608
extern cudaError_t __stdcall cudaGetSymbolSize(size_t * size, const void * symbol); 
#line 5676
extern cudaError_t __stdcall cudaMemPrefetchAsync(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
#line 5763
extern cudaError_t __stdcall cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
#line 5820
extern cudaError_t __stdcall cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
#line 5857
extern cudaError_t __stdcall cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
#line 6011
extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
#line 6050
extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
#line 6090
extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
#line 6110
extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice); 
#line 6171
extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
#line 6204
extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
#line 6241
extern cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 6274
extern cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 6304
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
#line 6340
extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
#line 6367
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
#line 6407
extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
#line 6443
extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
#line 6494
extern cudaError_t __stdcall cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = 4294967295U); 
#line 6549
extern cudaError_t __stdcall cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
#line 6583
extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
#line 6619
extern cudaError_t __stdcall cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
#line 6640
extern cudaError_t __stdcall cudaUnbindTexture(const textureReference * texref); 
#line 6665
extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
#line 6691
extern cudaError_t __stdcall cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
#line 6732
extern cudaError_t __stdcall cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
#line 6753
extern cudaError_t __stdcall cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
#line 6981
extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
#line 6998
extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject); 
#line 7016
extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
#line 7034
extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
#line 7053
extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
#line 7094
extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
#line 7111
extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
#line 7128
extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
#line 7157
extern cudaError_t __stdcall cudaDriverGetVersion(int * driverVersion); 
#line 7176
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 7181
extern cudaError_t __stdcall cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
#line 7409 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_runtime_api.h"
}
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 108
{ 
#line 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 110
} 
#line 112
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 113
{ 
#line 114
int e = (((int)sizeof(unsigned short)) * 8); 
#line 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 117
} 
#line 119
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 120
{ 
#line 121
int e = (((int)sizeof(unsigned short)) * 8); 
#line 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 124
} 
#line 126
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 127
{ 
#line 128
int e = (((int)sizeof(unsigned short)) * 8); 
#line 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 131
} 
#line 133
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 134
{ 
#line 135
int e = (((int)sizeof(unsigned short)) * 8); 
#line 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 138
} 
#line 140
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 141
{ 
#line 142
int e = (((int)sizeof(char)) * 8); 
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\channel_descriptor.h"
} 
#line 151
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 152
{ 
#line 153
int e = (((int)sizeof(signed char)) * 8); 
#line 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 156
} 
#line 158
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 159
{ 
#line 160
int e = (((int)sizeof(unsigned char)) * 8); 
#line 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 163
} 
#line 165
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 166
{ 
#line 167
int e = (((int)sizeof(signed char)) * 8); 
#line 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 170
} 
#line 172
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 173
{ 
#line 174
int e = (((int)sizeof(unsigned char)) * 8); 
#line 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 177
} 
#line 179
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 180
{ 
#line 181
int e = (((int)sizeof(signed char)) * 8); 
#line 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 184
} 
#line 186
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 187
{ 
#line 188
int e = (((int)sizeof(unsigned char)) * 8); 
#line 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 191
} 
#line 193
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 194
{ 
#line 195
int e = (((int)sizeof(signed char)) * 8); 
#line 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 198
} 
#line 200
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 201
{ 
#line 202
int e = (((int)sizeof(unsigned char)) * 8); 
#line 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 205
} 
#line 207
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 208
{ 
#line 209
int e = (((int)sizeof(short)) * 8); 
#line 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 212
} 
#line 214
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 215
{ 
#line 216
int e = (((int)sizeof(unsigned short)) * 8); 
#line 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 219
} 
#line 221
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 222
{ 
#line 223
int e = (((int)sizeof(short)) * 8); 
#line 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 226
} 
#line 228
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 229
{ 
#line 230
int e = (((int)sizeof(unsigned short)) * 8); 
#line 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 233
} 
#line 235
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 236
{ 
#line 237
int e = (((int)sizeof(short)) * 8); 
#line 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 240
} 
#line 242
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 243
{ 
#line 244
int e = (((int)sizeof(unsigned short)) * 8); 
#line 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 247
} 
#line 249
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 250
{ 
#line 251
int e = (((int)sizeof(short)) * 8); 
#line 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 254
} 
#line 256
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 257
{ 
#line 258
int e = (((int)sizeof(unsigned short)) * 8); 
#line 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 261
} 
#line 263
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 264
{ 
#line 265
int e = (((int)sizeof(int)) * 8); 
#line 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 268
} 
#line 270
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 271
{ 
#line 272
int e = (((int)sizeof(unsigned)) * 8); 
#line 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 275
} 
#line 277
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 278
{ 
#line 279
int e = (((int)sizeof(int)) * 8); 
#line 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 282
} 
#line 284
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 285
{ 
#line 286
int e = (((int)sizeof(unsigned)) * 8); 
#line 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 289
} 
#line 291
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 292
{ 
#line 293
int e = (((int)sizeof(int)) * 8); 
#line 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 296
} 
#line 298
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 299
{ 
#line 300
int e = (((int)sizeof(unsigned)) * 8); 
#line 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 303
} 
#line 305
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 306
{ 
#line 307
int e = (((int)sizeof(int)) * 8); 
#line 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 310
} 
#line 312
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 313
{ 
#line 314
int e = (((int)sizeof(unsigned)) * 8); 
#line 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 317
} 
#line 321
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 322
{ 
#line 323
int e = (((int)sizeof(long)) * 8); 
#line 325
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 326
} 
#line 328
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 329
{ 
#line 330
int e = (((int)sizeof(unsigned long)) * 8); 
#line 332
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 333
} 
#line 335
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 336
{ 
#line 337
int e = (((int)sizeof(long)) * 8); 
#line 339
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 340
} 
#line 342
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 343
{ 
#line 344
int e = (((int)sizeof(unsigned long)) * 8); 
#line 346
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 347
} 
#line 349
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 350
{ 
#line 351
int e = (((int)sizeof(long)) * 8); 
#line 353
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 354
} 
#line 356
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 357
{ 
#line 358
int e = (((int)sizeof(unsigned long)) * 8); 
#line 360
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 361
} 
#line 363
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 364
{ 
#line 365
int e = (((int)sizeof(long)) * 8); 
#line 367
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 368
} 
#line 370
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 371
{ 
#line 372
int e = (((int)sizeof(unsigned long)) * 8); 
#line 374
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 375
} 
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 380
{ 
#line 381
int e = (((int)sizeof(float)) * 8); 
#line 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 384
} 
#line 386
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 387
{ 
#line 388
int e = (((int)sizeof(float)) * 8); 
#line 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 391
} 
#line 393
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 394
{ 
#line 395
int e = (((int)sizeof(float)) * 8); 
#line 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 398
} 
#line 400
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 401
{ 
#line 402
int e = (((int)sizeof(float)) * 8); 
#line 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 405
} 
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 75 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x); 
#line 77
static __inline uchar1 make_uchar1(unsigned char x); 
#line 79
static __inline char2 make_char2(signed char x, signed char y); 
#line 81
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
#line 83
static __inline char3 make_char3(signed char x, signed char y, signed char z); 
#line 85
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
#line 87
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
#line 89
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
#line 91
static __inline short1 make_short1(short x); 
#line 93
static __inline ushort1 make_ushort1(unsigned short x); 
#line 95
static __inline short2 make_short2(short x, short y); 
#line 97
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
#line 99
static __inline short3 make_short3(short x, short y, short z); 
#line 101
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
#line 103
static __inline short4 make_short4(short x, short y, short z, short w); 
#line 105
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
#line 107
static __inline int1 make_int1(int x); 
#line 109
static __inline uint1 make_uint1(unsigned x); 
#line 111
static __inline int2 make_int2(int x, int y); 
#line 113
static __inline uint2 make_uint2(unsigned x, unsigned y); 
#line 115
static __inline int3 make_int3(int x, int y, int z); 
#line 117
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
#line 119
static __inline int4 make_int4(int x, int y, int z, int w); 
#line 121
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
#line 123
static __inline long1 make_long1(long x); 
#line 125
static __inline ulong1 make_ulong1(unsigned long x); 
#line 127
static __inline long2 make_long2(long x, long y); 
#line 129
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
#line 131
static __inline long3 make_long3(long x, long y, long z); 
#line 133
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
#line 135
static __inline long4 make_long4(long x, long y, long z, long w); 
#line 137
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
#line 139
static __inline float1 make_float1(float x); 
#line 141
static __inline float2 make_float2(float x, float y); 
#line 143
static __inline float3 make_float3(float x, float y, float z); 
#line 145
static __inline float4 make_float4(float x, float y, float z, float w); 
#line 147
static __inline longlong1 make_longlong1(__int64 x); 
#line 149
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x); 
#line 151
static __inline longlong2 make_longlong2(__int64 x, __int64 y); 
#line 153
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y); 
#line 155
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z); 
#line 157
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z); 
#line 159
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w); 
#line 161
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w); 
#line 163
static __inline double1 make_double1(double x); 
#line 165
static __inline double2 make_double2(double x, double y); 
#line 167
static __inline double3 make_double3(double x, double y, double z); 
#line 169
static __inline double4 make_double4(double x, double y, double z, double w); 
#line 75 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\vector_functions.hpp"
static __inline char1 make_char1(signed char x) 
#line 76
{ 
#line 77
char1 t; (t.x) = x; return t; 
#line 78
} 
#line 80
static __inline uchar1 make_uchar1(unsigned char x) 
#line 81
{ 
#line 82
uchar1 t; (t.x) = x; return t; 
#line 83
} 
#line 85
static __inline char2 make_char2(signed char x, signed char y) 
#line 86
{ 
#line 87
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 88
} 
#line 90
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 91
{ 
#line 92
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 93
} 
#line 95
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 96
{ 
#line 97
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 98
} 
#line 100
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 101
{ 
#line 102
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 103
} 
#line 105
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 106
{ 
#line 107
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 108
} 
#line 110
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 111
{ 
#line 112
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 113
} 
#line 115
static __inline short1 make_short1(short x) 
#line 116
{ 
#line 117
short1 t; (t.x) = x; return t; 
#line 118
} 
#line 120
static __inline ushort1 make_ushort1(unsigned short x) 
#line 121
{ 
#line 122
ushort1 t; (t.x) = x; return t; 
#line 123
} 
#line 125
static __inline short2 make_short2(short x, short y) 
#line 126
{ 
#line 127
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 128
} 
#line 130
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 131
{ 
#line 132
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 133
} 
#line 135
static __inline short3 make_short3(short x, short y, short z) 
#line 136
{ 
#line 137
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 138
} 
#line 140
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 141
{ 
#line 142
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 143
} 
#line 145
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 146
{ 
#line 147
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 148
} 
#line 150
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 151
{ 
#line 152
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 153
} 
#line 155
static __inline int1 make_int1(int x) 
#line 156
{ 
#line 157
int1 t; (t.x) = x; return t; 
#line 158
} 
#line 160
static __inline uint1 make_uint1(unsigned x) 
#line 161
{ 
#line 162
uint1 t; (t.x) = x; return t; 
#line 163
} 
#line 165
static __inline int2 make_int2(int x, int y) 
#line 166
{ 
#line 167
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 168
} 
#line 170
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 171
{ 
#line 172
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 173
} 
#line 175
static __inline int3 make_int3(int x, int y, int z) 
#line 176
{ 
#line 177
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 178
} 
#line 180
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 181
{ 
#line 182
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 183
} 
#line 185
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 186
{ 
#line 187
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 188
} 
#line 190
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 191
{ 
#line 192
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 193
} 
#line 195
static __inline long1 make_long1(long x) 
#line 196
{ 
#line 197
long1 t; (t.x) = x; return t; 
#line 198
} 
#line 200
static __inline ulong1 make_ulong1(unsigned long x) 
#line 201
{ 
#line 202
ulong1 t; (t.x) = x; return t; 
#line 203
} 
#line 205
static __inline long2 make_long2(long x, long y) 
#line 206
{ 
#line 207
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 208
} 
#line 210
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 211
{ 
#line 212
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 213
} 
#line 215
static __inline long3 make_long3(long x, long y, long z) 
#line 216
{ 
#line 217
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 218
} 
#line 220
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 221
{ 
#line 222
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 223
} 
#line 225
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 226
{ 
#line 227
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 228
} 
#line 230
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 231
{ 
#line 232
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 233
} 
#line 235
static __inline float1 make_float1(float x) 
#line 236
{ 
#line 237
float1 t; (t.x) = x; return t; 
#line 238
} 
#line 240
static __inline float2 make_float2(float x, float y) 
#line 241
{ 
#line 242
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 243
} 
#line 245
static __inline float3 make_float3(float x, float y, float z) 
#line 246
{ 
#line 247
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 248
} 
#line 250
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 251
{ 
#line 252
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 253
} 
#line 255
static __inline longlong1 make_longlong1(__int64 x) 
#line 256
{ 
#line 257
longlong1 t; (t.x) = x; return t; 
#line 258
} 
#line 260
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 261
{ 
#line 262
ulonglong1 t; (t.x) = x; return t; 
#line 263
} 
#line 265
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 266
{ 
#line 267
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 268
} 
#line 270
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 271
{ 
#line 272
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 273
} 
#line 275
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 276
{ 
#line 277
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 278
} 
#line 280
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 281
{ 
#line 282
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 283
} 
#line 285
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 286
{ 
#line 287
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 288
} 
#line 290
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 291
{ 
#line 292
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 293
} 
#line 295
static __inline double1 make_double1(double x) 
#line 296
{ 
#line 297
double1 t; (t.x) = x; return t; 
#line 298
} 
#line 300
static __inline double2 make_double2(double x, double y) 
#line 301
{ 
#line 302
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 303
} 
#line 305
static __inline double3 make_double3(double x, double y, double z) 
#line 306
{ 
#line 307
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 308
} 
#line 310
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 311
{ 
#line 312
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 313
} 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 18
__declspec(dllimport) int *__cdecl _errno(); 
#line 21
__declspec(dllimport) errno_t __cdecl _set_errno(int _Value); 
#line 22
__declspec(dllimport) errno_t __cdecl _get_errno(int * _Value); 
#line 24
__declspec(dllimport) unsigned long *__cdecl __doserrno(); 
#line 27
__declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 28
__declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\errno.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
__declspec(dllimport) const void *__cdecl memchr(const void * _Buf, int _Val, size_t _MaxCount); 
#line 26
int __cdecl memcmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h"
void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); 
#line 47
__declspec(dllimport) void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); 
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_string.h"
void *__cdecl memset(void * _Dst, int _Val, size_t _Size); 
#line 67
__declspec(dllimport) const char *__cdecl strchr(const char * _Str, int _Val); 
#line 73
__declspec(dllimport) const char *__cdecl strrchr(const char * _Str, int _Ch); 
#line 79
__declspec(dllimport) const char *__cdecl strstr(const char * _Str, const char * _SubStr); 
#line 86
__declspec(dllimport) const __wchar_t *__cdecl wcschr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 92
__declspec(dllimport) const __wchar_t *__cdecl wcsrchr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 99
__declspec(dllimport) const __wchar_t *__cdecl wcsstr(const __wchar_t * _Str, const __wchar_t * _SubStr); 
#line 106
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"
static __inline errno_t __cdecl memcpy_s(void *const 
#line 36
_Destination, const rsize_t 
#line 37
_DestinationSize, const void *const 
#line 38
_Source, const rsize_t 
#line 39
_SourceSize) 
#line 41
{ 
#line 42
if (_SourceSize == (0)) 
#line 43
{ 
#line 44
return 0; 
#line 45
}  
#line 47
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 48
if ((_Source == (0)) || (_DestinationSize < _SourceSize)) 
#line 49
{ 
#line 50
memset(_Destination, 0, _DestinationSize); 
#line 52
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 53
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 56
return 22; 
#line 57
}  
#line 59
memcpy(_Destination, _Source, _SourceSize); 
#line 60
return 0; 
#line 61
} 
#line 64
static __inline errno_t __cdecl memmove_s(void *const 
#line 65
_Destination, const rsize_t 
#line 66
_DestinationSize, const void *const 
#line 67
_Source, const rsize_t 
#line 68
_SourceSize) 
#line 70
{ 
#line 71
if (_SourceSize == (0)) 
#line 72
{ 
#line 73
return 0; 
#line 74
}  
#line 76
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 77
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 78
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 80
memmove(_Destination, _Source, _SourceSize); 
#line 81
return 0; 
#line 82
} 
#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memcpy_s.h"
}__pragma( pack ( pop )) 
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 24
__declspec(dllimport) int __cdecl _memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 31
__declspec(dllimport) int __cdecl _memicmp_l(const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale); 
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h"
__declspec(dllimport) void *__cdecl memccpy(void * _Dst, const void * _Src, int _Val, size_t _Size); 
#line 87
__declspec(dllimport) int __cdecl memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h"
extern "C++" inline void *__cdecl memchr(void *
#line 101
_Pv, int 
#line 102
_C, size_t 
#line 103
_N) 
#line 105
{ 
#line 106
const void *const _Pvc = _Pv; 
#line 107
return const_cast< void *>(memchr(_Pvc, _C, _N)); 
#line 108
} 
#line 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_memory.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 28
__declspec(dllimport) errno_t __cdecl wcscat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 35
__declspec(dllimport) errno_t __cdecl wcscpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 42
__declspec(dllimport) errno_t __cdecl wcsncat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 50
__declspec(dllimport) errno_t __cdecl wcsncpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 58
__declspec(dllimport) __wchar_t *__cdecl wcstok_s(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wcsdup(const __wchar_t * _String); 
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscat_s ( _Destination, _Size, _Source ); }}
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl wcscmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 114
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscpy_s ( _Destination, _Size, _Source ); }}
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 131
__declspec(dllimport) size_t __cdecl wcscspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 137
__declspec(dllimport) size_t __cdecl wcslen(const __wchar_t * _String); 
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(const __wchar_t * _Source, size_t _MaxCount); 
#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
static __inline size_t __cdecl wcsnlen_s(const __wchar_t *
#line 167
_Source, size_t 
#line 168
_MaxCount) 
#line 170
{ 
#line 171
return (_Source == (0)) ? 0 : wcsnlen(_Source, _MaxCount); 
#line 172
} 
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl wcsncat(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl wcsncmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 198
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl wcsncpy(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) const __wchar_t *__cdecl wcspbrk(const __wchar_t * _String, const __wchar_t * _Control); 
#line 220
__declspec(dllimport) size_t __cdecl wcsspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 226
__declspec(dllimport) __wchar_t *__cdecl wcstok(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 4141 4996)
#line 247
static __inline __wchar_t *__cdecl _wcstok(__wchar_t *const 
#line 248
_String, const __wchar_t *const 
#line 249
_Delimiter) 
#line 251
{ 
#line 252
return wcstok(_String, _Delimiter, 0); 
#line 253
} 
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
extern "C++" 
#line 260
__declspec(deprecated("wcstok has been changed to conform with the ISO C standard, adding an extra context parameter. To use the legacy Microsoft wcsto" "k, define _CRT_NON_CONFORMING_WCSTOK.")) inline __wchar_t *__cdecl 
#line 261
wcstok(__wchar_t *
#line 262
_String, const __wchar_t *
#line 263
_Delimiter) throw() 
#line 265
{ 
#line 266
return wcstok(_String, _Delimiter, 0); 
#line 267
} 
#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcserror(int _ErrorNumber); 
#line 283
__declspec(dllimport) errno_t __cdecl _wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, int _ErrorNumber); 
#line 289
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }}
#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl __wcserror(const __wchar_t * _String); 
#line 302
__declspec(dllimport) errno_t __cdecl __wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _ErrorMessage); 
#line 308
extern "C++" {template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl _wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 319
__declspec(dllimport) int __cdecl _wcsicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 325
__declspec(dllimport) int __cdecl _wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 331
__declspec(dllimport) int __cdecl _wcsnicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 338
__declspec(dllimport) errno_t __cdecl _wcsnset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value, size_t _MaxCount); 
#line 345
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t _Value, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Destination, _Size, _Value, _MaxCount ); }}
#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsrev(__wchar_t * _String); 
#line 364
__declspec(dllimport) errno_t __cdecl _wcsset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value); 
#line 370
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _String ) [ _Size ], wchar_t _Value ) throw ( ) { return _wcsset_s ( _String, _Size, _Value ); }}
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcslwr_s(__wchar_t * _String, size_t _SizeInWords); 
#line 388
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }}
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcslwr(__wchar_t * _String); 
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(__wchar_t * _String, size_t _SizeInWords, _locale_t _Locale); 
#line 405
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }}
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcslwr_l(__wchar_t * _String, _locale_t _Locale); 
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcsupr_s(__wchar_t * _String, size_t _Size); 
#line 424
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }}
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsupr(__wchar_t * _String); 
#line 435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(__wchar_t * _String, size_t _Size, _locale_t _Locale); 
#line 441
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }}
#line 447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsupr_l(__wchar_t * _String, _locale_t _Locale); 
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsxfrm(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount); 
#line 464
__declspec(dllimport) size_t __cdecl _wcsxfrm_l(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 472
__declspec(dllimport) int __cdecl wcscoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 478
__declspec(dllimport) int __cdecl _wcscoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 485
__declspec(dllimport) int __cdecl _wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 491
__declspec(dllimport) int __cdecl _wcsicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 498
__declspec(dllimport) int __cdecl _wcsncoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 505
__declspec(dllimport) int __cdecl _wcsncoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 513
__declspec(dllimport) int __cdecl _wcsnicoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 520
__declspec(dllimport) int __cdecl _wcsnicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 535
extern "C++" {
#line 539
inline __wchar_t *__cdecl wcschr(__wchar_t *_String, __wchar_t _C) 
#line 540
{ 
#line 541
return const_cast< __wchar_t *>(wcschr(static_cast< const __wchar_t *>(_String), _C)); 
#line 542
} 
#line 545
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_String, const __wchar_t *_Control) 
#line 546
{ 
#line 547
return const_cast< __wchar_t *>(wcspbrk(static_cast< const __wchar_t *>(_String), _Control)); 
#line 548
} 
#line 551
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_String, __wchar_t _C) 
#line 552
{ 
#line 553
return const_cast< __wchar_t *>(wcsrchr(static_cast< const __wchar_t *>(_String), _C)); 
#line 554
} 
#line 558
inline __wchar_t *__cdecl wcsstr(__wchar_t *_String, const __wchar_t *_SubStr) 
#line 559
{ 
#line 560
return const_cast< __wchar_t *>(wcsstr(static_cast< const __wchar_t *>(_String), _SubStr)); 
#line 561
} 
#line 563
}
#line 580 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl wcsdup(const __wchar_t * _String); 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 598
__declspec(dllimport) int __cdecl wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 606
__declspec(dllimport) __wchar_t *__cdecl wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 614
__declspec(dllimport) __wchar_t *__cdecl wcsrev(__wchar_t * _String); 
#line 620
__declspec(dllimport) __wchar_t *__cdecl wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 627
__declspec(dllimport) __wchar_t *__cdecl wcslwr(__wchar_t * _String); 
#line 633
__declspec(dllimport) __wchar_t *__cdecl wcsupr(__wchar_t * _String); 
#line 638
__declspec(dllimport) int __cdecl wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstring.h"
}__pragma( pack ( pop )) 
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 27
__declspec(dllimport) errno_t __cdecl strcpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 34
__declspec(dllimport) errno_t __cdecl strcat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 41
__declspec(dllimport) errno_t __cdecl strerror_s(char * _Buffer, size_t _SizeInBytes, int _ErrorNumber); 
#line 47
__declspec(dllimport) errno_t __cdecl strncat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 55
__declspec(dllimport) errno_t __cdecl strncpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 63
__declspec(dllimport) char *__cdecl strtok_s(char * _String, const char * _Delimiter, char ** _Context); 
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) void *__cdecl _memccpy(void * _Dst, const void * _Src, int _Val, size_t _MaxCount); 
#line 78
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcat_s ( _Destination, _Size, _Source ); }}
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
char *__cdecl strcat(char * _Destination, const char * _Source); 
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
#pragma warning(pop)
#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
int __cdecl strcmp(const char * _Str1, const char * _Str2); 
#line 105
__declspec(dllimport) int __cdecl _strcmpi(const char * _String1, const char * _String2); 
#line 111
__declspec(dllimport) int __cdecl strcoll(const char * _String1, const char * _String2); 
#line 117
__declspec(dllimport) int __cdecl _strcoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 123
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcpy_s ( _Destination, _Size, _Source ); }}
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
char *__cdecl strcpy(char * _Destination, const char * _Source); 
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
#pragma warning(pop)
#line 140
__declspec(dllimport) size_t __cdecl strcspn(const char * _Str, const char * _Control); 
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _strdup(const char * _Source); 
#line 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strerror(const char * _ErrorMessage); 
#line 167
__declspec(dllimport) errno_t __cdecl _strerror_s(char * _Buffer, size_t _SizeInBytes, const char * _ErrorMessage); 
#line 173
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], char const * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strerror(int _ErrorMessage); 
#line 185
extern "C++" {template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) int __cdecl _stricmp(const char * _String1, const char * _String2); 
#line 198
__declspec(dllimport) int __cdecl _stricoll(const char * _String1, const char * _String2); 
#line 204
__declspec(dllimport) int __cdecl _stricoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 211
__declspec(dllimport) int __cdecl _stricmp_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 218
size_t __cdecl strlen(const char * _Str); 
#line 223
__declspec(dllimport) errno_t __cdecl _strlwr_s(char * _String, size_t _Size); 
#line 228
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }}
#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strlwr(char * _String); 
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) errno_t __cdecl _strlwr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 245
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }}
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strlwr_l(char * _String, _locale_t _Locale); 
#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strncat(char * _Destination, const char * _Source, size_t _Count); 
#line 274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) int __cdecl strncmp(const char * _Str1, const char * _Str2, size_t _MaxCount); 
#line 281
__declspec(dllimport) int __cdecl _strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 288
__declspec(dllimport) int __cdecl _strnicmp_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 296
__declspec(dllimport) int __cdecl _strnicoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 303
__declspec(dllimport) int __cdecl _strnicoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 311
__declspec(dllimport) int __cdecl _strncoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 318
__declspec(dllimport) int __cdecl _strncoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 325
__declspec(dllimport) size_t __cdecl __strncnt(const char * _String, size_t _Count); 
#line 330
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strncpy(char * _Destination, const char * _Source, size_t _Count); 
#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(const char * _String, size_t _MaxCount); 
#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
static __inline size_t __cdecl strnlen_s(const char *
#line 371
_String, size_t 
#line 372
_MaxCount) 
#line 374
{ 
#line 375
return (_String == (0)) ? 0 : strnlen(_String, _MaxCount); 
#line 376
} 
#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) errno_t __cdecl _strnset_s(char * _String, size_t _SizeInBytes, int _Value, size_t _MaxCount); 
#line 388
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Destination ) [ _Size ], int _Value, size_t _Count ) throw ( ) { return _strnset_s ( _Destination, _Size, _Value, _Count ); }}
#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strnset(char * _Destination, int _Value, size_t _Count); 
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) const char *__cdecl strpbrk(const char * _Str, const char * _Control); 
#line 409
__declspec(dllimport) char *__cdecl _strrev(char * _Str); 
#line 414
__declspec(dllimport) errno_t __cdecl _strset_s(char * _Destination, size_t _DestinationSize, int _Value); 
#line 420
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Destination ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Destination, _Size, _Value ); }}
#line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
char *__cdecl _strset(char * _Destination, int _Value); 
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strspn(const char * _Str, const char * _Control); 
#line 439
__declspec(dllimport) char *__cdecl strtok(char * _String, const char * _Delimiter); 
#line 445
__declspec(dllimport) errno_t __cdecl _strupr_s(char * _String, size_t _Size); 
#line 450
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }}
#line 455 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strupr(char * _String); 
#line 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) errno_t __cdecl _strupr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 467
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }}
#line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strupr_l(char * _String, _locale_t _Locale); 
#line 482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strxfrm(char * _Destination, const char * _Source, size_t _MaxCount); 
#line 490
__declspec(dllimport) size_t __cdecl _strxfrm_l(char * _Destination, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 500
extern "C++" {
#line 503
inline char *__cdecl strchr(char *const _String, const int _Ch) 
#line 504
{ 
#line 505
return const_cast< char *>(strchr(static_cast< const char *>(_String), _Ch)); 
#line 506
} 
#line 509
inline char *__cdecl strpbrk(char *const _String, const char *const _Control) 
#line 510
{ 
#line 511
return const_cast< char *>(strpbrk(static_cast< const char *>(_String), _Control)); 
#line 512
} 
#line 515
inline char *__cdecl strrchr(char *const _String, const int _Ch) 
#line 516
{ 
#line 517
return const_cast< char *>(strrchr(static_cast< const char *>(_String), _Ch)); 
#line 518
} 
#line 521
inline char *__cdecl strstr(char *const _String, const char *const _SubString) 
#line 522
{ 
#line 523
return const_cast< char *>(strstr(static_cast< const char *>(_String), _SubString)); 
#line 524
} 
#line 525
}
#line 538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strdup(const char * _String); 
#line 548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
__declspec(dllimport) int __cdecl strcmpi(const char * _String1, const char * _String2); 
#line 554
__declspec(dllimport) int __cdecl stricmp(const char * _String1, const char * _String2); 
#line 560
__declspec(dllimport) char *__cdecl strlwr(char * _String); 
#line 565
__declspec(dllimport) int __cdecl strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 572
__declspec(dllimport) char *__cdecl strnset(char * _String, int _Value, size_t _MaxCount); 
#line 579
__declspec(dllimport) char *__cdecl strrev(char * _String); 
#line 584
char *__cdecl strset(char * _String, int _Value); 
#line 589
__declspec(dllimport) char *__cdecl strupr(char * _String); 
#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\string.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 22
struct tm { 
#line 24
int tm_sec; 
#line 25
int tm_min; 
#line 26
int tm_hour; 
#line 27
int tm_mday; 
#line 28
int tm_mon; 
#line 29
int tm_year; 
#line 30
int tm_wday; 
#line 31
int tm_yday; 
#line 32
int tm_isdst; 
#line 33
}; 
#line 44
__declspec(dllimport) __wchar_t *__cdecl _wasctime(const tm * _Tm); 
#line 50
__declspec(dllimport) errno_t __cdecl _wasctime_s(__wchar_t * _Buffer, size_t _SizeInWords, const tm * _Tm); 
#line 56
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }}
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) size_t __cdecl wcsftime(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm); 
#line 74
__declspec(dllimport) size_t __cdecl _wcsftime_l(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm, _locale_t _Locale); 
#line 84
__declspec(dllimport) __wchar_t *__cdecl _wctime32(const __time32_t * _Time); 
#line 89
__declspec(dllimport) errno_t __cdecl _wctime32_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time32_t * _Time); 
#line 95
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }}
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) __wchar_t *__cdecl _wctime64(const __time64_t * _Time); 
#line 109
__declspec(dllimport) errno_t __cdecl _wctime64_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time64_t * _Time); 
#line 114
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }}
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) errno_t __cdecl _wstrdate_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 126
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }}
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) __wchar_t *__cdecl _wstrdate(__wchar_t * _Buffer); 
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) errno_t __cdecl _wstrtime_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 142
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }}
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) __wchar_t *__cdecl _wstrtime(__wchar_t * _Buffer); 
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
#pragma warning(push)
#pragma warning(disable: 4996)
#line 185
static __inline __wchar_t *__cdecl _wctime(const time_t *const 
#line 186
_Time) 
#line 187
{ 
#line 188
return _wctime64(_Time); 
#line 189
} 
#line 192
static __inline errno_t __cdecl _wctime_s(__wchar_t *const 
#line 193
_Buffer, const size_t 
#line 194
_SizeInWords, const time_t *const 
#line 195
_Time) 
#line 197
{ 
#line 198
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 199
} 
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
}
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
#pragma warning(pop)
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wtime.h"
__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 23
typedef long clock_t; 
#line 25
struct _timespec32 { 
#line 27
__time32_t tv_sec; 
#line 28
long tv_nsec; 
#line 29
}; 
#line 31
struct _timespec64 { 
#line 33
__time64_t tv_sec; 
#line 34
long tv_nsec; 
#line 35
}; 
#line 38
struct timespec { 
#line 40
time_t tv_sec; 
#line 41
long tv_nsec; 
#line 42
}; 
#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) int *__cdecl __daylight(); 
#line 67
__declspec(dllimport) long *__cdecl __dstbias(); 
#line 73
__declspec(dllimport) long *__cdecl __timezone(); 
#line 79
__declspec(dllimport) char **__cdecl __tzname(); 
#line 84
__declspec(dllimport) errno_t __cdecl _get_daylight(int * _Daylight); 
#line 89
__declspec(dllimport) errno_t __cdecl _get_dstbias(long * _DaylightSavingsBias); 
#line 94
__declspec(dllimport) errno_t __cdecl _get_timezone(long * _TimeZone); 
#line 99
__declspec(dllimport) errno_t __cdecl _get_tzname(size_t * _ReturnValue, char * _Buffer, size_t _SizeInBytes, int _Index); 
#line 116
__declspec(dllimport) char *__cdecl asctime(const tm * _Tm); 
#line 123
__declspec(dllimport) errno_t __cdecl asctime_s(char * _Buffer, size_t _SizeInBytes, const tm * _Tm); 
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }}
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) clock_t __cdecl clock(); 
#line 142
__declspec(dllimport) char *__cdecl _ctime32(const __time32_t * _Time); 
#line 147
__declspec(dllimport) errno_t __cdecl _ctime32_s(char * _Buffer, size_t _SizeInBytes, const __time32_t * _Time); 
#line 153
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }}
#line 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) char *__cdecl _ctime64(const __time64_t * _Time); 
#line 167
__declspec(dllimport) errno_t __cdecl _ctime64_s(char * _Buffer, size_t _SizeInBytes, const __time64_t * _Time); 
#line 173
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }}
#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) double __cdecl _difftime32(__time32_t _Time1, __time32_t _Time2); 
#line 186
__declspec(dllimport) double __cdecl _difftime64(__time64_t _Time1, __time64_t _Time2); 
#line 193
__declspec(dllimport) tm *__cdecl _gmtime32(const __time32_t * _Time); 
#line 198
__declspec(dllimport) errno_t __cdecl _gmtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 205
__declspec(dllimport) tm *__cdecl _gmtime64(const __time64_t * _Time); 
#line 210
__declspec(dllimport) errno_t __cdecl _gmtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 217
__declspec(dllimport) tm *__cdecl _localtime32(const __time32_t * _Time); 
#line 222
__declspec(dllimport) errno_t __cdecl _localtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 229
__declspec(dllimport) tm *__cdecl _localtime64(const __time64_t * _Time); 
#line 234
__declspec(dllimport) errno_t __cdecl _localtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 240
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(tm * _Tm); 
#line 245
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(tm * _Tm); 
#line 250
__declspec(dllimport) __time32_t __cdecl _mktime32(tm * _Tm); 
#line 255
__declspec(dllimport) __time64_t __cdecl _mktime64(tm * _Tm); 
#line 261
__declspec(dllimport) size_t __cdecl strftime(char * _Buffer, size_t _SizeInBytes, const char * _Format, const tm * _Tm); 
#line 270
__declspec(dllimport) size_t __cdecl _strftime_l(char * _Buffer, size_t _MaxSize, const char * _Format, const tm * _Tm, _locale_t _Locale); 
#line 279
__declspec(dllimport) errno_t __cdecl _strdate_s(char * _Buffer, size_t _SizeInBytes); 
#line 284
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }}
#line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) char *__cdecl _strdate(char * _Buffer); 
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) errno_t __cdecl _strtime_s(char * _Buffer, size_t _SizeInBytes); 
#line 300
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }}
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) char *__cdecl _strtime(char * _Buffer); 
#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) __time32_t __cdecl _time32(__time32_t * _Time); 
#line 314
__declspec(dllimport) __time64_t __cdecl _time64(__time64_t * _Time); 
#line 320
__declspec(dllimport) int __cdecl _timespec32_get(_timespec32 * _Ts, int _Base); 
#line 327
__declspec(dllimport) int __cdecl _timespec64_get(_timespec64 * _Ts, int _Base); 
#line 341
__declspec(dllimport) void __cdecl _tzset(); 
#line 344
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) 
#line 345
__declspec(dllimport) unsigned __cdecl _getsystime(tm * _Tm); 
#line 349
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) 
#line 350
__declspec(dllimport) unsigned __cdecl _setsystime(tm * _Tm, unsigned _Milliseconds); 
#line 475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
static __inline char *__cdecl ctime(const time_t *const 
#line 476
_Time) 
#line 478
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _ctime64(_Time); 
#pragma warning(pop)
} 
#line 486
static __inline double __cdecl difftime(const time_t 
#line 487
_Time1, const time_t 
#line 488
_Time2) 
#line 490
{ 
#line 491
return _difftime64(_Time1, _Time2); 
#line 492
} 
#line 495
static __inline tm *__cdecl gmtime(const time_t *const 
#line 496
_Time) 
#line 497
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _gmtime64(_Time); 
#pragma warning(pop)
} 
#line 505
static __inline tm *__cdecl localtime(const time_t *const 
#line 506
_Time) 
#line 508
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _localtime64(_Time); 
#pragma warning(pop)
} 
#line 516
static __inline time_t __cdecl _mkgmtime(tm *const 
#line 517
_Tm) 
#line 519
{ 
#line 520
return _mkgmtime64(_Tm); 
#line 521
} 
#line 524
static __inline time_t __cdecl mktime(tm *const 
#line 525
_Tm) 
#line 527
{ 
#line 528
return _mktime64(_Tm); 
#line 529
} 
#line 531
static __inline time_t __cdecl time(time_t *const 
#line 532
_Time) 
#line 534
{ 
#line 535
return _time64(_Time); 
#line 536
} 
#line 539
static __inline int __cdecl timespec_get(timespec *const 
#line 540
_Ts, const int 
#line 541
_Base) 
#line 543
{ 
#line 544
return _timespec64_get((_timespec64 *)_Ts, _Base); 
#line 545
} 
#line 549
static __inline errno_t __cdecl ctime_s(char *const 
#line 550
_Buffer, const size_t 
#line 551
_SizeInBytes, const time_t *const 
#line 552
_Time) 
#line 554
{ 
#line 555
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 556
} 
#line 559
static __inline errno_t __cdecl gmtime_s(tm *const 
#line 560
_Tm, const time_t *const 
#line 561
_Time) 
#line 563
{ 
#line 564
return _gmtime64_s(_Tm, _Time); 
#line 565
} 
#line 568
static __inline errno_t __cdecl localtime_s(tm *const 
#line 569
_Tm, const time_t *const 
#line 570
_Time) 
#line 572
{ 
#line 573
return _localtime64_s(_Tm, _Time); 
#line 574
} 
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
__declspec(dllimport) void __cdecl tzset(); 
#line 600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\time.h"
}__pragma( pack ( pop )) 
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt/common_functions.h"
extern "C" {
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt/common_functions.h"
__declspec(dllimport) extern clock_t __cdecl clock(); 
#line 78 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt/common_functions.h"
extern void *__cdecl memset(void *, int, size_t); 
#line 79
extern void *__cdecl memcpy(void *, const void *, size_t); 
#line 81
}
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern "C" {
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern int __cdecl abs(int); 
#line 169
extern long __cdecl labs(long); 
#line 170
extern __int64 llabs(__int64); 
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double __cdecl fabs(double x); 
#line 261
extern __inline float fabsf(float x); 
#line 265 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline int min(int, int); 
#line 267
extern inline unsigned umin(unsigned, unsigned); 
#line 268
extern inline __int64 llmin(__int64, __int64); 
#line 269
extern inline unsigned __int64 ullmin(unsigned __int64, unsigned __int64); 
#line 292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fminf(float x, float y); 
#line 312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fmin(double x, double y); 
#line 317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline int max(int, int); 
#line 319
extern inline unsigned umax(unsigned, unsigned); 
#line 320
extern inline __int64 llmax(__int64, __int64); 
#line 321
extern inline unsigned __int64 ullmax(unsigned __int64, unsigned __int64); 
#line 344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fmaxf(float x, float y); 
#line 364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fmax(double, double); 
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double __cdecl sin(double x); 
#line 439
extern double __cdecl cos(double x); 
#line 458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern void sincos(double x, double * sptr, double * cptr); 
#line 474
extern void sincosf(float x, float * sptr, float * cptr); 
#line 519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double __cdecl tan(double x); 
#line 588
extern double __cdecl sqrt(double x); 
#line 660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double rsqrt(double x); 
#line 730
extern float rsqrtf(float x); 
#line 788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl log2(double x); 
#line 813 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl exp2(double x); 
#line 838 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl exp2f(float x); 
#line 863 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double exp10(double x); 
#line 886
extern float exp10f(float x); 
#line 934 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl expm1(double x); 
#line 979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl expm1f(float x); 
#line 1034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl log2f(float x); 
#line 1086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double __cdecl log10(double x); 
#line 1157
extern double __cdecl log(double x); 
#line 1253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl log1p(double x); 
#line 1350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl log1pf(float x); 
#line 1423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl floor(double x); 
#line 1462
extern double __cdecl exp(double x); 
#line 1493
extern double __cdecl cosh(double x); 
#line 1523
extern double __cdecl sinh(double x); 
#line 1553
extern double __cdecl tanh(double x); 
#line 1590 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl acosh(double x); 
#line 1628 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl acoshf(float x); 
#line 1644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl asinh(double x); 
#line 1660 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl asinhf(float x); 
#line 1714 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl atanh(double x); 
#line 1768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl atanhf(float x); 
#line 1825 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl ldexp(double x, int exp); 
#line 1881
extern __inline float ldexpf(float x, int exp); 
#line 1935 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl logb(double x); 
#line 1990 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl logbf(float x); 
#line 2020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern int __cdecl ilogb(double x); 
#line 2050 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern int __cdecl ilogbf(float x); 
#line 2126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl scalbn(double x, int n); 
#line 2202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl scalbnf(float x, int n); 
#line 2278 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl scalbln(double x, long n); 
#line 2354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl scalblnf(float x, long n); 
#line 2430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl frexp(double x, int * nptr); 
#line 2505
extern __inline float frexpf(float x, int * nptr); 
#line 2521 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl round(double x); 
#line 2538 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl roundf(float x); 
#line 2556 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lround(double x); 
#line 2574 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lroundf(float x); 
#line 2592 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llround(double x); 
#line 2610 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llroundf(float x); 
#line 2662 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl rintf(float x); 
#line 2678 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lrint(double x); 
#line 2694 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lrintf(float x); 
#line 2710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llrint(double x); 
#line 2726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llrintf(float x); 
#line 2779 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl nearbyint(double x); 
#line 2832 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl nearbyintf(float x); 
#line 2892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl ceil(double x); 
#line 2906 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl trunc(double x); 
#line 2921 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl truncf(float x); 
#line 2947 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fdim(double x, double y); 
#line 2973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fdimf(float x, float y); 
#line 3007 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double __cdecl atan2(double y, double x); 
#line 3038
extern double __cdecl atan(double x); 
#line 3061
extern double __cdecl acos(double x); 
#line 3093
extern double __cdecl asin(double x); 
#line 3136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl hypot(double x, double y); 
#line 3191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double rhypot(double x, double y); 
#line 3235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline float __cdecl hypotf(float x, float y); 
#line 3289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float rhypotf(float x, float y); 
#line 3333
__declspec(dllimport) extern double __cdecl norm3d(double a, double b, double c); 
#line 3384
extern double rnorm3d(double a, double b, double c); 
#line 3433
__declspec(dllimport) extern double __cdecl norm4d(double a, double b, double c, double d); 
#line 3489
extern double rnorm4d(double a, double b, double c, double d); 
#line 3534
extern double norm(int dim, const double * t); 
#line 3585
extern double rnorm(int dim, const double * t); 
#line 3637
extern float rnormf(int dim, const float * a); 
#line 3681
extern float normf(int dim, const float * a); 
#line 3726
extern float norm3df(float a, float b, float c); 
#line 3777
extern float rnorm3df(float a, float b, float c); 
#line 3826
extern float norm4df(float a, float b, float c, float d); 
#line 3882
extern float rnorm4df(float a, float b, float c, float d); 
#line 3971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl cbrt(double x); 
#line 4057 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl cbrtf(float x); 
#line 4110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double rcbrt(double x); 
#line 4160
extern float rcbrtf(float x); 
#line 4220
extern double sinpi(double x); 
#line 4280
extern float sinpif(float x); 
#line 4332
extern double cospi(double x); 
#line 4384
extern float cospif(float x); 
#line 4414
extern void sincospi(double x, double * sptr, double * cptr); 
#line 4444
extern void sincospif(float x, float * sptr, float * cptr); 
#line 4756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double __cdecl pow(double x, double y); 
#line 4812
__declspec(dllimport) extern double __cdecl modf(double x, double * iptr); 
#line 4871
extern double __cdecl fmod(double x, double y); 
#line 4959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl remainder(double x, double y); 
#line 5049 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl remainderf(float x, float y); 
#line 5103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl remquo(double x, double y, int * quo); 
#line 5157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl remquof(float x, float y, int * quo); 
#line 5196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl j0(double x); 
#line 5238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float j0f(float x); 
#line 5299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl j1(double x); 
#line 5360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float j1f(float x); 
#line 5403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl jn(int n, double x); 
#line 5446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float jnf(int n, float x); 
#line 5498 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl y0(double x); 
#line 5550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float y0f(float x); 
#line 5602 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl y1(double x); 
#line 5654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float y1f(float x); 
#line 5707 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl yn(int n, double x); 
#line 5760 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern float ynf(int n, float x); 
#line 5787
__declspec(dllimport) extern double __cdecl cyl_bessel_i0(double x); 
#line 5813
extern float cyl_bessel_i0f(float x); 
#line 5840
__declspec(dllimport) extern double __cdecl cyl_bessel_i1(double x); 
#line 5866
extern float cyl_bessel_i1f(float x); 
#line 5951 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl erf(double x); 
#line 6033 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl erff(float x); 
#line 6095 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double erfinv(double y); 
#line 6152
extern float erfinvf(float y); 
#line 6193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl erfc(double x); 
#line 6231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl erfcf(float x); 
#line 6359 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl lgamma(double x); 
#line 6420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern double erfcinv(double y); 
#line 6476
extern float erfcinvf(float y); 
#line 6534
extern double normcdfinv(double y); 
#line 6592
extern float normcdfinvf(float y); 
#line 6635
extern double normcdf(double y); 
#line 6678
extern float normcdff(float y); 
#line 6753
extern double erfcx(double x); 
#line 6828
extern float erfcxf(float x); 
#line 6964 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl lgammaf(float x); 
#line 7073 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl tgamma(double x); 
#line 7182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl tgammaf(float x); 
#line 7195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl copysign(double x, double y); 
#line 7208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl copysignf(float x, float y); 
#line 7245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl nextafter(double x, double y); 
#line 7282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl nextafterf(float x, float y); 
#line 7298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl nan(const char * tagp); 
#line 7314 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl nanf(const char * tagp); 
#line 7319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern int __isinff(float); 
#line 7320
extern int __isnanf(float); 
#line 7330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern int __finite(double); 
#line 7331
extern int __finitef(float); 
#line 7332
extern int __signbit(double); 
#line 7333
extern int __isnan(double); 
#line 7334
extern int __isinf(double); 
#line 7337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern int __signbitf(float); 
#line 7498 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fma(double x, double y, double z); 
#line 7656 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fmaf(float x, float y, float z); 
#line 7665 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern int __signbitl(long double); 
#line 7671 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern int __finitel(long double); 
#line 7672
extern int __isinfl(long double); 
#line 7673
extern int __isnanl(long double); 
#line 7677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl acosf(float); 
#line 7678
__declspec(dllimport) extern float __cdecl asinf(float); 
#line 7679
__declspec(dllimport) extern float __cdecl atanf(float); 
#line 7680
__declspec(dllimport) extern float __cdecl atan2f(float, float); 
#line 7681
__declspec(dllimport) extern float __cdecl cosf(float); 
#line 7682
__declspec(dllimport) extern float __cdecl sinf(float); 
#line 7683
__declspec(dllimport) extern float __cdecl tanf(float); 
#line 7684
__declspec(dllimport) extern float __cdecl coshf(float); 
#line 7685
__declspec(dllimport) extern float __cdecl sinhf(float); 
#line 7686
__declspec(dllimport) extern float __cdecl tanhf(float); 
#line 7687
__declspec(dllimport) extern float __cdecl expf(float); 
#line 7688
__declspec(dllimport) extern float __cdecl logf(float); 
#line 7689
__declspec(dllimport) extern float __cdecl log10f(float); 
#line 7690
__declspec(dllimport) extern float __cdecl modff(float, float *); 
#line 7691
__declspec(dllimport) extern float __cdecl powf(float, float); 
#line 7692
__declspec(dllimport) extern float __cdecl sqrtf(float); 
#line 7693
__declspec(dllimport) extern float __cdecl ceilf(float); 
#line 7694
__declspec(dllimport) extern float __cdecl floorf(float); 
#line 7695
__declspec(dllimport) extern float __cdecl fmodf(float, float); 
#line 8828 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
}
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 15
#pragma warning(push)
#pragma warning(disable:4738)
#pragma warning(disable:4820)
#line 24
struct _exception { 
#line 26
int type; 
#line 27
char *name; 
#line 28
double arg1; 
#line 29
double arg2; 
#line 30
double retval; 
#line 31
}; 
#line 38
struct _complex { 
#line 40
double x, y; 
#line 41
}; 
#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
typedef float float_t; 
#line 61
typedef double double_t; 
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
extern const double _HUGE; 
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
void __cdecl _fperrraise(int _Except); 
#line 172
__declspec(dllimport) short __cdecl _dclass(double _X); 
#line 173
__declspec(dllimport) short __cdecl _ldclass(long double _X); 
#line 174
__declspec(dllimport) short __cdecl _fdclass(float _X); 
#line 176
__declspec(dllimport) int __cdecl _dsign(double _X); 
#line 177
__declspec(dllimport) int __cdecl _ldsign(long double _X); 
#line 178
__declspec(dllimport) int __cdecl _fdsign(float _X); 
#line 180
__declspec(dllimport) int __cdecl _dpcomp(double _X, double _Y); 
#line 181
__declspec(dllimport) int __cdecl _ldpcomp(long double _X, long double _Y); 
#line 182
__declspec(dllimport) int __cdecl _fdpcomp(float _X, float _Y); 
#line 184
__declspec(dllimport) short __cdecl _dtest(double * _Px); 
#line 185
__declspec(dllimport) short __cdecl _ldtest(long double * _Px); 
#line 186
__declspec(dllimport) short __cdecl _fdtest(float * _Px); 
#line 188
__declspec(dllimport) short __cdecl _d_int(double * _Px, short _Xexp); 
#line 189
__declspec(dllimport) short __cdecl _ld_int(long double * _Px, short _Xexp); 
#line 190
__declspec(dllimport) short __cdecl _fd_int(float * _Px, short _Xexp); 
#line 192
__declspec(dllimport) short __cdecl _dscale(double * _Px, long _Lexp); 
#line 193
__declspec(dllimport) short __cdecl _ldscale(long double * _Px, long _Lexp); 
#line 194
__declspec(dllimport) short __cdecl _fdscale(float * _Px, long _Lexp); 
#line 196
__declspec(dllimport) short __cdecl _dunscale(short * _Pex, double * _Px); 
#line 197
__declspec(dllimport) short __cdecl _ldunscale(short * _Pex, long double * _Px); 
#line 198
__declspec(dllimport) short __cdecl _fdunscale(short * _Pex, float * _Px); 
#line 200
__declspec(dllimport) short __cdecl _dexp(double * _Px, double _Y, long _Eoff); 
#line 201
__declspec(dllimport) short __cdecl _ldexp(long double * _Px, long double _Y, long _Eoff); 
#line 202
__declspec(dllimport) short __cdecl _fdexp(float * _Px, float _Y, long _Eoff); 
#line 204
__declspec(dllimport) short __cdecl _dnorm(unsigned short * _Ps); 
#line 205
__declspec(dllimport) short __cdecl _fdnorm(unsigned short * _Ps); 
#line 207
__declspec(dllimport) double __cdecl _dpoly(double _X, const double * _Tab, int _N); 
#line 208
__declspec(dllimport) long double __cdecl _ldpoly(long double _X, const long double * _Tab, int _N); 
#line 209
__declspec(dllimport) float __cdecl _fdpoly(float _X, const float * _Tab, int _N); 
#line 211
__declspec(dllimport) double __cdecl _dlog(double _X, int _Baseflag); 
#line 212
__declspec(dllimport) long double __cdecl _ldlog(long double _X, int _Baseflag); 
#line 213
__declspec(dllimport) float __cdecl _fdlog(float _X, int _Baseflag); 
#line 215
__declspec(dllimport) double __cdecl _dsin(double _X, unsigned _Qoff); 
#line 216
__declspec(dllimport) long double __cdecl _ldsin(long double _X, unsigned _Qoff); 
#line 217
__declspec(dllimport) float __cdecl _fdsin(float _X, unsigned _Qoff); 
#line 224
typedef 
#line 221
union { 
#line 222
unsigned short _Sh[4]; 
#line 223
double _Val; 
#line 224
} _double_val; 
#line 231
typedef 
#line 228
union { 
#line 229
unsigned short _Sh[2]; 
#line 230
float _Val; 
#line 231
} _float_val; 
#line 238
typedef 
#line 235
union { 
#line 236
unsigned short _Sh[4]; 
#line 237
long double _Val; 
#line 238
} _ldouble_val; 
#line 246
typedef 
#line 241
union { 
#line 242
unsigned short _Word[4]; 
#line 243
float _Float; 
#line 244
double _Double; 
#line 245
long double _Long_double; 
#line 246
} _float_const; 
#line 248
extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C; 
#line 249
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C; 
#line 250
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C; 
#line 252
extern const _float_const _Eps_C, _Rteps_C; 
#line 253
extern const _float_const _FEps_C, _FRteps_C; 
#line 254
extern const _float_const _LEps_C, _LRteps_C; 
#line 256
extern const double _Zero_C, _Xbig_C; 
#line 257
extern const float _FZero_C, _FXbig_C; 
#line 258
extern const long double _LZero_C, _LXbig_C; 
#line 287
extern "C++" {
#line 289
inline int fpclassify(float _X) throw() 
#line 290
{ 
#line 291
return _fdtest(&_X); 
#line 292
} 
#line 294
inline int fpclassify(double _X) throw() 
#line 295
{ 
#line 296
return _dtest(&_X); 
#line 297
} 
#line 299
inline int fpclassify(long double _X) throw() 
#line 300
{ 
#line 301
return _ldtest(&_X); 
#line 302
} 
#line 304
inline bool signbit(float _X) throw() 
#line 305
{ 
#line 306
return _fdsign(_X) != 0; 
#line 307
} 
#line 309
inline bool signbit(double _X) throw() 
#line 310
{ 
#line 311
return _dsign(_X) != 0; 
#line 312
} 
#line 314
inline bool signbit(long double _X) throw() 
#line 315
{ 
#line 316
return _ldsign(_X) != 0; 
#line 317
} 
#line 319
inline int _fpcomp(float _X, float _Y) throw() 
#line 320
{ 
#line 321
return _fdpcomp(_X, _Y); 
#line 322
} 
#line 324
inline int _fpcomp(double _X, double _Y) throw() 
#line 325
{ 
#line 326
return _dpcomp(_X, _Y); 
#line 327
} 
#line 329
inline int _fpcomp(long double _X, long double _Y) throw() 
#line 330
{ 
#line 331
return _ldpcomp(_X, _Y); 
#line 332
} 
#line 334
template< class _Trc, class _Tre> struct _Combined_type { 
#line 336
typedef float _Type; 
#line 337
}; 
#line 339
template<> struct _Combined_type< float, double>  { 
#line 341
typedef double _Type; 
#line 342
}; 
#line 344
template<> struct _Combined_type< float, long double>  { 
#line 346
typedef long double _Type; 
#line 347
}; 
#line 349
template< class _Ty, class _T2> struct _Real_widened { 
#line 351
typedef long double _Type; 
#line 352
}; 
#line 354
template<> struct _Real_widened< float, float>  { 
#line 356
typedef float _Type; 
#line 357
}; 
#line 359
template<> struct _Real_widened< float, double>  { 
#line 361
typedef double _Type; 
#line 362
}; 
#line 364
template<> struct _Real_widened< double, float>  { 
#line 366
typedef double _Type; 
#line 367
}; 
#line 369
template<> struct _Real_widened< double, double>  { 
#line 371
typedef double _Type; 
#line 372
}; 
#line 374
template< class _Ty> struct _Real_type { 
#line 376
typedef double _Type; 
#line 377
}; 
#line 379
template<> struct _Real_type< float>  { 
#line 381
typedef float _Type; 
#line 382
}; 
#line 384
template<> struct _Real_type< long double>  { 
#line 386
typedef long double _Type; 
#line 387
}; 
#line 389
template < class _T1, class _T2 >
      inline int _fpcomp ( _T1 _X, _T2 _Y ) throw ( )
    {
        typedef typename _Combined_type < float,
            typename _Real_widened <
            typename _Real_type < _T1 > :: _Type,
            typename _Real_type < _T2 > :: _Type > :: _Type > :: _Type _Tw;
        return _fpcomp ( ( _Tw ) _X, ( _Tw ) _Y );
    }
#line 399
template < class _Ty >
      inline bool isfinite ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) <= 0;
    }
#line 405
template < class _Ty >
      inline bool isinf ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 1;
    }
#line 411
template < class _Ty >
      inline bool isnan ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 2;
    }
#line 417
template < class _Ty >
      inline bool isnormal ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == ( - 1 );
    }
#line 423
template < class _Ty1, class _Ty2 >
      inline bool isgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 4 ) != 0;
    }
#line 429
template < class _Ty1, class _Ty2 >
      inline bool isgreaterequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 2 | 4 ) ) != 0;
    }
#line 435
template < class _Ty1, class _Ty2 >
      inline bool isless ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 1 ) != 0;
    }
#line 441
template < class _Ty1, class _Ty2 >
      inline bool islessequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 2 ) ) != 0;
    }
#line 447
template < class _Ty1, class _Ty2 >
      inline bool islessgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 4 ) ) != 0;
    }
#line 453
template < class _Ty1, class _Ty2 >
      inline bool isunordered ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return _fpcomp ( _X, _Y ) == 0;
    }
#line 458
}
#line 465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
int __cdecl abs(int _X); 
#line 466
long __cdecl labs(long _X); 
#line 467
__int64 __cdecl llabs(__int64 _X); 
#line 469
double __cdecl acos(double _X); 
#line 470
double __cdecl asin(double _X); 
#line 471
double __cdecl atan(double _X); 
#line 472
double __cdecl atan2(double _Y, double _X); 
#line 474
double __cdecl cos(double _X); 
#line 475
double __cdecl cosh(double _X); 
#line 476
double __cdecl exp(double _X); 
#line 477
double __cdecl fabs(double _X); 
#line 478
double __cdecl fmod(double _X, double _Y); 
#line 479
double __cdecl log(double _X); 
#line 480
double __cdecl log10(double _X); 
#line 481
double __cdecl pow(double _X, double _Y); 
#line 482
double __cdecl sin(double _X); 
#line 483
double __cdecl sinh(double _X); 
#line 484
double __cdecl sqrt(double _X); 
#line 485
double __cdecl tan(double _X); 
#line 486
double __cdecl tanh(double _X); 
#line 488
__declspec(dllimport) double __cdecl acosh(double _X); 
#line 489
__declspec(dllimport) double __cdecl asinh(double _X); 
#line 490
__declspec(dllimport) double __cdecl atanh(double _X); 
#line 491
__declspec(dllimport) double __cdecl atof(const char * _String); 
#line 492
__declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 493
__declspec(dllimport) double __cdecl _cabs(_complex _Complex_value); 
#line 494
__declspec(dllimport) double __cdecl cbrt(double _X); 
#line 495
__declspec(dllimport) double __cdecl ceil(double _X); 
#line 496
__declspec(dllimport) double __cdecl _chgsign(double _X); 
#line 497
__declspec(dllimport) double __cdecl copysign(double _Number, double _Sign); 
#line 498
__declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); 
#line 499
__declspec(dllimport) double __cdecl erf(double _X); 
#line 500
__declspec(dllimport) double __cdecl erfc(double _X); 
#line 501
__declspec(dllimport) double __cdecl exp2(double _X); 
#line 502
__declspec(dllimport) double __cdecl expm1(double _X); 
#line 503
__declspec(dllimport) double __cdecl fdim(double _X, double _Y); 
#line 504
__declspec(dllimport) double __cdecl floor(double _X); 
#line 505
__declspec(dllimport) double __cdecl fma(double _X, double _Y, double _Z); 
#line 506
__declspec(dllimport) double __cdecl fmax(double _X, double _Y); 
#line 507
__declspec(dllimport) double __cdecl fmin(double _X, double _Y); 
#line 508
__declspec(dllimport) double __cdecl frexp(double _X, int * _Y); 
#line 509
__declspec(dllimport) double __cdecl hypot(double _X, double _Y); 
#line 510
__declspec(dllimport) double __cdecl _hypot(double _X, double _Y); 
#line 511
__declspec(dllimport) int __cdecl ilogb(double _X); 
#line 512
__declspec(dllimport) double __cdecl ldexp(double _X, int _Y); 
#line 513
__declspec(dllimport) double __cdecl lgamma(double _X); 
#line 514
__declspec(dllimport) __int64 __cdecl llrint(double _X); 
#line 515
__declspec(dllimport) __int64 __cdecl llround(double _X); 
#line 516
__declspec(dllimport) double __cdecl log1p(double _X); 
#line 517
__declspec(dllimport) double __cdecl log2(double _X); 
#line 518
__declspec(dllimport) double __cdecl logb(double _X); 
#line 519
__declspec(dllimport) long __cdecl lrint(double _X); 
#line 520
__declspec(dllimport) long __cdecl lround(double _X); 
#line 522
int __cdecl _matherr(_exception * _Except); 
#line 524
__declspec(dllimport) double __cdecl modf(double _X, double * _Y); 
#line 525
__declspec(dllimport) double __cdecl nan(const char * _X); 
#line 526
__declspec(dllimport) double __cdecl nearbyint(double _X); 
#line 527
__declspec(dllimport) double __cdecl nextafter(double _X, double _Y); 
#line 528
__declspec(dllimport) double __cdecl nexttoward(double _X, long double _Y); 
#line 529
__declspec(dllimport) double __cdecl remainder(double _X, double _Y); 
#line 530
__declspec(dllimport) double __cdecl remquo(double _X, double _Y, int * _Z); 
#line 531
__declspec(dllimport) double __cdecl rint(double _X); 
#line 532
__declspec(dllimport) double __cdecl round(double _X); 
#line 533
__declspec(dllimport) double __cdecl scalbln(double _X, long _Y); 
#line 534
__declspec(dllimport) double __cdecl scalbn(double _X, int _Y); 
#line 535
__declspec(dllimport) double __cdecl tgamma(double _X); 
#line 536
__declspec(dllimport) double __cdecl trunc(double _X); 
#line 537
__declspec(dllimport) double __cdecl _j0(double _X); 
#line 538
__declspec(dllimport) double __cdecl _j1(double _X); 
#line 539
__declspec(dllimport) double __cdecl _jn(int _X, double _Y); 
#line 540
__declspec(dllimport) double __cdecl _y0(double _X); 
#line 541
__declspec(dllimport) double __cdecl _y1(double _X); 
#line 542
__declspec(dllimport) double __cdecl _yn(int _X, double _Y); 
#line 544
__declspec(dllimport) float __cdecl acoshf(float _X); 
#line 545
__declspec(dllimport) float __cdecl asinhf(float _X); 
#line 546
__declspec(dllimport) float __cdecl atanhf(float _X); 
#line 547
__declspec(dllimport) float __cdecl cbrtf(float _X); 
#line 548
__declspec(dllimport) float __cdecl _chgsignf(float _X); 
#line 549
__declspec(dllimport) float __cdecl copysignf(float _Number, float _Sign); 
#line 550
__declspec(dllimport) float __cdecl _copysignf(float _Number, float _Sign); 
#line 551
__declspec(dllimport) float __cdecl erff(float _X); 
#line 552
__declspec(dllimport) float __cdecl erfcf(float _X); 
#line 553
__declspec(dllimport) float __cdecl expm1f(float _X); 
#line 554
__declspec(dllimport) float __cdecl exp2f(float _X); 
#line 555
__declspec(dllimport) float __cdecl fdimf(float _X, float _Y); 
#line 556
__declspec(dllimport) float __cdecl fmaf(float _X, float _Y, float _Z); 
#line 557
__declspec(dllimport) float __cdecl fmaxf(float _X, float _Y); 
#line 558
__declspec(dllimport) float __cdecl fminf(float _X, float _Y); 
#line 559
__declspec(dllimport) float __cdecl _hypotf(float _X, float _Y); 
#line 560
__declspec(dllimport) int __cdecl ilogbf(float _X); 
#line 561
__declspec(dllimport) float __cdecl lgammaf(float _X); 
#line 562
__declspec(dllimport) __int64 __cdecl llrintf(float _X); 
#line 563
__declspec(dllimport) __int64 __cdecl llroundf(float _X); 
#line 564
__declspec(dllimport) float __cdecl log1pf(float _X); 
#line 565
__declspec(dllimport) float __cdecl log2f(float _X); 
#line 566
__declspec(dllimport) float __cdecl logbf(float _X); 
#line 567
__declspec(dllimport) long __cdecl lrintf(float _X); 
#line 568
__declspec(dllimport) long __cdecl lroundf(float _X); 
#line 569
__declspec(dllimport) float __cdecl nanf(const char * _X); 
#line 570
__declspec(dllimport) float __cdecl nearbyintf(float _X); 
#line 571
__declspec(dllimport) float __cdecl nextafterf(float _X, float _Y); 
#line 572
__declspec(dllimport) float __cdecl nexttowardf(float _X, long double _Y); 
#line 573
__declspec(dllimport) float __cdecl remainderf(float _X, float _Y); 
#line 574
__declspec(dllimport) float __cdecl remquof(float _X, float _Y, int * _Z); 
#line 575
__declspec(dllimport) float __cdecl rintf(float _X); 
#line 576
__declspec(dllimport) float __cdecl roundf(float _X); 
#line 577
__declspec(dllimport) float __cdecl scalblnf(float _X, long _Y); 
#line 578
__declspec(dllimport) float __cdecl scalbnf(float _X, int _Y); 
#line 579
__declspec(dllimport) float __cdecl tgammaf(float _X); 
#line 580
__declspec(dllimport) float __cdecl truncf(float _X); 
#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) float __cdecl _logbf(float _X); 
#line 591
__declspec(dllimport) float __cdecl _nextafterf(float _X, float _Y); 
#line 592
__declspec(dllimport) int __cdecl _finitef(float _X); 
#line 593
__declspec(dllimport) int __cdecl _isnanf(float _X); 
#line 594
__declspec(dllimport) int __cdecl _fpclassf(float _X); 
#line 596
__declspec(dllimport) int __cdecl _set_FMA3_enable(int _Flag); 
#line 597
__declspec(dllimport) int __cdecl _get_FMA3_enable(); 
#line 610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) float __cdecl acosf(float _X); 
#line 611
__declspec(dllimport) float __cdecl asinf(float _X); 
#line 612
__declspec(dllimport) float __cdecl atan2f(float _Y, float _X); 
#line 613
__declspec(dllimport) float __cdecl atanf(float _X); 
#line 614
__declspec(dllimport) float __cdecl ceilf(float _X); 
#line 615
__declspec(dllimport) float __cdecl cosf(float _X); 
#line 616
__declspec(dllimport) float __cdecl coshf(float _X); 
#line 617
__declspec(dllimport) float __cdecl expf(float _X); 
#line 669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__inline float __cdecl fabsf(float _X) 
#line 670
{ 
#line 671
return (float)fabs(_X); 
#line 672
} 
#line 678 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) float __cdecl floorf(float _X); 
#line 679
__declspec(dllimport) float __cdecl fmodf(float _X, float _Y); 
#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__inline float __cdecl frexpf(float _X, int *_Y) 
#line 696
{ 
#line 697
return (float)frexp(_X, _Y); 
#line 698
} 
#line 700
__inline float __cdecl hypotf(float _X, float _Y) 
#line 701
{ 
#line 702
return _hypotf(_X, _Y); 
#line 703
} 
#line 705
__inline float __cdecl ldexpf(float _X, int _Y) 
#line 706
{ 
#line 707
return (float)ldexp(_X, _Y); 
#line 708
} 
#line 712
__declspec(dllimport) float __cdecl log10f(float _X); 
#line 713
__declspec(dllimport) float __cdecl logf(float _X); 
#line 714
__declspec(dllimport) float __cdecl modff(float _X, float * _Y); 
#line 715
__declspec(dllimport) float __cdecl powf(float _X, float _Y); 
#line 716
__declspec(dllimport) float __cdecl sinf(float _X); 
#line 717
__declspec(dllimport) float __cdecl sinhf(float _X); 
#line 718
__declspec(dllimport) float __cdecl sqrtf(float _X); 
#line 719
__declspec(dllimport) float __cdecl tanf(float _X); 
#line 720
__declspec(dllimport) float __cdecl tanhf(float _X); 
#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) long double __cdecl acoshl(long double _X); 
#line 776
__inline long double __cdecl acosl(long double _X) 
#line 777
{ 
#line 778
return acos((double)_X); 
#line 779
} 
#line 781
__declspec(dllimport) long double __cdecl asinhl(long double _X); 
#line 783
__inline long double __cdecl asinl(long double _X) 
#line 784
{ 
#line 785
return asin((double)_X); 
#line 786
} 
#line 788
__inline long double __cdecl atan2l(long double _Y, long double _X) 
#line 789
{ 
#line 790
return atan2((double)_Y, (double)_X); 
#line 791
} 
#line 793
__declspec(dllimport) long double __cdecl atanhl(long double _X); 
#line 795
__inline long double __cdecl atanl(long double _X) 
#line 796
{ 
#line 797
return atan((double)_X); 
#line 798
} 
#line 800
__declspec(dllimport) long double __cdecl cbrtl(long double _X); 
#line 802
__inline long double __cdecl ceill(long double _X) 
#line 803
{ 
#line 804
return ceil((double)_X); 
#line 805
} 
#line 807
__inline long double __cdecl _chgsignl(long double _X) 
#line 808
{ 
#line 809
return _chgsign((double)_X); 
#line 810
} 
#line 812
__declspec(dllimport) long double __cdecl copysignl(long double _Number, long double _Sign); 
#line 814
__inline long double __cdecl _copysignl(long double _Number, long double _Sign) 
#line 815
{ 
#line 816
return _copysign((double)_Number, (double)_Sign); 
#line 817
} 
#line 819
__inline long double __cdecl coshl(long double _X) 
#line 820
{ 
#line 821
return cosh((double)_X); 
#line 822
} 
#line 824
__inline long double __cdecl cosl(long double _X) 
#line 825
{ 
#line 826
return cos((double)_X); 
#line 827
} 
#line 829
__declspec(dllimport) long double __cdecl erfl(long double _X); 
#line 830
__declspec(dllimport) long double __cdecl erfcl(long double _X); 
#line 832
__inline long double __cdecl expl(long double _X) 
#line 833
{ 
#line 834
return exp((double)_X); 
#line 835
} 
#line 837
__declspec(dllimport) long double __cdecl exp2l(long double _X); 
#line 838
__declspec(dllimport) long double __cdecl expm1l(long double _X); 
#line 840
__inline long double __cdecl fabsl(long double _X) 
#line 841
{ 
#line 842
return fabs((double)_X); 
#line 843
} 
#line 845
__declspec(dllimport) long double __cdecl fdiml(long double _X, long double _Y); 
#line 847
__inline long double __cdecl floorl(long double _X) 
#line 848
{ 
#line 849
return floor((double)_X); 
#line 850
} 
#line 852
__declspec(dllimport) long double __cdecl fmal(long double _X, long double _Y, long double _Z); 
#line 853
__declspec(dllimport) long double __cdecl fmaxl(long double _X, long double _Y); 
#line 854
__declspec(dllimport) long double __cdecl fminl(long double _X, long double _Y); 
#line 856
__inline long double __cdecl fmodl(long double _X, long double _Y) 
#line 857
{ 
#line 858
return fmod((double)_X, (double)_Y); 
#line 859
} 
#line 861
__inline long double __cdecl frexpl(long double _X, int *_Y) 
#line 862
{ 
#line 863
return frexp((double)_X, _Y); 
#line 864
} 
#line 866
__declspec(dllimport) int __cdecl ilogbl(long double _X); 
#line 868
__inline long double __cdecl _hypotl(long double _X, long double _Y) 
#line 869
{ 
#line 870
return _hypot((double)_X, (double)_Y); 
#line 871
} 
#line 873
__inline long double __cdecl hypotl(long double _X, long double _Y) 
#line 874
{ 
#line 875
return _hypot((double)_X, (double)_Y); 
#line 876
} 
#line 878
__inline long double __cdecl ldexpl(long double _X, int _Y) 
#line 879
{ 
#line 880
return ldexp((double)_X, _Y); 
#line 881
} 
#line 883
__declspec(dllimport) long double __cdecl lgammal(long double _X); 
#line 884
__declspec(dllimport) __int64 __cdecl llrintl(long double _X); 
#line 885
__declspec(dllimport) __int64 __cdecl llroundl(long double _X); 
#line 887
__inline long double __cdecl logl(long double _X) 
#line 888
{ 
#line 889
return log((double)_X); 
#line 890
} 
#line 892
__inline long double __cdecl log10l(long double _X) 
#line 893
{ 
#line 894
return log10((double)_X); 
#line 895
} 
#line 897
__declspec(dllimport) long double __cdecl log1pl(long double _X); 
#line 898
__declspec(dllimport) long double __cdecl log2l(long double _X); 
#line 899
__declspec(dllimport) long double __cdecl logbl(long double _X); 
#line 900
__declspec(dllimport) long __cdecl lrintl(long double _X); 
#line 901
__declspec(dllimport) long __cdecl lroundl(long double _X); 
#line 903
__inline long double __cdecl modfl(long double _X, long double *_Y) 
#line 904
{ 
#line 905
double _F, _I; 
#line 906
_F = modf((double)_X, &_I); 
#line 907
(*_Y) = _I; 
#line 908
return _F; 
#line 909
} 
#line 911
__declspec(dllimport) long double __cdecl nanl(const char * _X); 
#line 912
__declspec(dllimport) long double __cdecl nearbyintl(long double _X); 
#line 913
__declspec(dllimport) long double __cdecl nextafterl(long double _X, long double _Y); 
#line 914
__declspec(dllimport) long double __cdecl nexttowardl(long double _X, long double _Y); 
#line 916
__inline long double __cdecl powl(long double _X, long double _Y) 
#line 917
{ 
#line 918
return pow((double)_X, (double)_Y); 
#line 919
} 
#line 921
__declspec(dllimport) long double __cdecl remainderl(long double _X, long double _Y); 
#line 922
__declspec(dllimport) long double __cdecl remquol(long double _X, long double _Y, int * _Z); 
#line 923
__declspec(dllimport) long double __cdecl rintl(long double _X); 
#line 924
__declspec(dllimport) long double __cdecl roundl(long double _X); 
#line 925
__declspec(dllimport) long double __cdecl scalblnl(long double _X, long _Y); 
#line 926
__declspec(dllimport) long double __cdecl scalbnl(long double _X, int _Y); 
#line 928
__inline long double __cdecl sinhl(long double _X) 
#line 929
{ 
#line 930
return sinh((double)_X); 
#line 931
} 
#line 933
__inline long double __cdecl sinl(long double _X) 
#line 934
{ 
#line 935
return sin((double)_X); 
#line 936
} 
#line 938
__inline long double __cdecl sqrtl(long double _X) 
#line 939
{ 
#line 940
return sqrt((double)_X); 
#line 941
} 
#line 943
__inline long double __cdecl tanhl(long double _X) 
#line 944
{ 
#line 945
return tanh((double)_X); 
#line 946
} 
#line 948
__inline long double __cdecl tanl(long double _X) 
#line 949
{ 
#line 950
return tan((double)_X); 
#line 951
} 
#line 953
__declspec(dllimport) long double __cdecl tgammal(long double _X); 
#line 954
__declspec(dllimport) long double __cdecl truncl(long double _X); 
#line 975 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
extern double HUGE; 
#line 980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) double __cdecl j0(double _X); 
#line 981
__declspec(dllimport) double __cdecl j1(double _X); 
#line 982
__declspec(dllimport) double __cdecl jn(int _X, double _Y); 
#line 983
__declspec(dllimport) double __cdecl y0(double _X); 
#line 984
__declspec(dllimport) double __cdecl y1(double _X); 
#line 985
__declspec(dllimport) double __cdecl yn(int _X, double _Y); 
#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_math.h"
}
#line 991
#pragma warning(pop)
#line 993
__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h"
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 55
_calloc_base(size_t _Count, size_t _Size); 
#line 61
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 62
calloc(size_t _Count, size_t _Size); 
#line 68
__declspec(dllimport) int __cdecl _callnewh(size_t _Size); 
#line 73
__declspec(dllimport) __declspec(allocator) void *__cdecl 
#line 74
_expand(void * _Block, size_t _Size); 
#line 79
__declspec(dllimport) void __cdecl 
#line 80
_free_base(void * _Block); 
#line 84
__declspec(dllimport) void __cdecl 
#line 85
free(void * _Block); 
#line 90
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 91
_malloc_base(size_t _Size); 
#line 96
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 97
malloc(size_t _Size); 
#line 102
__declspec(dllimport) size_t __cdecl 
#line 103
_msize_base(void * _Block); 
#line 108
__declspec(dllimport) size_t __cdecl 
#line 109
_msize(void * _Block); 
#line 114
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 115
_realloc_base(void * _Block, size_t _Size); 
#line 121
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 122
realloc(void * _Block, size_t _Size); 
#line 128
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 129
_recalloc_base(void * _Block, size_t _Count, size_t _Size); 
#line 136
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 137
_recalloc(void * _Block, size_t _Count, size_t _Size); 
#line 143
__declspec(dllimport) void __cdecl 
#line 144
_aligned_free(void * _Block); 
#line 149
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 150
_aligned_malloc(size_t _Size, size_t _Alignment); 
#line 156
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 157
_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset); 
#line 164
__declspec(dllimport) size_t __cdecl 
#line 165
_aligned_msize(void * _Block, size_t _Alignment, size_t _Offset); 
#line 172
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 173
_aligned_offset_realloc(void * _Block, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 181
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 182
_aligned_offset_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 191
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 192
_aligned_realloc(void * _Block, size_t _Size, size_t _Alignment); 
#line 199
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 200
_aligned_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment); 
#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_malloc.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
typedef int (__cdecl *_CoreCrtSecureSearchSortCompareFunction)(void *, const void *, const void *); 
#line 20
typedef int (__cdecl *_CoreCrtNonSecureSearchSortCompareFunction)(const void *, const void *); 
#line 26
__declspec(dllimport) void *__cdecl bsearch_s(const void * _Key, const void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 35
__declspec(dllimport) void __cdecl qsort_s(void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h"
__declspec(dllimport) void *__cdecl bsearch(const void * _Key, const void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 56
__declspec(dllimport) void __cdecl qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 64
__declspec(dllimport) void *__cdecl _lfind_s(const void * _Key, const void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 74
__declspec(dllimport) void *__cdecl _lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 83
__declspec(dllimport) void *__cdecl _lsearch_s(const void * _Key, void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 93
__declspec(dllimport) void *__cdecl _lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h"
__declspec(dllimport) void *__cdecl lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 200
__declspec(dllimport) void *__cdecl lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_search.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 50
__declspec(dllimport) errno_t __cdecl _itow_s(int _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 57
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) __wchar_t *__cdecl _itow(int _Value, __wchar_t * _Buffer, int _Radix); 
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) errno_t __cdecl _ltow_s(long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 80
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) __wchar_t *__cdecl _ltow(long _Value, __wchar_t * _Buffer, int _Radix); 
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 102
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) __wchar_t *__cdecl _ultow(unsigned long _Value, __wchar_t * _Buffer, int _Radix); 
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) double __cdecl wcstod(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 123
__declspec(dllimport) double __cdecl _wcstod_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 130
__declspec(dllimport) long __cdecl wcstol(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 137
__declspec(dllimport) long __cdecl _wcstol_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 145
__declspec(dllimport) __int64 __cdecl wcstoll(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 152
__declspec(dllimport) __int64 __cdecl _wcstoll_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 160
__declspec(dllimport) unsigned long __cdecl wcstoul(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 167
__declspec(dllimport) unsigned long __cdecl _wcstoul_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 175
__declspec(dllimport) unsigned __int64 __cdecl wcstoull(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 182
__declspec(dllimport) unsigned __int64 __cdecl _wcstoull_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 190
__declspec(dllimport) long double __cdecl wcstold(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 196
__declspec(dllimport) long double __cdecl _wcstold_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 203
__declspec(dllimport) float __cdecl wcstof(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 209
__declspec(dllimport) float __cdecl _wcstof_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 216
__declspec(dllimport) double __cdecl _wtof(const __wchar_t * _String); 
#line 221
__declspec(dllimport) double __cdecl _wtof_l(const __wchar_t * _String, _locale_t _Locale); 
#line 227
__declspec(dllimport) int __cdecl _wtoi(const __wchar_t * _String); 
#line 232
__declspec(dllimport) int __cdecl _wtoi_l(const __wchar_t * _String, _locale_t _Locale); 
#line 238
__declspec(dllimport) long __cdecl _wtol(const __wchar_t * _String); 
#line 243
__declspec(dllimport) long __cdecl _wtol_l(const __wchar_t * _String, _locale_t _Locale); 
#line 249
__declspec(dllimport) __int64 __cdecl _wtoll(const __wchar_t * _String); 
#line 254
__declspec(dllimport) __int64 __cdecl _wtoll_l(const __wchar_t * _String, _locale_t _Locale); 
#line 260
__declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 268
__declspec(dllimport) __wchar_t *__cdecl _i64tow(__int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 275
__declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 283
__declspec(dllimport) __wchar_t *__cdecl _ui64tow(unsigned __int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 290
__declspec(dllimport) __int64 __cdecl _wtoi64(const __wchar_t * _String); 
#line 295
__declspec(dllimport) __int64 __cdecl _wtoi64_l(const __wchar_t * _String, _locale_t _Locale); 
#line 301
__declspec(dllimport) __int64 __cdecl _wcstoi64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 308
__declspec(dllimport) __int64 __cdecl _wcstoi64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 316
__declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 323
__declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 335
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wfullpath(__wchar_t * _Buffer, const __wchar_t * _Path, size_t _BufferCount); 
#line 344
__declspec(dllimport) errno_t __cdecl _wmakepath_s(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 353
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Drive, wchar_t const * _Dir, wchar_t const * _Filename, wchar_t const * _Ext ) throw ( ) { return _wmakepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) void __cdecl _wmakepath(__wchar_t * _Buffer, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)
#line 375
__declspec(dllimport) void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 380
__declspec(dllimport) void __cdecl _wsplitpath(const __wchar_t * _FullPath, __wchar_t * _Drive, __wchar_t * _Dir, __wchar_t * _Filename, __wchar_t * _Ext); 
#line 388
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(const __wchar_t * _FullPath, __wchar_t * _Drive, size_t _DriveCount, __wchar_t * _Dir, size_t _DirCount, __wchar_t * _Filename, size_t _FilenameCount, __wchar_t * _Ext, size_t _ExtCount); 
#line 400
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( wchar_t const * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) errno_t __cdecl _wdupenv_s(__wchar_t ** _Buffer, size_t * _BufferCount, const __wchar_t * _VarName); 
#line 422
__declspec(dllimport) __wchar_t *__cdecl _wgetenv(const __wchar_t * _VarName); 
#line 428
__declspec(dllimport) errno_t __cdecl _wgetenv_s(size_t * _RequiredCount, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _VarName); 
#line 435
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _RequiredCount, wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _VarName ) throw ( ) { return _wgetenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) int __cdecl _wputenv(const __wchar_t * _EnvString); 
#line 449
__declspec(dllimport) errno_t __cdecl _wputenv_s(const __wchar_t * _Name, const __wchar_t * _Value); 
#line 454
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _Buffer, size_t _BufferCount); 
#line 461
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( wchar_t const * _Filename, wchar_t const * _VarName, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _VarName, _ResultPath, _Size ); }}
#line 468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) void __cdecl _wsearchenv(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _ResultPath); 
#line 475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) int __cdecl _wsystem(const __wchar_t * _Command); 
#line 484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdlib.h"
}__pragma( pack ( pop )) 
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) void __cdecl _swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 51
__declspec(dllimport) __declspec(noreturn) void __cdecl exit(int _Code); 
#line 52
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int _Code); 
#line 53
__declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(int _Code); 
#line 54
__declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(int _Code); 
#line 55
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(); 
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) unsigned __cdecl _set_abort_behavior(unsigned _Flags, unsigned _Mask); 
#line 72
typedef int (__cdecl *_onexit_t)(void); 
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
int __cdecl atexit(void (__cdecl *)(void)); 
#line 140
_onexit_t __cdecl _onexit(_onexit_t _Func); 
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
int __cdecl at_quick_exit(void (__cdecl *)(void)); 
#line 154
typedef void (__cdecl *_purecall_handler)(void); 
#line 157
typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); 
#line 166
__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler); 
#line 170
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(); 
#line 173
__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 177
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); 
#line 179
__declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 183
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(); 
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl _set_error_mode(int _Mode); 
#line 212
__declspec(dllimport) int *__cdecl _errno(); 
#line 215
__declspec(dllimport) errno_t __cdecl _set_errno(int _Value); 
#line 216
__declspec(dllimport) errno_t __cdecl _get_errno(int * _Value); 
#line 218
__declspec(dllimport) unsigned long *__cdecl __doserrno(); 
#line 221
__declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 222
__declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 225
__declspec(dllimport) char **__cdecl __sys_errlist(); 
#line 228
__declspec(dllimport) int *__cdecl __sys_nerr(); 
#line 231
__declspec(dllimport) void __cdecl perror(const char * _ErrMsg); 
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char **__cdecl __p__pgmptr(); 
#line 238
__declspec(dllimport) __wchar_t **__cdecl __p__wpgmptr(); 
#line 239
__declspec(dllimport) int *__cdecl __p__fmode(); 
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _get_pgmptr(char ** _Value); 
#line 257
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(__wchar_t ** _Value); 
#line 259
__declspec(dllimport) errno_t __cdecl _set_fmode(int _Mode); 
#line 261
__declspec(dllimport) errno_t __cdecl _get_fmode(int * _PMode); 
#line 274
typedef 
#line 270
struct _div_t { 
#line 272
int quot; 
#line 273
int rem; 
#line 274
} div_t; 
#line 280
typedef 
#line 276
struct _ldiv_t { 
#line 278
long quot; 
#line 279
long rem; 
#line 280
} ldiv_t; 
#line 286
typedef 
#line 282
struct _lldiv_t { 
#line 284
__int64 quot; 
#line 285
__int64 rem; 
#line 286
} lldiv_t; 
#line 288
int __cdecl abs(int _Number); 
#line 289
long __cdecl labs(long _Number); 
#line 290
__int64 __cdecl llabs(__int64 _Number); 
#line 291
__int64 __cdecl _abs64(__int64 _Number); 
#line 293
unsigned short __cdecl _byteswap_ushort(unsigned short _Number); 
#line 294
unsigned long __cdecl _byteswap_ulong(unsigned long _Number); 
#line 295
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Number); 
#line 297
__declspec(dllimport) div_t __cdecl div(int _Numerator, int _Denominator); 
#line 298
__declspec(dllimport) ldiv_t __cdecl ldiv(long _Numerator, long _Denominator); 
#line 299
__declspec(dllimport) lldiv_t __cdecl lldiv(__int64 _Numerator, __int64 _Denominator); 
#line 303
#pragma warning (push)
#pragma warning (disable:6540)
#line 306
unsigned __cdecl _rotl(unsigned _Value, int _Shift); 
#line 312
unsigned long __cdecl _lrotl(unsigned long _Value, int _Shift); 
#line 317
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); 
#line 322
unsigned __cdecl _rotr(unsigned _Value, int _Shift); 
#line 328
unsigned long __cdecl _lrotr(unsigned long _Value, int _Shift); 
#line 333
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); 
#line 338
#pragma warning (pop)
#line 345
__declspec(dllimport) void __cdecl srand(unsigned _Seed); 
#line 347
__declspec(dllimport) int __cdecl rand(); 
#line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
extern "C++" {
#line 358
inline long abs(const long _X) throw() 
#line 359
{ 
#line 360
return labs(_X); 
#line 361
} 
#line 363
inline __int64 abs(const __int64 _X) throw() 
#line 364
{ 
#line 365
return llabs(_X); 
#line 366
} 
#line 368
inline ldiv_t div(const long _A1, const long _A2) throw() 
#line 369
{ 
#line 370
return ldiv(_A1, _A2); 
#line 371
} 
#line 373
inline lldiv_t div(const __int64 _A1, const __int64 _A2) throw() 
#line 374
{ 
#line 375
return lldiv(_A1, _A2); 
#line 376
} 
#line 377
}
#line 389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma pack ( push, 4 )
#line 393
typedef 
#line 391
struct { 
#line 392
unsigned char ld[10]; 
#line 393
} _LDOUBLE; 
#pragma pack ( pop )
#line 413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
typedef 
#line 411
struct { 
#line 412
double x; 
#line 413
} _CRT_DOUBLE; 
#line 418
typedef 
#line 416
struct { 
#line 417
float f; 
#line 418
} _CRT_FLOAT; 
#line 427
typedef 
#line 425
struct { 
#line 426
long double x; 
#line 427
} _LONGDOUBLE; 
#line 431
#pragma pack ( push, 4 )
#line 435
typedef 
#line 433
struct { 
#line 434
unsigned char ld12[12]; 
#line 435
} _LDBL12; 
#pragma pack ( pop )
#line 445
__declspec(dllimport) double __cdecl atof(const char * _String); 
#line 446
__declspec(dllimport) int __cdecl atoi(const char * _String); 
#line 447
__declspec(dllimport) long __cdecl atol(const char * _String); 
#line 448
__declspec(dllimport) __int64 __cdecl atoll(const char * _String); 
#line 449
__declspec(dllimport) __int64 __cdecl _atoi64(const char * _String); 
#line 451
__declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 452
__declspec(dllimport) int __cdecl _atoi_l(const char * _String, _locale_t _Locale); 
#line 453
__declspec(dllimport) long __cdecl _atol_l(const char * _String, _locale_t _Locale); 
#line 454
__declspec(dllimport) __int64 __cdecl _atoll_l(const char * _String, _locale_t _Locale); 
#line 455
__declspec(dllimport) __int64 __cdecl _atoi64_l(const char * _String, _locale_t _Locale); 
#line 457
__declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * _Result, const char * _String); 
#line 458
__declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * _Result, char * _String); 
#line 459
__declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * _Result, char * _String); 
#line 462
__declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * _Result, const char * _String, _locale_t _Locale); 
#line 469
__declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 477
__declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 484
__declspec(dllimport) float __cdecl strtof(const char * _String, char ** _EndPtr); 
#line 490
__declspec(dllimport) float __cdecl _strtof_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 497
__declspec(dllimport) double __cdecl strtod(const char * _String, char ** _EndPtr); 
#line 503
__declspec(dllimport) double __cdecl _strtod_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 510
__declspec(dllimport) long double __cdecl strtold(const char * _String, char ** _EndPtr); 
#line 516
__declspec(dllimport) long double __cdecl _strtold_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 523
__declspec(dllimport) long __cdecl strtol(const char * _String, char ** _EndPtr, int _Radix); 
#line 530
__declspec(dllimport) long __cdecl _strtol_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 538
__declspec(dllimport) __int64 __cdecl strtoll(const char * _String, char ** _EndPtr, int _Radix); 
#line 545
__declspec(dllimport) __int64 __cdecl _strtoll_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 553
__declspec(dllimport) unsigned long __cdecl strtoul(const char * _String, char ** _EndPtr, int _Radix); 
#line 560
__declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 568
__declspec(dllimport) unsigned __int64 __cdecl strtoull(const char * _String, char ** _EndPtr, int _Radix); 
#line 575
__declspec(dllimport) unsigned __int64 __cdecl _strtoull_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 583
__declspec(dllimport) __int64 __cdecl _strtoi64(const char * _String, char ** _EndPtr, int _Radix); 
#line 590
__declspec(dllimport) __int64 __cdecl _strtoi64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 598
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(const char * _String, char ** _EndPtr, int _Radix); 
#line 605
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 621
__declspec(dllimport) errno_t __cdecl _itoa_s(int _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 628
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) char *__cdecl _itoa(int _Value, char * _Buffer, int _Radix); 
#line 645 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 649
__declspec(dllimport) errno_t __cdecl _ltoa_s(long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 656
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _ltoa(long _Value, char * _Buffer, int _Radix); 
#line 672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 679
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(dllimport) char *__cdecl _ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 698
__declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 707
__declspec(dllimport) char *__cdecl _i64toa(__int64 _Value, char * _Buffer, int _Radix); 
#line 715
__declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 723
__declspec(dllimport) char *__cdecl _ui64toa(unsigned __int64 _Value, char * _Buffer, int _Radix); 
#line 743
__declspec(dllimport) errno_t __cdecl _ecvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 752
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign ); }}
#line 762 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 771
__declspec(dllimport) errno_t __cdecl _fcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 780
extern "C++" {template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign ); }}
#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 800
__declspec(dllimport) errno_t __cdecl _gcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount); 
#line 807
extern "C++" {template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount ) throw ( ) { return _gcvt_s ( _Buffer, _Size, _Value, _DigitCount ); }}
#line 816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _gcvt(double _Value, int _DigitCount, char * _Buffer); 
#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(); 
#line 848
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale); 
#line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl mblen(const char * _Ch, size_t _MaxCount); 
#line 860
__declspec(dllimport) int __cdecl _mblen_l(const char * _Ch, size_t _MaxCount, _locale_t _Locale); 
#line 868
__declspec(dllimport) size_t __cdecl _mbstrlen(const char * _String); 
#line 874
__declspec(dllimport) size_t __cdecl _mbstrlen_l(const char * _String, _locale_t _Locale); 
#line 881
__declspec(dllimport) size_t __cdecl _mbstrnlen(const char * _String, size_t _MaxCount); 
#line 888
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(const char * _String, size_t _MaxCount, _locale_t _Locale); 
#line 895
__declspec(dllimport) int __cdecl mbtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes); 
#line 902
__declspec(dllimport) int __cdecl _mbtowc_l(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale); 
#line 910
__declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount); 
#line 918
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl mbstowcs(__wchar_t * _Dest, const char * _Source, size_t _MaxCount); 
#line 934 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale); 
#line 943
extern "C++" {template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 952 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl _mbstowcs_l(__wchar_t * _Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl wctomb(char * _MbCh, __wchar_t _WCh); 
#line 971
__declspec(dllimport) int __cdecl _wctomb_l(char * _MbCh, __wchar_t _WCh, _locale_t _Locale); 
#line 980
__declspec(dllimport) errno_t __cdecl wctomb_s(int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, __wchar_t _WCh); 
#line 990 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _wctomb_s_l(int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, __wchar_t _WCh, _locale_t _Locale); 
#line 998
__declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes); 
#line 1006
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 1014 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl wcstombs(char * _Dest, const __wchar_t * _Source, size_t _MaxCount); 
#line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale); 
#line 1031
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 1040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl _wcstombs_l(char * _Dest, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _fullpath(char * _Buffer, const char * _Path, size_t _BufferCount); 
#line 1079
__declspec(dllimport) errno_t __cdecl _makepath_s(char * _Buffer, size_t _BufferCount, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1088
extern "C++" {template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Buffer ) [ _Size ], char const * _Drive, char const * _Dir, char const * _Filename, char const * _Ext ) throw ( ) { return _makepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 1097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) void __cdecl _makepath(char * _Buffer, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 1111
__declspec(dllimport) void __cdecl _splitpath(const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext); 
#line 1120
__declspec(dllimport) errno_t __cdecl _splitpath_s(const char * _FullPath, char * _Drive, size_t _DriveCount, char * _Dir, size_t _DirCount, char * _Filename, size_t _FilenameCount, char * _Ext, size_t _ExtCount); 
#line 1132
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( char const * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 1147
__declspec(dllimport) errno_t __cdecl getenv_s(size_t * _RequiredCount, char * _Buffer, rsize_t _BufferCount, const char * _VarName); 
#line 1159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) int *__cdecl __p___argc(); 
#line 1160
__declspec(dllimport) char ***__cdecl __p___argv(); 
#line 1161
__declspec(dllimport) __wchar_t ***__cdecl __p___wargv(); 
#line 1173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char ***__cdecl __p__environ(); 
#line 1174
__declspec(dllimport) __wchar_t ***__cdecl __p__wenviron(); 
#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl getenv(const char * _VarName); 
#line 1203
extern "C++" {template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _RequiredCount, char ( & _Buffer ) [ _Size ], char const * _VarName ) throw ( ) { return getenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _dupenv_s(char ** _Buffer, size_t * _BufferCount, const char * _VarName); 
#line 1226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl system(const char * _Command); 
#line 1232
#pragma warning (push)
#pragma warning (disable:6540)
#line 1236
__declspec(dllimport) int __cdecl _putenv(const char * _EnvString); 
#line 1241
__declspec(dllimport) errno_t __cdecl _putenv_s(const char * _Name, const char * _Value); 
#line 1246
#pragma warning (pop)
#line 1248
__declspec(dllimport) errno_t __cdecl _searchenv_s(const char * _Filename, const char * _VarName, char * _Buffer, size_t _BufferCount); 
#line 1255
extern "C++" {template < size_t _Size > inline errno_t __cdecl _searchenv_s ( char const * _Filename, char const * _VarName, char ( & _Buffer ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _VarName, _Buffer, _Size ); }}
#line 1262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(dllimport) void __cdecl _searchenv(const char * _Filename, const char * _VarName, char * _Buffer); 
#line 1270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) 
#line 1271
__declspec(dllimport) void __cdecl _seterrormode(int _Mode); 
#line 1275
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) 
#line 1276
__declspec(dllimport) void __cdecl _beep(unsigned _Frequency, unsigned _Duration); 
#line 1281
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) 
#line 1282
__declspec(dllimport) void __cdecl _sleep(unsigned long _Duration); 
#line 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
#line 1311
__declspec(dllimport) char *__cdecl ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 1319
__declspec(dllimport) char *__cdecl fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 1327
__declspec(dllimport) char *__cdecl gcvt(double _Value, int _DigitCount, char * _DstBuf); 
#line 1334
__declspec(dllimport) char *__cdecl itoa(int _Value, char * _Buffer, int _Radix); 
#line 1341
__declspec(dllimport) char *__cdecl ltoa(long _Value, char * _Buffer, int _Radix); 
#line 1349
__declspec(dllimport) void __cdecl swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 1356
__declspec(dllimport) char *__cdecl ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 1367
__declspec(dllimport) int __cdecl putenv(const char * _EnvString); 
#line 1373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 1375
_onexit_t __cdecl onexit(_onexit_t _Func); 
#line 1381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
}
#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1900")
#line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\use_ansi.h"
#pragma comment(lib, "msvcprtd")
#line 1381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdlib.h"
__pragma( pack ( pop )) 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
#pragma pack ( push, 8 )
#line 592 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
typedef __int64 _Longlong; 
#line 593
typedef unsigned __int64 _ULonglong; 
#line 611
namespace std { 
#line 612
enum _Uninitialized { 
#line 614
_Noinit
#line 615
}; 
#line 619
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit { 
#line 644 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
public: __thiscall _Lockit(); 
#line 645
explicit __thiscall _Lockit(int); 
#line 646
__thiscall ~_Lockit() noexcept; 
#line 649 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
static void __cdecl _Lockit_ctor(int); 
#line 650
static void __cdecl _Lockit_dtor(int); 
#line 653
private: static void __cdecl _Lockit_ctor(_Lockit *); 
#line 654
static void __cdecl _Lockit_ctor(_Lockit *, int); 
#line 655
static void __cdecl _Lockit_dtor(_Lockit *); 
#line 658
public: _Lockit(const _Lockit &) = delete;
#line 659
_Lockit &operator=(const _Lockit &) = delete;
#line 662
private: int _Locktype; 
#line 677 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
}; 
#line 764 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
class __declspec(dllimport) _Init_locks { 
#line 780 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
public: __thiscall _Init_locks(); 
#line 781
__thiscall ~_Init_locks() noexcept; 
#line 785 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
#line 786
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 797 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
}; 
#line 799
#pragma warning(pop)
}
#line 809 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\yvals.h"
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void)); 
#line 811
typedef unsigned long _Uint32t; 
#line 817
#pragma pack ( pop )
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath"
inline double abs(double _Xx) noexcept 
#line 18
{ 
#line 19
return ::fabs(_Xx); 
#line 20
} 
#line 22
inline double pow(double _Xx, int _Yx) noexcept 
#line 23
{ 
#line 24
if (_Yx == 2) { 
#line 25
return _Xx * _Xx; }  
#line 27
return ::pow(_Xx, static_cast< double>(_Yx)); 
#line 28
} 
#line 30
inline float abs(float _Xx) noexcept 
#line 31
{ 
#line 32
return ::fabsf(_Xx); 
#line 33
} 
#line 35
inline float acos(float _Xx) noexcept 
#line 36
{ 
#line 37
return ::acosf(_Xx); 
#line 38
} 
#line 40
inline float acosh(float _Xx) noexcept 
#line 41
{ 
#line 42
return ::acoshf(_Xx); 
#line 43
} 
#line 45
inline float asin(float _Xx) noexcept 
#line 46
{ 
#line 47
return ::asinf(_Xx); 
#line 48
} 
#line 50
inline float asinh(float _Xx) noexcept 
#line 51
{ 
#line 52
return ::asinhf(_Xx); 
#line 53
} 
#line 55
inline float atan(float _Xx) noexcept 
#line 56
{ 
#line 57
return ::atanf(_Xx); 
#line 58
} 
#line 60
inline float atanh(float _Xx) noexcept 
#line 61
{ 
#line 62
return ::atanhf(_Xx); 
#line 63
} 
#line 65
inline float atan2(float _Yx, float _Xx) noexcept 
#line 66
{ 
#line 67
return ::atan2f(_Yx, _Xx); 
#line 68
} 
#line 70
inline float cbrt(float _Xx) noexcept 
#line 71
{ 
#line 72
return ::cbrtf(_Xx); 
#line 73
} 
#line 75
inline float ceil(float _Xx) noexcept 
#line 76
{ 
#line 77
return ::ceilf(_Xx); 
#line 78
} 
#line 80
inline float copysign(float _Number, float 
#line 81
_Sign) noexcept 
#line 82
{ 
#line 83
return ::copysignf(_Number, _Sign); 
#line 84
} 
#line 86
inline float cos(float _Xx) noexcept 
#line 87
{ 
#line 88
return ::cosf(_Xx); 
#line 89
} 
#line 91
inline float cosh(float _Xx) noexcept 
#line 92
{ 
#line 93
return ::coshf(_Xx); 
#line 94
} 
#line 96
inline float erf(float _Xx) noexcept 
#line 97
{ 
#line 98
return ::erff(_Xx); 
#line 99
} 
#line 101
inline float erfc(float _Xx) noexcept 
#line 102
{ 
#line 103
return ::erfcf(_Xx); 
#line 104
} 
#line 106
inline float exp(float _Xx) noexcept 
#line 107
{ 
#line 108
return ::expf(_Xx); 
#line 109
} 
#line 111
inline float exp2(float _Xx) noexcept 
#line 112
{ 
#line 113
return ::exp2f(_Xx); 
#line 114
} 
#line 116
inline float expm1(float _Xx) noexcept 
#line 117
{ 
#line 118
return ::expm1f(_Xx); 
#line 119
} 
#line 121
inline float fabs(float _Xx) noexcept 
#line 122
{ 
#line 123
return ::fabsf(_Xx); 
#line 124
} 
#line 126
inline float fdim(float _Xx, float _Yx) noexcept 
#line 127
{ 
#line 128
return ::fdimf(_Xx, _Yx); 
#line 129
} 
#line 131
inline float floor(float _Xx) noexcept 
#line 132
{ 
#line 133
return ::floorf(_Xx); 
#line 134
} 
#line 136
inline float fma(float _Xx, float _Yx, float 
#line 137
_Zx) noexcept 
#line 138
{ 
#line 139
return ::fmaf(_Xx, _Yx, _Zx); 
#line 140
} 
#line 142
inline float fmax(float _Xx, float _Yx) noexcept 
#line 143
{ 
#line 144
return ::fmaxf(_Xx, _Yx); 
#line 145
} 
#line 147
inline float fmin(float _Xx, float _Yx) noexcept 
#line 148
{ 
#line 149
return ::fminf(_Xx, _Yx); 
#line 150
} 
#line 152
inline float fmod(float _Xx, float _Yx) noexcept 
#line 153
{ 
#line 154
return ::fmodf(_Xx, _Yx); 
#line 155
} 
#line 157
inline float frexp(float _Xx, int *_Yx) noexcept 
#line 158
{ 
#line 159
return ::frexpf(_Xx, _Yx); 
#line 160
} 
#line 162
inline float hypot(float _Xx, float _Yx) noexcept 
#line 163
{ 
#line 164
return ::hypotf(_Xx, _Yx); 
#line 165
} 
#line 167
inline int ilogb(float _Xx) noexcept 
#line 168
{ 
#line 169
return ::ilogbf(_Xx); 
#line 170
} 
#line 172
inline float ldexp(float _Xx, int _Yx) noexcept 
#line 173
{ 
#line 174
return ::ldexpf(_Xx, _Yx); 
#line 175
} 
#line 177
inline float lgamma(float _Xx) noexcept 
#line 178
{ 
#line 179
return ::lgammaf(_Xx); 
#line 180
} 
#line 182
inline __int64 llrint(float _Xx) noexcept 
#line 183
{ 
#line 184
return ::llrintf(_Xx); 
#line 185
} 
#line 187
inline __int64 llround(float _Xx) noexcept 
#line 188
{ 
#line 189
return ::llroundf(_Xx); 
#line 190
} 
#line 192
inline float log(float _Xx) noexcept 
#line 193
{ 
#line 194
return ::logf(_Xx); 
#line 195
} 
#line 197
inline float log10(float _Xx) noexcept 
#line 198
{ 
#line 199
return ::log10f(_Xx); 
#line 200
} 
#line 202
inline float log1p(float _Xx) noexcept 
#line 203
{ 
#line 204
return ::log1pf(_Xx); 
#line 205
} 
#line 207
inline float log2(float _Xx) noexcept 
#line 208
{ 
#line 209
return ::log2f(_Xx); 
#line 210
} 
#line 212
inline float logb(float _Xx) noexcept 
#line 213
{ 
#line 214
return ::logbf(_Xx); 
#line 215
} 
#line 217
inline long lrint(float _Xx) noexcept 
#line 218
{ 
#line 219
return ::lrintf(_Xx); 
#line 220
} 
#line 222
inline long lround(float _Xx) noexcept 
#line 223
{ 
#line 224
return ::lroundf(_Xx); 
#line 225
} 
#line 227
inline float modf(float _Xx, float *_Yx) noexcept 
#line 228
{ 
#line 229
return ::modff(_Xx, _Yx); 
#line 230
} 
#line 232
inline float nearbyint(float _Xx) noexcept 
#line 233
{ 
#line 234
return ::nearbyintf(_Xx); 
#line 235
} 
#line 237
inline float nextafter(float _Xx, float _Yx) noexcept 
#line 238
{ 
#line 239
return ::nextafterf(_Xx, _Yx); 
#line 240
} 
#line 242
inline float nexttoward(float _Xx, long double 
#line 243
_Yx) noexcept 
#line 244
{ 
#line 245
return ::nexttowardf(_Xx, _Yx); 
#line 246
} 
#line 248
inline float pow(float _Xx, float 
#line 249
_Yx) noexcept 
#line 250
{ 
#line 251
return ::powf(_Xx, _Yx); 
#line 252
} 
#line 254
inline float pow(float _Xx, int _Yx) noexcept 
#line 255
{ 
#line 256
if (_Yx == 2) { 
#line 257
return _Xx * _Xx; }  
#line 259
return ::powf(_Xx, static_cast< float>(_Yx)); 
#line 260
} 
#line 262
inline float remainder(float _Xx, float _Yx) noexcept 
#line 263
{ 
#line 264
return ::remainderf(_Xx, _Yx); 
#line 265
} 
#line 267
inline float remquo(float _Xx, float _Yx, int *
#line 268
_Zx) noexcept 
#line 269
{ 
#line 270
return ::remquof(_Xx, _Yx, _Zx); 
#line 271
} 
#line 273
inline float rint(float _Xx) noexcept 
#line 274
{ 
#line 275
return ::rintf(_Xx); 
#line 276
} 
#line 278
inline float round(float _Xx) noexcept 
#line 279
{ 
#line 280
return ::roundf(_Xx); 
#line 281
} 
#line 283
inline float scalbln(float _Xx, long _Yx) noexcept 
#line 284
{ 
#line 285
return ::scalblnf(_Xx, _Yx); 
#line 286
} 
#line 288
inline float scalbn(float _Xx, int _Yx) noexcept 
#line 289
{ 
#line 290
return ::scalbnf(_Xx, _Yx); 
#line 291
} 
#line 293
inline float sin(float _Xx) noexcept 
#line 294
{ 
#line 295
return ::sinf(_Xx); 
#line 296
} 
#line 298
inline float sinh(float _Xx) noexcept 
#line 299
{ 
#line 300
return ::sinhf(_Xx); 
#line 301
} 
#line 303
inline float sqrt(float _Xx) noexcept 
#line 304
{ 
#line 305
return ::sqrtf(_Xx); 
#line 306
} 
#line 308
inline float tan(float _Xx) noexcept 
#line 309
{ 
#line 310
return ::tanf(_Xx); 
#line 311
} 
#line 313
inline float tanh(float _Xx) noexcept 
#line 314
{ 
#line 315
return ::tanhf(_Xx); 
#line 316
} 
#line 318
inline float tgamma(float _Xx) noexcept 
#line 319
{ 
#line 320
return ::tgammaf(_Xx); 
#line 321
} 
#line 323
inline float trunc(float _Xx) noexcept 
#line 324
{ 
#line 325
return ::truncf(_Xx); 
#line 326
} 
#line 328
inline long double abs(long double _Xx) noexcept 
#line 329
{ 
#line 330
return ::fabsl(_Xx); 
#line 331
} 
#line 333
inline long double acos(long double _Xx) noexcept 
#line 334
{ 
#line 335
return ::acosl(_Xx); 
#line 336
} 
#line 338
inline long double acosh(long double _Xx) noexcept 
#line 339
{ 
#line 340
return ::acoshl(_Xx); 
#line 341
} 
#line 343
inline long double asin(long double _Xx) noexcept 
#line 344
{ 
#line 345
return ::asinl(_Xx); 
#line 346
} 
#line 348
inline long double asinh(long double _Xx) noexcept 
#line 349
{ 
#line 350
return ::asinhl(_Xx); 
#line 351
} 
#line 353
inline long double atan(long double _Xx) noexcept 
#line 354
{ 
#line 355
return ::atanl(_Xx); 
#line 356
} 
#line 358
inline long double atanh(long double _Xx) noexcept 
#line 359
{ 
#line 360
return ::atanhl(_Xx); 
#line 361
} 
#line 363
inline long double atan2(long double _Yx, long double 
#line 364
_Xx) noexcept 
#line 365
{ 
#line 366
return ::atan2l(_Yx, _Xx); 
#line 367
} 
#line 369
inline long double cbrt(long double _Xx) noexcept 
#line 370
{ 
#line 371
return ::cbrtl(_Xx); 
#line 372
} 
#line 374
inline long double ceil(long double _Xx) noexcept 
#line 375
{ 
#line 376
return ::ceill(_Xx); 
#line 377
} 
#line 379
inline long double copysign(long double _Number, long double 
#line 380
_Sign) noexcept 
#line 381
{ 
#line 382
return ::copysignl(_Number, _Sign); 
#line 383
} 
#line 385
inline long double cos(long double _Xx) noexcept 
#line 386
{ 
#line 387
return ::cosl(_Xx); 
#line 388
} 
#line 390
inline long double cosh(long double _Xx) noexcept 
#line 391
{ 
#line 392
return ::coshl(_Xx); 
#line 393
} 
#line 395
inline long double erf(long double _Xx) noexcept 
#line 396
{ 
#line 397
return ::erfl(_Xx); 
#line 398
} 
#line 400
inline long double erfc(long double _Xx) noexcept 
#line 401
{ 
#line 402
return ::erfcl(_Xx); 
#line 403
} 
#line 405
inline long double exp(long double _Xx) noexcept 
#line 406
{ 
#line 407
return ::expl(_Xx); 
#line 408
} 
#line 410
inline long double exp2(long double _Xx) noexcept 
#line 411
{ 
#line 412
return ::exp2l(_Xx); 
#line 413
} 
#line 415
inline long double expm1(long double _Xx) noexcept 
#line 416
{ 
#line 417
return ::expm1l(_Xx); 
#line 418
} 
#line 420
inline long double fabs(long double _Xx) noexcept 
#line 421
{ 
#line 422
return ::fabsl(_Xx); 
#line 423
} 
#line 425
inline long double fdim(long double _Xx, long double 
#line 426
_Yx) noexcept 
#line 427
{ 
#line 428
return ::fdiml(_Xx, _Yx); 
#line 429
} 
#line 431
inline long double floor(long double _Xx) noexcept 
#line 432
{ 
#line 433
return ::floorl(_Xx); 
#line 434
} 
#line 436
inline long double fma(long double _Xx, long double 
#line 437
_Yx, long double _Zx) noexcept 
#line 438
{ 
#line 439
return ::fmal(_Xx, _Yx, _Zx); 
#line 440
} 
#line 442
inline long double fmax(long double _Xx, long double 
#line 443
_Yx) noexcept 
#line 444
{ 
#line 445
return ::fmaxl(_Xx, _Yx); 
#line 446
} 
#line 448
inline long double fmin(long double _Xx, long double 
#line 449
_Yx) noexcept 
#line 450
{ 
#line 451
return ::fminl(_Xx, _Yx); 
#line 452
} 
#line 454
inline long double fmod(long double _Xx, long double 
#line 455
_Yx) noexcept 
#line 456
{ 
#line 457
return ::fmodl(_Xx, _Yx); 
#line 458
} 
#line 460
inline long double frexp(long double _Xx, int *
#line 461
_Yx) noexcept 
#line 462
{ 
#line 463
return ::frexpl(_Xx, _Yx); 
#line 464
} 
#line 466
inline long double hypot(long double _Xx, long double 
#line 467
_Yx) noexcept 
#line 468
{ 
#line 469
return ::hypotl(_Xx, _Yx); 
#line 470
} 
#line 472
inline int ilogb(long double _Xx) noexcept 
#line 473
{ 
#line 474
return ::ilogbl(_Xx); 
#line 475
} 
#line 477
inline long double ldexp(long double _Xx, int 
#line 478
_Yx) noexcept 
#line 479
{ 
#line 480
return ::ldexpl(_Xx, _Yx); 
#line 481
} 
#line 483
inline long double lgamma(long double _Xx) noexcept 
#line 484
{ 
#line 485
return ::lgammal(_Xx); 
#line 486
} 
#line 488
inline __int64 llrint(long double _Xx) noexcept 
#line 489
{ 
#line 490
return ::llrintl(_Xx); 
#line 491
} 
#line 493
inline __int64 llround(long double _Xx) noexcept 
#line 494
{ 
#line 495
return ::llroundl(_Xx); 
#line 496
} 
#line 498
inline long double log(long double _Xx) noexcept 
#line 499
{ 
#line 500
return ::logl(_Xx); 
#line 501
} 
#line 503
inline long double log10(long double _Xx) noexcept 
#line 504
{ 
#line 505
return ::log10l(_Xx); 
#line 506
} 
#line 508
inline long double log1p(long double _Xx) noexcept 
#line 509
{ 
#line 510
return ::log1pl(_Xx); 
#line 511
} 
#line 513
inline long double log2(long double _Xx) noexcept 
#line 514
{ 
#line 515
return ::log2l(_Xx); 
#line 516
} 
#line 518
inline long double logb(long double _Xx) noexcept 
#line 519
{ 
#line 520
return ::logbl(_Xx); 
#line 521
} 
#line 523
inline long lrint(long double _Xx) noexcept 
#line 524
{ 
#line 525
return ::lrintl(_Xx); 
#line 526
} 
#line 528
inline long lround(long double _Xx) noexcept 
#line 529
{ 
#line 530
return ::lroundl(_Xx); 
#line 531
} 
#line 533
inline long double modf(long double _Xx, long double *
#line 534
_Yx) noexcept 
#line 535
{ 
#line 536
return ::modfl(_Xx, _Yx); 
#line 537
} 
#line 539
inline long double nearbyint(long double _Xx) noexcept 
#line 540
{ 
#line 541
return ::nearbyintl(_Xx); 
#line 542
} 
#line 544
inline long double nextafter(long double _Xx, long double 
#line 545
_Yx) noexcept 
#line 546
{ 
#line 547
return ::nextafterl(_Xx, _Yx); 
#line 548
} 
#line 550
inline long double nexttoward(long double _Xx, long double 
#line 551
_Yx) noexcept 
#line 552
{ 
#line 553
return ::nexttowardl(_Xx, _Yx); 
#line 554
} 
#line 556
inline long double pow(long double _Xx, long double 
#line 557
_Yx) noexcept 
#line 558
{ 
#line 559
return ::powl(_Xx, _Yx); 
#line 560
} 
#line 562
inline long double pow(long double _Xx, int 
#line 563
_Yx) noexcept 
#line 564
{ 
#line 565
if (_Yx == 2) { 
#line 566
return _Xx * _Xx; }  
#line 568
return ::powl(_Xx, static_cast< long double>(_Yx)); 
#line 569
} 
#line 571
inline long double remainder(long double _Xx, long double 
#line 572
_Yx) noexcept 
#line 573
{ 
#line 574
return ::remainderl(_Xx, _Yx); 
#line 575
} 
#line 577
inline long double remquo(long double _Xx, long double 
#line 578
_Yx, int *_Zx) noexcept 
#line 579
{ 
#line 580
return ::remquol(_Xx, _Yx, _Zx); 
#line 581
} 
#line 583
inline long double rint(long double _Xx) noexcept 
#line 584
{ 
#line 585
return ::rintl(_Xx); 
#line 586
} 
#line 588
inline long double round(long double _Xx) noexcept 
#line 589
{ 
#line 590
return ::roundl(_Xx); 
#line 591
} 
#line 593
inline long double scalbln(long double _Xx, long 
#line 594
_Yx) noexcept 
#line 595
{ 
#line 596
return ::scalblnl(_Xx, _Yx); 
#line 597
} 
#line 599
inline long double scalbn(long double _Xx, int 
#line 600
_Yx) noexcept 
#line 601
{ 
#line 602
return ::scalbnl(_Xx, _Yx); 
#line 603
} 
#line 605
inline long double sin(long double _Xx) noexcept 
#line 606
{ 
#line 607
return ::sinl(_Xx); 
#line 608
} 
#line 610
inline long double sinh(long double _Xx) noexcept 
#line 611
{ 
#line 612
return ::sinhl(_Xx); 
#line 613
} 
#line 615
inline long double sqrt(long double _Xx) noexcept 
#line 616
{ 
#line 617
return ::sqrtl(_Xx); 
#line 618
} 
#line 620
inline long double tan(long double _Xx) noexcept 
#line 621
{ 
#line 622
return ::tanl(_Xx); 
#line 623
} 
#line 625
inline long double tanh(long double _Xx) noexcept 
#line 626
{ 
#line 627
return ::tanhl(_Xx); 
#line 628
} 
#line 630
inline long double tgamma(long double _Xx) noexcept 
#line 631
{ 
#line 632
return ::tgammal(_Xx); 
#line 633
} 
#line 635
inline long double trunc(long double _Xx) noexcept 
#line 636
{ 
#line 637
return ::truncl(_Xx); 
#line 638
} 
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdlib"
namespace std { 
#line 18
using ::size_t;using ::div_t;using ::ldiv_t;
#line 19
using ::abort;using ::abs;using ::atexit;
#line 20
using ::atof;using ::atoi;using ::atol;
#line 21
using ::bsearch;using ::calloc;using ::div;
#line 22
using ::exit;using ::free;
#line 23
using ::labs;using ::ldiv;using ::malloc;
#line 24
using ::mblen;using ::mbstowcs;using ::mbtowc;
#line 25
using ::qsort;using ::rand;using ::realloc;
#line 26
using ::srand;using ::strtod;using ::strtol;
#line 27
using ::strtoul;
#line 28
using ::wcstombs;using ::wctomb;
#line 30
using ::lldiv_t;
#line 33
using ::getenv;
#line 34
using ::system;
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdlib"
using ::atoll;using ::llabs;using ::lldiv;
#line 38
using ::strtof;using ::strtold;
#line 39
using ::strtoll;using ::strtoull;
#line 41
using ::_Exit;using ::at_quick_exit;using ::quick_exit;
#line 42
}
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
struct _Nil { 
#line 17
}; 
#line 20
template < class _Ty,
 _Ty _Val >
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant < _Ty, _Val > type;

 constexpr operator value_type ( ) const noexcept
  {
  return ( value );
  }

 constexpr value_type operator ( ) ( ) const noexcept
  {
  return ( value );
  }
 };
#line 40
typedef integral_constant< bool, true>  true_type; 
#line 41
typedef integral_constant< bool, false>  false_type; 
#line 44
template< bool _Val> using bool_constant = integral_constant< bool, _Val> ; 
#line 48
template< bool _Val> 
#line 49
struct _Cat_base : public integral_constant< bool, _Val>  { 
#line 52
}; 
#line 55
template< bool _Test, class 
#line 56
_Ty = void> 
#line 57
struct enable_if { 
#line 59
}; 
#line 61
template< class _Ty> 
#line 62
struct enable_if< true, _Ty>  { 
#line 64
typedef _Ty type; 
#line 65
}; 
#line 68
template< bool _Test, class 
#line 69
_Ty1, class 
#line 70
_Ty2> 
#line 71
struct conditional { 
#line 73
typedef _Ty2 type; 
#line 74
}; 
#line 76
template< class _Ty1, class 
#line 77
_Ty2> 
#line 78
struct conditional< true, _Ty1, _Ty2>  { 
#line 80
typedef _Ty1 type; 
#line 81
}; 
#line 84
template< class _Ty1, class 
#line 85
_Ty2> 
#line 86
struct is_same : public false_type { 
#line 89
}; 
#line 91
template< class _Ty1> 
#line 92
struct is_same< _Ty1, _Ty1>  : public true_type { 
#line 95
}; 
#line 98
template< class _Ty, class 
#line 99
_Uty> constexpr bool 
#line 100
is_same_v = (is_same< _Ty, _Uty> ::value); 
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
template< class _Ty> 
#line 105
struct remove_const { 
#line 107
typedef _Ty type; 
#line 108
}; 
#line 110
template< class _Ty> 
#line 111
struct remove_const< const _Ty>  { 
#line 113
typedef _Ty type; 
#line 114
}; 
#line 117
template< class _Ty> 
#line 118
struct remove_volatile { 
#line 120
typedef _Ty type; 
#line 121
}; 
#line 123
template< class _Ty> 
#line 124
struct remove_volatile< volatile _Ty>  { 
#line 126
typedef _Ty type; 
#line 127
}; 
#line 130
template< class _Ty> 
#line 131
struct remove_cv { 
#line 134
typedef typename remove_const< typename remove_volatile< _Ty> ::type> ::type type; 
#line 135
}; 
#line 138
template< class _Ty> 
#line 139
struct _Is_integral : public false_type { 
#line 142
}; 
#line 145
template<> struct _Is_integral< bool>  : public true_type { 
#line 148
}; 
#line 151
template<> struct _Is_integral< char>  : public true_type { 
#line 154
}; 
#line 157
template<> struct _Is_integral< unsigned char>  : public true_type { 
#line 160
}; 
#line 163
template<> struct _Is_integral< signed char>  : public true_type { 
#line 166
}; 
#line 170
template<> struct _Is_integral< __wchar_t>  : public true_type { 
#line 173
}; 
#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
template<> struct _Is_integral< unsigned short>  : public true_type { 
#line 180
}; 
#line 183
template<> struct _Is_integral< signed short>  : public true_type { 
#line 186
}; 
#line 189
template<> struct _Is_integral< unsigned>  : public true_type { 
#line 192
}; 
#line 195
template<> struct _Is_integral< signed int>  : public true_type { 
#line 198
}; 
#line 201
template<> struct _Is_integral< unsigned long>  : public true_type { 
#line 204
}; 
#line 207
template<> struct _Is_integral< signed long>  : public true_type { 
#line 210
}; 
#line 213
template<> struct _Is_integral< char16_t>  : public true_type { 
#line 216
}; 
#line 219
template<> struct _Is_integral< char32_t>  : public true_type { 
#line 222
}; 
#line 225
template<> struct _Is_integral< __int64>  : public true_type { 
#line 228
}; 
#line 231
template<> struct _Is_integral< unsigned __int64>  : public true_type { 
#line 234
}; 
#line 237
template< class _Ty> 
#line 238
struct is_integral : public _Is_integral< typename remove_cv< _Ty> ::type>  { 
#line 241
}; 
#line 244
template< class _Ty> constexpr bool 
#line 245
is_integral_v = (is_integral< _Ty> ::value); 
#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
template< class _Ty> 
#line 250
struct _Is_floating_point : public false_type { 
#line 253
}; 
#line 256
template<> struct _Is_floating_point< float>  : public true_type { 
#line 259
}; 
#line 262
template<> struct _Is_floating_point< double>  : public true_type { 
#line 265
}; 
#line 268
template<> struct _Is_floating_point< long double>  : public true_type { 
#line 271
}; 
#line 274
template< class _Ty> 
#line 275
struct is_floating_point : public _Is_floating_point< typename remove_cv< _Ty> ::type>  { 
#line 278
}; 
#line 281
template< class _Ty> constexpr bool 
#line 282
is_floating_point_v = (is_floating_point< _Ty> ::value); 
#line 286 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
template< class _Ty> 
#line 287
struct is_arithmetic : public _Cat_base< is_integral< _Ty> ::value || is_floating_point< _Ty> ::value>  { 
#line 291
}; 
#line 294
template< class _Ty> constexpr bool 
#line 295
is_arithmetic_v = (is_arithmetic< _Ty> ::value); 
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
template< class _Ty> 
#line 300
struct remove_reference { 
#line 302
typedef _Ty type; 
#line 303
}; 
#line 305
template< class _Ty> 
#line 306
struct remove_reference< _Ty &>  { 
#line 308
typedef _Ty type; 
#line 309
}; 
#line 311
template< class _Ty> 
#line 312
struct remove_reference< _Ty &&>  { 
#line 314
typedef _Ty type; 
#line 315
}; 
#line 318
struct _Wrap_int { 
#line 320
_Wrap_int(int) 
#line 321
{ 
#line 322
} 
#line 323
}; 
#line 325
template< class _Ty> 
#line 326
struct _Identity { 
#line 328
typedef _Ty type; 
#line 329
}; 
#line 344
}
#line 346
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtgmath.h"
#pragma warning(push,3)
#line 347 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtr1common"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xtgmath.h"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 16
template< class _Ty> 
#line 17
struct _Promote_to_float { 
#line 20
typedef typename conditional< is_integral< _Ty> ::value, double, _Ty> ::type type; 
#line 21
}; 
#line 23
template< class _Ty1, class 
#line 24
_Ty2> 
#line 25
struct _Common_float_type { 
#line 27
typedef typename _Promote_to_float< _Ty1> ::type _Ty1f; 
#line 28
typedef typename _Promote_to_float< _Ty2> ::type _Ty2f; 
#line 33
typedef typename conditional< is_same< typename _Promote_to_float< _Ty1> ::type, long double> ::value || is_same< typename _Promote_to_float< _Ty2> ::type, long double> ::value, long double, typename conditional< is_same< typename _Promote_to_float< _Ty1> ::type, double> ::value || is_same< typename _Promote_to_float< _Ty2> ::type, double> ::value, double, float> ::type> ::type type; 
#line 34
}; 
#line 35
}
#line 76
template < class _Ty1,
 class _Ty2 > inline
 typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value
  && :: std :: is_arithmetic < _Ty2 > :: value,
  typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type
 pow ( const _Ty1 _Left, const _Ty2 _Right )
 {
 typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type;
 return ( :: pow ( type ( _Left ), type ( _Right ) ) );
 }
#line 88
extern "C" double __cdecl acos(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type acos ( _Ty _Left ) { return ( :: acos ( ( double ) _Left ) ); }
#line 89
extern "C" double __cdecl asin(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type asin ( _Ty _Left ) { return ( :: asin ( ( double ) _Left ) ); }
#line 90
extern "C" double __cdecl atan(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type atan ( _Ty _Left ) { return ( :: atan ( ( double ) _Left ) ); }
#line 91
extern "C" double __cdecl atan2(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type atan2 ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: atan2 ( ( type ) _Left, ( type ) _Right ) ); }
#line 92
extern "C" __declspec(dllimport) double __cdecl ceil(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type ceil ( _Ty _Left ) { return ( :: ceil ( ( double ) _Left ) ); }
#line 93
extern "C" double __cdecl cos(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cos ( _Ty _Left ) { return ( :: cos ( ( double ) _Left ) ); }
#line 94
extern "C" double __cdecl cosh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cosh ( _Ty _Left ) { return ( :: cosh ( ( double ) _Left ) ); }
#line 95
extern "C" double __cdecl exp(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type exp ( _Ty _Left ) { return ( :: exp ( ( double ) _Left ) ); }
#line 97
extern "C" double __cdecl fabs(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type fabs ( _Ty _Left ) { return ( :: fabs ( ( double ) _Left ) ); }
#line 99
extern "C" __declspec(dllimport) double __cdecl floor(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type floor ( _Ty _Left ) { return ( :: floor ( ( double ) _Left ) ); }
#line 100
extern "C" double __cdecl fmod(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fmod ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmod ( ( type ) _Left, ( type ) _Right ) ); }
#line 101
extern "C" __declspec(dllimport) double __cdecl frexp(double, int *); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type frexp ( _Ty _Left, int * _Arg2 ) { return ( :: frexp ( ( double ) _Left, _Arg2 ) ); }
#line 102
extern "C" __declspec(dllimport) double __cdecl ldexp(double, int); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type ldexp ( _Ty _Left, int _Arg2 ) { return ( :: ldexp ( ( double ) _Left, _Arg2 ) ); }
#line 103
extern "C" double __cdecl log(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log ( _Ty _Left ) { return ( :: log ( ( double ) _Left ) ); }
#line 104
extern "C" double __cdecl log10(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log10 ( _Ty _Left ) { return ( :: log10 ( ( double ) _Left ) ); }
#line 107
extern "C" double __cdecl sin(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sin ( _Ty _Left ) { return ( :: sin ( ( double ) _Left ) ); }
#line 108
extern "C" double __cdecl sinh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sinh ( _Ty _Left ) { return ( :: sinh ( ( double ) _Left ) ); }
#line 109
extern "C" double __cdecl sqrt(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sqrt ( _Ty _Left ) { return ( :: sqrt ( ( double ) _Left ) ); }
#line 110
extern "C" double __cdecl tan(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tan ( _Ty _Left ) { return ( :: tan ( ( double ) _Left ) ); }
#line 111
extern "C" double __cdecl tanh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tanh ( _Ty _Left ) { return ( :: tanh ( ( double ) _Left ) ); }
#line 125
inline float _Fma(float _Left, float _Middle, float _Right) 
#line 126
{ 
#line 127
return ::fmaf(_Left, _Middle, _Right); 
#line 128
} 
#line 130
inline double _Fma(double _Left, double _Middle, double _Right) 
#line 131
{ 
#line 132
return ::fma(_Left, _Middle, _Right); 
#line 133
} 
#line 135
inline long double _Fma(long double _Left, long double _Middle, long double 
#line 136
_Right) 
#line 137
{ 
#line 138
return ::fmal(_Left, _Middle, _Right); 
#line 139
} 
#line 141
template < class _Ty1,
 class _Ty2,
 class _Ty3 > inline
 typename :: std :: _Common_float_type < _Ty1,
  typename :: std :: _Common_float_type < _Ty2, _Ty3 > :: type > :: type
 fma ( _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right )
 {
 typedef typename :: std :: _Common_float_type < _Ty1,
  typename :: std :: _Common_float_type < _Ty2, _Ty3 > :: type > :: type type;
 return ( _Fma ( ( type ) _Left, ( type ) _Middle, ( type ) _Right ) );
 }
#line 155
inline float _Remquo(float _Left, float _Right, int *_Pquo) 
#line 156
{ 
#line 157
return ::remquof(_Left, _Right, _Pquo); 
#line 158
} 
#line 160
inline double _Remquo(double _Left, double _Right, int *_Pquo) 
#line 161
{ 
#line 162
return ::remquo(_Left, _Right, _Pquo); 
#line 163
} 
#line 165
inline long double _Remquo(long double _Left, long double _Right, int *_Pquo) 
#line 166
{ 
#line 167
return ::remquol(_Left, _Right, _Pquo); 
#line 168
} 
#line 170
template < class _Ty1,
 class _Ty2 > inline
 typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type
 remquo ( _Ty1 _Left, _Ty2 _Right, int * _Pquo )
 {
 typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type;
 return ( _Remquo ( ( type ) _Left, ( type ) _Right, _Pquo ) );
 }
#line 179
extern "C" __declspec(dllimport) double __cdecl acosh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type acosh ( _Ty _Left ) { return ( :: acosh ( ( double ) _Left ) ); }
#line 180
extern "C" __declspec(dllimport) double __cdecl asinh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type asinh ( _Ty _Left ) { return ( :: asinh ( ( double ) _Left ) ); }
#line 181
extern "C" __declspec(dllimport) double __cdecl atanh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type atanh ( _Ty _Left ) { return ( :: atanh ( ( double ) _Left ) ); }
#line 182
extern "C" __declspec(dllimport) double __cdecl cbrt(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cbrt ( _Ty _Left ) { return ( :: cbrt ( ( double ) _Left ) ); }
#line 183
extern "C" __declspec(dllimport) double __cdecl copysign(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type copysign ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: copysign ( ( type ) _Left, ( type ) _Right ) ); }
#line 184
extern "C" __declspec(dllimport) double __cdecl erf(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type erf ( _Ty _Left ) { return ( :: erf ( ( double ) _Left ) ); }
#line 185
extern "C" __declspec(dllimport) double __cdecl erfc(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type erfc ( _Ty _Left ) { return ( :: erfc ( ( double ) _Left ) ); }
#line 186
extern "C" __declspec(dllimport) double __cdecl expm1(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type expm1 ( _Ty _Left ) { return ( :: expm1 ( ( double ) _Left ) ); }
#line 187
extern "C" __declspec(dllimport) double __cdecl exp2(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type exp2 ( _Ty _Left ) { return ( :: exp2 ( ( double ) _Left ) ); }
#line 188
extern "C" __declspec(dllimport) double __cdecl fdim(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fdim ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fdim ( ( type ) _Left, ( type ) _Right ) ); }
#line 190
extern "C" __declspec(dllimport) double __cdecl fmax(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fmax ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmax ( ( type ) _Left, ( type ) _Right ) ); }
#line 191
extern "C" __declspec(dllimport) double __cdecl fmin(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fmin ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmin ( ( type ) _Left, ( type ) _Right ) ); }
#line 192
extern "C" __declspec(dllimport) double __cdecl hypot(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type hypot ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: hypot ( ( type ) _Left, ( type ) _Right ) ); }
#line 193
extern "C" __declspec(dllimport) int __cdecl ilogb(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, int > :: type ilogb ( _Ty _Left ) { return ( :: ilogb ( ( double ) _Left ) ); }
#line 194
extern "C" __declspec(dllimport) double __cdecl lgamma(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type lgamma ( _Ty _Left ) { return ( :: lgamma ( ( double ) _Left ) ); }
#line 195
extern "C" __declspec(dllimport) __int64 __cdecl llrint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long long > :: type llrint ( _Ty _Left ) { return ( :: llrint ( ( double ) _Left ) ); }
#line 196
extern "C" __declspec(dllimport) __int64 __cdecl llround(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long long > :: type llround ( _Ty _Left ) { return ( :: llround ( ( double ) _Left ) ); }
#line 197
extern "C" __declspec(dllimport) double __cdecl log1p(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log1p ( _Ty _Left ) { return ( :: log1p ( ( double ) _Left ) ); }
#line 198
extern "C" __declspec(dllimport) double __cdecl log2(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log2 ( _Ty _Left ) { return ( :: log2 ( ( double ) _Left ) ); }
#line 199
extern "C" __declspec(dllimport) double __cdecl logb(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type logb ( _Ty _Left ) { return ( :: logb ( ( double ) _Left ) ); }
#line 200
extern "C" __declspec(dllimport) long __cdecl lrint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long > :: type lrint ( _Ty _Left ) { return ( :: lrint ( ( double ) _Left ) ); }
#line 201
extern "C" __declspec(dllimport) long __cdecl lround(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long > :: type lround ( _Ty _Left ) { return ( :: lround ( ( double ) _Left ) ); }
#line 202
extern "C" __declspec(dllimport) double __cdecl nearbyint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type nearbyint ( _Ty _Left ) { return ( :: nearbyint ( ( double ) _Left ) ); }
#line 203
extern "C" __declspec(dllimport) double __cdecl nextafter(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type nextafter ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: nextafter ( ( type ) _Left, ( type ) _Right ) ); }
#line 204
extern "C" __declspec(dllimport) double __cdecl nexttoward(double, long double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type nexttoward ( _Ty _Left, long double _Arg2 ) { return ( :: nexttoward ( ( double ) _Left, _Arg2 ) ); }
#line 205
extern "C" __declspec(dllimport) double __cdecl remainder(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: is_arithmetic < _Ty1 > :: value && :: std :: is_arithmetic < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type remainder ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: remainder ( ( type ) _Left, ( type ) _Right ) ); }
#line 207
extern "C" __declspec(dllimport) double __cdecl rint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type rint ( _Ty _Left ) { return ( :: rint ( ( double ) _Left ) ); }
#line 208
extern "C" __declspec(dllimport) double __cdecl round(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type round ( _Ty _Left ) { return ( :: round ( ( double ) _Left ) ); }
#line 209
extern "C" __declspec(dllimport) double __cdecl scalbln(double, long); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type scalbln ( _Ty _Left, long _Arg2 ) { return ( :: scalbln ( ( double ) _Left, _Arg2 ) ); }
#line 210
extern "C" __declspec(dllimport) double __cdecl scalbn(double, int); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type scalbn ( _Ty _Left, int _Arg2 ) { return ( :: scalbn ( ( double ) _Left, _Arg2 ) ); }
#line 211
extern "C" __declspec(dllimport) double __cdecl tgamma(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tgamma ( _Ty _Left ) { return ( :: tgamma ( ( double ) _Left ) ); }
#line 212
extern "C" __declspec(dllimport) double __cdecl trunc(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type trunc ( _Ty _Left ) { return ( :: trunc ( ( double ) _Left ) ); }
#line 215
#pragma warning(pop)
#pragma pack ( pop )
#line 651 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cmath"
namespace std { 
#line 652
using ::abs;using ::acos;using ::asin;
#line 653
using ::atan;using ::atan2;using ::ceil;
#line 654
using ::cos;using ::cosh;using ::exp;
#line 655
using ::fabs;using ::floor;using ::fmod;
#line 656
using ::frexp;using ::ldexp;using ::log;
#line 657
using ::log10;using ::modf;using ::pow;
#line 658
using ::sin;using ::sinh;using ::sqrt;
#line 659
using ::tan;using ::tanh;
#line 661
using ::acosf;using ::asinf;
#line 662
using ::atanf;using ::atan2f;using ::ceilf;
#line 663
using ::cosf;using ::coshf;using ::expf;
#line 664
using ::fabsf;using ::floorf;using ::fmodf;
#line 665
using ::frexpf;using ::ldexpf;using ::logf;
#line 666
using ::log10f;using ::modff;using ::powf;
#line 667
using ::sinf;using ::sinhf;using ::sqrtf;
#line 668
using ::tanf;using ::tanhf;
#line 670
using ::acosl;using ::asinl;
#line 671
using ::atanl;using ::atan2l;using ::ceill;
#line 672
using ::cosl;using ::coshl;using ::expl;
#line 673
using ::fabsl;using ::floorl;using ::fmodl;
#line 674
using ::frexpl;using ::ldexpl;using ::logl;
#line 675
using ::log10l;using ::modfl;using ::powl;
#line 676
using ::sinl;using ::sinhl;using ::sqrtl;
#line 677
using ::tanl;using ::tanhl;
#line 679
using ::float_t;using ::double_t;
#line 681
using ::acosh;using ::asinh;using ::atanh;
#line 682
using ::cbrt;using ::erf;using ::erfc;
#line 683
using ::expm1;using ::exp2;
#line 684
using ::hypot;using ::ilogb;using ::lgamma;
#line 685
using ::log1p;using ::log2;using ::logb;
#line 686
using ::llrint;using ::lrint;using ::nearbyint;
#line 687
using ::rint;using ::llround;using ::lround;
#line 688
using ::fdim;using ::fma;using ::fmax;using ::fmin;
#line 689
using ::round;using ::trunc;
#line 690
using ::remainder;using ::remquo;
#line 691
using ::copysign;using ::nan;using ::nextafter;
#line 692
using ::scalbn;using ::scalbln;
#line 693
using ::nexttoward;using ::tgamma;
#line 695
using ::acoshf;using ::asinhf;using ::atanhf;
#line 696
using ::cbrtf;using ::erff;using ::erfcf;
#line 697
using ::expm1f;using ::exp2f;
#line 698
using ::hypotf;using ::ilogbf;using ::lgammaf;
#line 699
using ::log1pf;using ::log2f;using ::logbf;
#line 700
using ::llrintf;using ::lrintf;using ::nearbyintf;
#line 701
using ::rintf;using ::llroundf;using ::lroundf;
#line 702
using ::fdimf;using ::fmaf;using ::fmaxf;using ::fminf;
#line 703
using ::roundf;using ::truncf;
#line 704
using ::remainderf;using ::remquof;
#line 705
using ::copysignf;using ::nanf;
#line 706
using ::nextafterf;using ::scalbnf;using ::scalblnf;
#line 707
using ::nexttowardf;using ::tgammaf;
#line 709
using ::acoshl;using ::asinhl;using ::atanhl;
#line 710
using ::cbrtl;using ::erfl;using ::erfcl;
#line 711
using ::expm1l;using ::exp2l;
#line 712
using ::hypotl;using ::ilogbl;using ::lgammal;
#line 713
using ::log1pl;using ::log2l;using ::logbl;
#line 714
using ::llrintl;using ::lrintl;using ::nearbyintl;
#line 715
using ::rintl;using ::llroundl;using ::lroundl;
#line 716
using ::fdiml;using ::fmal;using ::fmaxl;using ::fminl;
#line 717
using ::roundl;using ::truncl;
#line 718
using ::remainderl;using ::remquol;
#line 719
using ::copysignl;using ::nanl;
#line 720
using ::nextafterl;using ::scalbnl;using ::scalblnl;
#line 721
using ::nexttowardl;using ::tgammal;
#line 723
using ::fpclassify;using ::signbit;
#line 724
using ::isfinite;using ::isinf;
#line 725
using ::isnan;using ::isnormal;
#line 726
using ::isgreater;using ::isgreaterequal;
#line 727
using ::isless;using ::islessequal;
#line 728
using ::islessgreater;using ::isunordered;
#line 729
}
#line 9063 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl _hypot(double x, double y); 
#line 9064
extern "C" __declspec(dllimport) float __cdecl _hypotf(float x, float y); 
#line 9074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline bool signbit(long double) throw(); 
#line 9075
extern "C" __declspec(dllimport) int _ldsign(long double); 
#line 9118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline bool signbit(double) throw(); 
#line 9119
extern "C" __declspec(dllimport) int _dsign(double); 
#line 9163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline bool signbit(float) throw(); 
#line 9164
extern "C" __declspec(dllimport) int _fdsign(float); 
#line 9172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isinf(long double a); 
#line 9207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isinf(double a); 
#line 9245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isinf(float a); 
#line 9252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isnan(long double a); 
#line 9285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isnan(double a); 
#line 9321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isnan(float a); 
#line 9328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isfinite(long double a); 
#line 9365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isfinite(double a); 
#line 9401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static __inline bool isfinite(float a); 
#line 9409 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
template< class T> extern T _Pow_int(T, int) throw(); 
#line 9410
extern inline __int64 abs(__int64) throw(); 
#line 9485 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline long __cdecl abs(long) throw(); 
#line 9489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline float __cdecl abs(float) throw(); 
#line 9490
extern inline double __cdecl abs(double) throw(); 
#line 9491
extern inline float __cdecl fabs(float) throw(); 
#line 9492
extern inline float __cdecl ceil(float) throw(); 
#line 9493
extern inline float __cdecl floor(float) throw(); 
#line 9494
extern inline float __cdecl sqrt(float) throw(); 
#line 9495
extern inline float __cdecl pow(float, float) throw(); 
#line 9520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline float __cdecl pow(float, int) throw(); 
#line 9521
extern inline double __cdecl pow(double, int) throw(); 
#line 9524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline float __cdecl log(float) throw(); 
#line 9525
extern inline float __cdecl log10(float) throw(); 
#line 9526
extern inline float __cdecl fmod(float, float) throw(); 
#line 9527
extern inline float __cdecl modf(float, float *) throw(); 
#line 9528
extern inline float __cdecl exp(float) throw(); 
#line 9529
extern inline float __cdecl frexp(float, int *) throw(); 
#line 9530
extern inline float __cdecl ldexp(float, int) throw(); 
#line 9531
extern inline float __cdecl asin(float) throw(); 
#line 9532
extern inline float __cdecl sin(float) throw(); 
#line 9533
extern inline float __cdecl sinh(float) throw(); 
#line 9534
extern inline float __cdecl acos(float) throw(); 
#line 9535
extern inline float __cdecl cos(float) throw(); 
#line 9536
extern inline float __cdecl cosh(float) throw(); 
#line 9537
extern inline float __cdecl atan(float) throw(); 
#line 9538
extern inline float __cdecl atan2(float, float) throw(); 
#line 9539
extern inline float __cdecl tan(float) throw(); 
#line 9540
extern inline float __cdecl tanh(float) throw(); 
#line 9770 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
extern inline float __cdecl logb(float) throw(); 
#line 9771
extern inline int __cdecl ilogb(float) throw(); 
#line 9772
extern float __cdecl scalbn(float, float) throw(); 
#line 9773
extern inline float __cdecl scalbln(float, long) throw(); 
#line 9774
extern inline float __cdecl exp2(float) throw(); 
#line 9775
extern inline float __cdecl expm1(float) throw(); 
#line 9776
extern inline float __cdecl log2(float) throw(); 
#line 9777
extern inline float __cdecl log1p(float) throw(); 
#line 9778
extern inline float __cdecl acosh(float) throw(); 
#line 9779
extern inline float __cdecl asinh(float) throw(); 
#line 9780
extern inline float __cdecl atanh(float) throw(); 
#line 9781
extern inline float __cdecl hypot(float, float) throw(); 
#line 9782
extern float __cdecl norm3d(float, float, float) throw(); 
#line 9783
extern float __cdecl norm4d(float, float, float, float) throw(); 
#line 9784
extern inline float __cdecl cbrt(float) throw(); 
#line 9785
extern inline float __cdecl erf(float) throw(); 
#line 9786
extern inline float __cdecl erfc(float) throw(); 
#line 9787
extern inline float __cdecl lgamma(float) throw(); 
#line 9788
extern inline float __cdecl tgamma(float) throw(); 
#line 9789
extern inline float __cdecl copysign(float, float) throw(); 
#line 9790
extern inline float __cdecl nextafter(float, float) throw(); 
#line 9791
extern inline float __cdecl remainder(float, float) throw(); 
#line 9792
extern inline float __cdecl remquo(float, float, int *) throw(); 
#line 9793
extern inline float __cdecl round(float) throw(); 
#line 9794
extern inline long __cdecl lround(float) throw(); 
#line 9795
extern inline __int64 __cdecl llround(float) throw(); 
#line 9796
extern inline float __cdecl trunc(float) throw(); 
#line 9797
extern inline float __cdecl rint(float) throw(); 
#line 9798
extern inline long __cdecl lrint(float) throw(); 
#line 9799
extern inline __int64 __cdecl llrint(float) throw(); 
#line 9800
extern inline float __cdecl nearbyint(float) throw(); 
#line 9801
extern inline float __cdecl fdim(float, float) throw(); 
#line 9802
extern inline float __cdecl fma(float, float, float) throw(); 
#line 9803
extern inline float __cdecl fmax(float, float) throw(); 
#line 9804
extern inline float __cdecl fmin(float, float) throw(); 
#line 9807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.h"
static inline float exp10(float a); 
#line 9809
static inline float rsqrt(float a); 
#line 9811
static inline float rcbrt(float a); 
#line 9813
static inline float sinpi(float a); 
#line 9815
static inline float cospi(float a); 
#line 9817
static inline void sincospi(float a, float * sptr, float * cptr); 
#line 9819
static inline void sincos(float a, float * sptr, float * cptr); 
#line 9821
static inline float j0(float a); 
#line 9823
static inline float j1(float a); 
#line 9825
static inline float jn(int n, float a); 
#line 9827
static inline float y0(float a); 
#line 9829
static inline float y1(float a); 
#line 9831
static inline float yn(int n, float a); 
#line 9833
static inline float cyl_bessel_i0(float a); 
#line 9835
static inline float cyl_bessel_i1(float a); 
#line 9837
static inline float erfinv(float a); 
#line 9839
static inline float erfcinv(float a); 
#line 9841
static inline float normcdfinv(float a); 
#line 9843
static inline float normcdf(float a); 
#line 9845
static inline float erfcx(float a); 
#line 9847
static inline double copysign(double a, float b); 
#line 9849
static inline double copysign(float a, double b); 
#line 9851
static inline unsigned min(unsigned a, unsigned b); 
#line 9853
static inline unsigned min(int a, unsigned b); 
#line 9855
static inline unsigned min(unsigned a, int b); 
#line 9857
static inline long min(long a, long b); 
#line 9859
static inline unsigned long min(unsigned long a, unsigned long b); 
#line 9861
static inline unsigned long min(long a, unsigned long b); 
#line 9863
static inline unsigned long min(unsigned long a, long b); 
#line 9865
static inline __int64 min(__int64 a, __int64 b); 
#line 9867
static inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b); 
#line 9869
static inline unsigned __int64 min(__int64 a, unsigned __int64 b); 
#line 9871
static inline unsigned __int64 min(unsigned __int64 a, __int64 b); 
#line 9873
static inline float min(float a, float b); 
#line 9875
static inline double min(double a, double b); 
#line 9877
static inline double min(float a, double b); 
#line 9879
static inline double min(double a, float b); 
#line 9881
static inline unsigned max(unsigned a, unsigned b); 
#line 9883
static inline unsigned max(int a, unsigned b); 
#line 9885
static inline unsigned max(unsigned a, int b); 
#line 9887
static inline long max(long a, long b); 
#line 9889
static inline unsigned long max(unsigned long a, unsigned long b); 
#line 9891
static inline unsigned long max(long a, unsigned long b); 
#line 9893
static inline unsigned long max(unsigned long a, long b); 
#line 9895
static inline __int64 max(__int64 a, __int64 b); 
#line 9897
static inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b); 
#line 9899
static inline unsigned __int64 max(__int64 a, unsigned __int64 b); 
#line 9901
static inline unsigned __int64 max(unsigned __int64 a, __int64 b); 
#line 9903
static inline float max(float a, float b); 
#line 9905
static inline double max(double a, double b); 
#line 9907
static inline double max(float a, double b); 
#line 9909
static inline double max(double a, float b); 
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isinf(long double a) 
#line 388
{ 
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isinf< long double> (a); 
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isinf(double a) 
#line 404
{ 
#line 408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isinf< double> (a); 
#line 410 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isinf(float a) 
#line 420
{ 
#line 424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isinf< float> (a); 
#line 426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isnan(long double a) 
#line 436
{ 
#line 440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isnan< long double> (a); 
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isnan(double a) 
#line 452
{ 
#line 456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isnan< double> (a); 
#line 458 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 467 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isnan(float a) 
#line 468
{ 
#line 472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isnan< float> (a); 
#line 474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(long double a) 
#line 484
{ 
#line 488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isfinite< long double> (a); 
#line 490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(double a) 
#line 500
{ 
#line 504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isfinite< double> (a); 
#line 506 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 515 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(float a) 
#line 516
{ 
#line 520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return isfinite< float> (a); 
#line 522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
} 
#line 730 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static inline float exp10(float a) 
#line 731
{ 
#line 732
return exp10f(a); 
#line 733
} 
#line 735
static inline float rsqrt(float a) 
#line 736
{ 
#line 737
return rsqrtf(a); 
#line 738
} 
#line 740
static inline float rcbrt(float a) 
#line 741
{ 
#line 742
return rcbrtf(a); 
#line 743
} 
#line 745
static inline float sinpi(float a) 
#line 746
{ 
#line 747
return sinpif(a); 
#line 748
} 
#line 750
static inline float cospi(float a) 
#line 751
{ 
#line 752
return cospif(a); 
#line 753
} 
#line 755
static inline void sincospi(float a, float *sptr, float *cptr) 
#line 756
{ 
#line 757
sincospif(a, sptr, cptr); 
#line 758
} 
#line 760
static inline void sincos(float a, float *sptr, float *cptr) 
#line 761
{ 
#line 762
sincosf(a, sptr, cptr); 
#line 763
} 
#line 765
static inline float j0(float a) 
#line 766
{ 
#line 767
return j0f(a); 
#line 768
} 
#line 770
static inline float j1(float a) 
#line 771
{ 
#line 772
return j1f(a); 
#line 773
} 
#line 775
static inline float jn(int n, float a) 
#line 776
{ 
#line 777
return jnf(n, a); 
#line 778
} 
#line 780
static inline float y0(float a) 
#line 781
{ 
#line 782
return y0f(a); 
#line 783
} 
#line 785
static inline float y1(float a) 
#line 786
{ 
#line 787
return y1f(a); 
#line 788
} 
#line 790
static inline float yn(int n, float a) 
#line 791
{ 
#line 792
return ynf(n, a); 
#line 793
} 
#line 795
static inline float cyl_bessel_i0(float a) 
#line 796
{ 
#line 797
return cyl_bessel_i0f(a); 
#line 798
} 
#line 800
static inline float cyl_bessel_i1(float a) 
#line 801
{ 
#line 802
return cyl_bessel_i1f(a); 
#line 803
} 
#line 805
static inline float erfinv(float a) 
#line 806
{ 
#line 807
return erfinvf(a); 
#line 808
} 
#line 810
static inline float erfcinv(float a) 
#line 811
{ 
#line 812
return erfcinvf(a); 
#line 813
} 
#line 815
static inline float normcdfinv(float a) 
#line 816
{ 
#line 817
return normcdfinvf(a); 
#line 818
} 
#line 820
static inline float normcdf(float a) 
#line 821
{ 
#line 822
return normcdff(a); 
#line 823
} 
#line 825
static inline float erfcx(float a) 
#line 826
{ 
#line 827
return erfcxf(a); 
#line 828
} 
#line 830
static inline double copysign(double a, float b) 
#line 831
{ 
#line 832
return copysign(a, (double)b); 
#line 833
} 
#line 835
static inline double copysign(float a, double b) 
#line 836
{ 
#line 837
return copysign((double)a, b); 
#line 838
} 
#line 840
static inline unsigned min(unsigned a, unsigned b) 
#line 841
{ 
#line 842
return umin(a, b); 
#line 843
} 
#line 845
static inline unsigned min(int a, unsigned b) 
#line 846
{ 
#line 847
return umin((unsigned)a, b); 
#line 848
} 
#line 850
static inline unsigned min(unsigned a, int b) 
#line 851
{ 
#line 852
return umin(a, (unsigned)b); 
#line 853
} 
#line 855
static inline long min(long a, long b) 
#line 856
{ 
#line 859
#pragma warning (disable: 4127)
#line 862 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 864
#pragma warning (default: 4127)
#line 866 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (long)min((int)a, (int)b); 
#line 867
} else { 
#line 868
return (long)llmin((__int64)a, (__int64)b); 
#line 869
}  
#line 870
} 
#line 872
static inline unsigned long min(unsigned long a, unsigned long b) 
#line 873
{ 
#line 875
#pragma warning (disable: 4127)
#line 877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 879
#pragma warning (default: 4127)
#line 881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 882
} else { 
#line 883
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 884
}  
#line 885
} 
#line 887
static inline unsigned long min(long a, unsigned long b) 
#line 888
{ 
#line 890
#pragma warning (disable: 4127)
#line 892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 894
#pragma warning (default: 4127)
#line 896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 897
} else { 
#line 898
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 899
}  
#line 900
} 
#line 902
static inline unsigned long min(unsigned long a, long b) 
#line 903
{ 
#line 905
#pragma warning (disable: 4127)
#line 907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 909
#pragma warning (default: 4127)
#line 911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 912
} else { 
#line 913
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 914
}  
#line 915
} 
#line 917
static inline __int64 min(__int64 a, __int64 b) 
#line 918
{ 
#line 919
return llmin(a, b); 
#line 920
} 
#line 922
static inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b) 
#line 923
{ 
#line 924
return ullmin(a, b); 
#line 925
} 
#line 927
static inline unsigned __int64 min(__int64 a, unsigned __int64 b) 
#line 928
{ 
#line 929
return ullmin((unsigned __int64)a, b); 
#line 930
} 
#line 932
static inline unsigned __int64 min(unsigned __int64 a, __int64 b) 
#line 933
{ 
#line 934
return ullmin(a, (unsigned __int64)b); 
#line 935
} 
#line 937
static inline float min(float a, float b) 
#line 938
{ 
#line 939
return fminf(a, b); 
#line 940
} 
#line 942
static inline double min(double a, double b) 
#line 943
{ 
#line 944
return fmin(a, b); 
#line 945
} 
#line 947
static inline double min(float a, double b) 
#line 948
{ 
#line 949
return fmin((double)a, b); 
#line 950
} 
#line 952
static inline double min(double a, float b) 
#line 953
{ 
#line 954
return fmin(a, (double)b); 
#line 955
} 
#line 957
static inline unsigned max(unsigned a, unsigned b) 
#line 958
{ 
#line 959
return umax(a, b); 
#line 960
} 
#line 962
static inline unsigned max(int a, unsigned b) 
#line 963
{ 
#line 964
return umax((unsigned)a, b); 
#line 965
} 
#line 967
static inline unsigned max(unsigned a, int b) 
#line 968
{ 
#line 969
return umax(a, (unsigned)b); 
#line 970
} 
#line 972
static inline long max(long a, long b) 
#line 973
{ 
#line 976
#pragma warning (disable: 4127)
#line 978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 980
#pragma warning (default: 4127)
#line 982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (long)max((int)a, (int)b); 
#line 983
} else { 
#line 984
return (long)llmax((__int64)a, (__int64)b); 
#line 985
}  
#line 986
} 
#line 988
static inline unsigned long max(unsigned long a, unsigned long b) 
#line 989
{ 
#line 991
#pragma warning (disable: 4127)
#line 993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 995
#pragma warning (default: 4127)
#line 997 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 998
} else { 
#line 999
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 1000
}  
#line 1001
} 
#line 1003
static inline unsigned long max(long a, unsigned long b) 
#line 1004
{ 
#line 1006
#pragma warning (disable: 4127)
#line 1008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1010
#pragma warning (default: 4127)
#line 1012 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 1013
} else { 
#line 1014
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 1015
}  
#line 1016
} 
#line 1018
static inline unsigned long max(unsigned long a, long b) 
#line 1019
{ 
#line 1021
#pragma warning (disable: 4127)
#line 1023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1025
#pragma warning (default: 4127)
#line 1027 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 1028
} else { 
#line 1029
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 1030
}  
#line 1031
} 
#line 1033
static inline __int64 max(__int64 a, __int64 b) 
#line 1034
{ 
#line 1035
return llmax(a, b); 
#line 1036
} 
#line 1038
static inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b) 
#line 1039
{ 
#line 1040
return ullmax(a, b); 
#line 1041
} 
#line 1043
static inline unsigned __int64 max(__int64 a, unsigned __int64 b) 
#line 1044
{ 
#line 1045
return ullmax((unsigned __int64)a, b); 
#line 1046
} 
#line 1048
static inline unsigned __int64 max(unsigned __int64 a, __int64 b) 
#line 1049
{ 
#line 1050
return ullmax(a, (unsigned __int64)b); 
#line 1051
} 
#line 1053
static inline float max(float a, float b) 
#line 1054
{ 
#line 1055
return fmaxf(a, b); 
#line 1056
} 
#line 1058
static inline double max(double a, double b) 
#line 1059
{ 
#line 1060
return fmax(a, b); 
#line 1061
} 
#line 1063
static inline double max(float a, double b) 
#line 1064
{ 
#line 1065
return fmax((double)a, b); 
#line 1066
} 
#line 1068
static inline double max(double a, float b) 
#line 1069
{ 
#line 1070
return fmax(a, (double)b); 
#line 1071
} 
#line 1077
#pragma warning(disable : 4211)
#line 1082 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\math_functions.hpp"
static inline int min(int a, int b) 
#line 1083
{ 
#line 1084
return (a < b) ? a : b; 
#line 1085
} 
#line 1087
static inline unsigned umin(unsigned a, unsigned b) 
#line 1088
{ 
#line 1089
return (a < b) ? a : b; 
#line 1090
} 
#line 1092
static inline __int64 llmin(__int64 a, __int64 b) 
#line 1093
{ 
#line 1094
return (a < b) ? a : b; 
#line 1095
} 
#line 1097
static inline unsigned __int64 ullmin(unsigned __int64 a, unsigned __int64 
#line 1098
b) 
#line 1099
{ 
#line 1100
return (a < b) ? a : b; 
#line 1101
} 
#line 1103
static inline int max(int a, int b) 
#line 1104
{ 
#line 1105
return (a > b) ? a : b; 
#line 1106
} 
#line 1108
static inline unsigned umax(unsigned a, unsigned b) 
#line 1109
{ 
#line 1110
return (a > b) ? a : b; 
#line 1111
} 
#line 1113
static inline __int64 llmax(__int64 a, __int64 b) 
#line 1114
{ 
#line 1115
return (a > b) ? a : b; 
#line 1116
} 
#line 1118
static inline unsigned __int64 ullmax(unsigned __int64 a, unsigned __int64 
#line 1119
b) 
#line 1120
{ 
#line 1121
return (a > b) ? a : b; 
#line 1122
} 
#line 1125
#pragma warning(default: 4211)
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_surface_types.h"
template< class T, int dim = 1> 
#line 78
struct surface : public surfaceReference { 
#line 81
surface() 
#line 82
{ 
#line 83
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 84
} 
#line 86
surface(::cudaChannelFormatDesc desc) 
#line 87
{ 
#line 88
(channelDesc) = desc; 
#line 89
} 
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_surface_types.h"
}; 
#line 93
template< int dim> 
#line 94
struct surface< void, dim>  : public surfaceReference { 
#line 97
surface() 
#line 98
{ 
#line 99
(channelDesc) = cudaCreateChannelDesc< void> (); 
#line 100
} 
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_surface_types.h"
}; 
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
#line 78
struct texture : public textureReference { 
#line 81
texture(int norm = 0, ::cudaTextureFilterMode 
#line 82
fMode = cudaFilterModePoint, ::cudaTextureAddressMode 
#line 83
aMode = cudaAddressModeClamp) 
#line 84
{ 
#line 85
(normalized) = norm; 
#line 86
(filterMode) = fMode; 
#line 87
((addressMode)[0]) = aMode; 
#line 88
((addressMode)[1]) = aMode; 
#line 89
((addressMode)[2]) = aMode; 
#line 90
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 91
(sRGB) = 0; 
#line 92
} 
#line 94
texture(int norm, ::cudaTextureFilterMode 
#line 95
fMode, ::cudaTextureAddressMode 
#line 96
aMode, ::cudaChannelFormatDesc 
#line 97
desc) 
#line 98
{ 
#line 99
(normalized) = norm; 
#line 100
(filterMode) = fMode; 
#line 101
((addressMode)[0]) = aMode; 
#line 102
((addressMode)[1]) = aMode; 
#line 103
((addressMode)[2]) = aMode; 
#line 104
(channelDesc) = desc; 
#line 105
(sRGB) = 0; 
#line 106
} 
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\cuda_texture_types.h"
}; 
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt/device_functions.h"
extern "C" {
#line 3201
}
#line 3209
static __inline int mulhi(int a, int b); 
#line 3211
static __inline unsigned mulhi(unsigned a, unsigned b); 
#line 3213
static __inline unsigned mulhi(int a, unsigned b); 
#line 3215
static __inline unsigned mulhi(unsigned a, int b); 
#line 3217
static __inline __int64 mul64hi(__int64 a, __int64 b); 
#line 3219
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b); 
#line 3221
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b); 
#line 3223
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b); 
#line 3225
static __inline int float_as_int(float a); 
#line 3227
static __inline float int_as_float(int a); 
#line 3229
static __inline unsigned float_as_uint(float a); 
#line 3231
static __inline float uint_as_float(unsigned a); 
#line 3233
static __inline float saturate(float a); 
#line 3235
static __inline int mul24(int a, int b); 
#line 3237
static __inline unsigned umul24(unsigned a, unsigned b); 
#line 3239
static __inline int float2int(float a, cudaRoundMode mode = cudaRoundZero); 
#line 3241
static __inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero); 
#line 3243
static __inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 3245
static __inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 80 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline int mulhi(int a, int b) 
#line 81
{int volatile ___ = 1;(void)a;(void)b;
#line 83
::exit(___);}
#if 0
#line 81
{ 
#line 82
return __mulhi(a, b); 
#line 83
} 
#endif
#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(unsigned a, unsigned b) 
#line 86
{int volatile ___ = 1;(void)a;(void)b;
#line 88
::exit(___);}
#if 0
#line 86
{ 
#line 87
return __umulhi(a, b); 
#line 88
} 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(int a, unsigned b) 
#line 91
{int volatile ___ = 1;(void)a;(void)b;
#line 93
::exit(___);}
#if 0
#line 91
{ 
#line 92
return __umulhi((unsigned)a, b); 
#line 93
} 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(unsigned a, int b) 
#line 96
{int volatile ___ = 1;(void)a;(void)b;
#line 98
::exit(___);}
#if 0
#line 96
{ 
#line 97
return __umulhi(a, (unsigned)b); 
#line 98
} 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline __int64 mul64hi(__int64 a, __int64 b) 
#line 101
{int volatile ___ = 1;(void)a;(void)b;
#line 103
::exit(___);}
#if 0
#line 101
{ 
#line 102
return __mul64hi(a, b); 
#line 103
} 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b) 
#line 106
{int volatile ___ = 1;(void)a;(void)b;
#line 108
::exit(___);}
#if 0
#line 106
{ 
#line 107
return __umul64hi(a, b); 
#line 108
} 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b) 
#line 111
{int volatile ___ = 1;(void)a;(void)b;
#line 113
::exit(___);}
#if 0
#line 111
{ 
#line 112
return __umul64hi((unsigned __int64)a, b); 
#line 113
} 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b) 
#line 116
{int volatile ___ = 1;(void)a;(void)b;
#line 118
::exit(___);}
#if 0
#line 116
{ 
#line 117
return __umul64hi(a, (unsigned __int64)b); 
#line 118
} 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline int float_as_int(float a) 
#line 121
{int volatile ___ = 1;(void)a;
#line 123
::exit(___);}
#if 0
#line 121
{ 
#line 122
return __float_as_int(a); 
#line 123
} 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline float int_as_float(int a) 
#line 126
{int volatile ___ = 1;(void)a;
#line 128
::exit(___);}
#if 0
#line 126
{ 
#line 127
return __int_as_float(a); 
#line 128
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned float_as_uint(float a) 
#line 131
{int volatile ___ = 1;(void)a;
#line 133
::exit(___);}
#if 0
#line 131
{ 
#line 132
return __float_as_uint(a); 
#line 133
} 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline float uint_as_float(unsigned a) 
#line 136
{int volatile ___ = 1;(void)a;
#line 138
::exit(___);}
#if 0
#line 136
{ 
#line 137
return __uint_as_float(a); 
#line 138
} 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline float saturate(float a) 
#line 140
{int volatile ___ = 1;(void)a;
#line 142
::exit(___);}
#if 0
#line 140
{ 
#line 141
return __saturatef(a); 
#line 142
} 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline int mul24(int a, int b) 
#line 145
{int volatile ___ = 1;(void)a;(void)b;
#line 147
::exit(___);}
#if 0
#line 145
{ 
#line 146
return __mul24(a, b); 
#line 147
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned umul24(unsigned a, unsigned b) 
#line 150
{int volatile ___ = 1;(void)a;(void)b;
#line 152
::exit(___);}
#if 0
#line 150
{ 
#line 151
return __umul24(a, b); 
#line 152
} 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline int float2int(float a, cudaRoundMode mode) 
#line 155
{int volatile ___ = 1;(void)a;(void)mode;
#line 160
::exit(___);}
#if 0
#line 155
{ 
#line 156
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
#line 160
} 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline unsigned float2uint(float a, cudaRoundMode mode) 
#line 163
{int volatile ___ = 1;(void)a;(void)mode;
#line 168
::exit(___);}
#if 0
#line 163
{ 
#line 164
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
#line 168
} 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline float int2float(int a, cudaRoundMode mode) 
#line 171
{int volatile ___ = 1;(void)a;(void)mode;
#line 176
::exit(___);}
#if 0
#line 171
{ 
#line 172
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_functions.hpp"
static __inline float uint2float(unsigned a, cudaRoundMode mode) 
#line 179
{int volatile ___ = 1;(void)a;(void)mode;
#line 184
::exit(___);}
#if 0
#line 179
{ 
#line 180
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
#line 184
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 121
{ } 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 131
{ } 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
extern "C" {
#line 182
}
#line 191
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
__declspec(deprecated("__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 197
{ } 
#endif
#line 199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_atomic_functions.h"
__declspec(deprecated("__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 199
{ } 
#endif
#line 77 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.h"
extern "C" {
#line 1129
}
#line 1137
static __inline double fma(double a, double b, double c, cudaRoundMode mode); 
#line 1139
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1141
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1143
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1145
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1147
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1149
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1151
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1153
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1155
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1157
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 1159
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 1161
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) 
#line 84
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
#line 89
::exit(___);}
#if 0
#line 84
{ 
#line 85
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 89
} 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double dmul(double a, double b, cudaRoundMode mode) 
#line 92
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 97
::exit(___);}
#if 0
#line 92
{ 
#line 93
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 97
} 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double dadd(double a, double b, cudaRoundMode mode) 
#line 100
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 105
::exit(___);}
#if 0
#line 100
{ 
#line 101
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 105
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double dsub(double a, double b, cudaRoundMode mode) 
#line 108
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 113
::exit(___);}
#if 0
#line 108
{ 
#line 109
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 113
} 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline int double2int(double a, cudaRoundMode mode) 
#line 116
{int volatile ___ = 1;(void)a;(void)mode;
#line 121
::exit(___);}
#if 0
#line 116
{ 
#line 117
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 121
} 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline unsigned double2uint(double a, cudaRoundMode mode) 
#line 124
{int volatile ___ = 1;(void)a;(void)mode;
#line 129
::exit(___);}
#if 0
#line 124
{ 
#line 125
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 129
} 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline __int64 double2ll(double a, cudaRoundMode mode) 
#line 132
{int volatile ___ = 1;(void)a;(void)mode;
#line 137
::exit(___);}
#if 0
#line 132
{ 
#line 133
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 137
} 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode) 
#line 140
{int volatile ___ = 1;(void)a;(void)mode;
#line 145
::exit(___);}
#if 0
#line 140
{ 
#line 141
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 145
} 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double ll2double(__int64 a, cudaRoundMode mode) 
#line 148
{int volatile ___ = 1;(void)a;(void)mode;
#line 153
::exit(___);}
#if 0
#line 148
{ 
#line 149
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 153
} 
#endif
#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode) 
#line 156
{int volatile ___ = 1;(void)a;(void)mode;
#line 161
::exit(___);}
#if 0
#line 156
{ 
#line 157
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 161
} 
#endif
#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double int2double(int a, cudaRoundMode mode) 
#line 164
{int volatile ___ = 1;(void)a;(void)mode;
#line 166
::exit(___);}
#if 0
#line 164
{ 
#line 165
return (double)a; 
#line 166
} 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double uint2double(unsigned a, cudaRoundMode mode) 
#line 169
{int volatile ___ = 1;(void)a;(void)mode;
#line 171
::exit(___);}
#if 0
#line 169
{ 
#line 170
return (double)a; 
#line 171
} 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\device_double_functions.hpp"
static __inline double float2double(float a, cudaRoundMode mode) 
#line 174
{int volatile ___ = 1;(void)a;(void)mode;
#line 176
::exit(___);}
#if 0
#line 174
{ 
#line 175
return (double)a; 
#line 176
} 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMax(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicAnd(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicOr(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicXor(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 304
{ } 
#endif
#line 307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 307
{ } 
#endif
#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 310
{ } 
#endif
#line 313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 313
{ } 
#endif
#line 316 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 316
{ } 
#endif
#line 319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 319
{ } 
#endif
#line 322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 322
{ } 
#endif
#line 325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 325
{ } 
#endif
#line 328 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 328
{ } 
#endif
#line 331 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 331
{ } 
#endif
#line 334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 334
{ } 
#endif
#line 337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 337
{ } 
#endif
#line 340 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 340
{ } 
#endif
#line 343 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 343
{ } 
#endif
#line 346 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 346
{ } 
#endif
#line 349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 349
{ } 
#endif
#line 352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 352
{ } 
#endif
#line 355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 355
{ } 
#endif
#line 358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 358
{ } 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 361
{ } 
#endif
#line 364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 364
{ } 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 367
{ } 
#endif
#line 370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 370
{ } 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 373
{ } 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 376
{ } 
#endif
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 379
{ } 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 382
{ } 
#endif
#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 385
{ } 
#endif
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 388
{ } 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 391
{ } 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 394
{ } 
#endif
#line 397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 397
{ } 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 400
{ } 
#endif
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 403
{ } 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 406
{ } 
#endif
#line 409 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 409
{ } 
#endif
#line 412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 412
{ } 
#endif
#line 415 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 415
{ } 
#endif
#line 418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 418
{ } 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 421
{ } 
#endif
#line 424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 424
{ } 
#endif
#line 427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 427
{ } 
#endif
#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 430
{ } 
#endif
#line 433 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 433
{ } 
#endif
#line 436 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 436
{ } 
#endif
#line 439 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
#line 440
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 440
{ } 
#endif
#line 443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
#line 444
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 444
{ } 
#endif
#line 447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_block(unsigned __int64 *address, unsigned __int64 
#line 448
compare, unsigned __int64 
#line 449
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 449
{ } 
#endif
#line 452 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_system(unsigned __int64 *address, unsigned __int64 
#line 453
compare, unsigned __int64 
#line 454
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 454
{ } 
#endif
#line 457 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 457
{ } 
#endif
#line 460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 460
{ } 
#endif
#line 463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 463
{ } 
#endif
#line 466 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 466
{ } 
#endif
#line 469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 469
{ } 
#endif
#line 472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 472
{ } 
#endif
#line 475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 475
{ } 
#endif
#line 478 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 478
{ } 
#endif
#line 481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 481
{ } 
#endif
#line 484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 484
{ } 
#endif
#line 487 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 487
{ } 
#endif
#line 490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 490
{ } 
#endif
#line 493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 493
{ } 
#endif
#line 496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 496
{ } 
#endif
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 499
{ } 
#endif
#line 502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 502
{ } 
#endif
#line 505 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 505
{ } 
#endif
#line 508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 508
{ } 
#endif
#line 511 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 511
{ } 
#endif
#line 514 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 514
{ } 
#endif
#line 517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 517
{ } 
#endif
#line 520 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 520
{ } 
#endif
#line 523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 523
{ } 
#endif
#line 526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 526
{ } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_20_intrinsics.h"
extern "C" {
#line 1477
}
#line 1484
__declspec(deprecated("__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to" " suppress this warning).")) static __inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1484
{ } 
#endif
#line 1486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_20_intrinsics.h"
static __inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1486
{ } 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1488
{ } 
#endif
#line 1490 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1490
{ } 
#endif
#line 1497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1497
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __fns(unsigned mask, unsigned base, int offset) {int volatile ___ = 1;(void)mask;(void)base;(void)offset;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync(unsigned id) {int volatile ___ = 1;(void)id;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync_count(unsigned id, unsigned cnt) {int volatile ___ = 1;(void)id;(void)cnt;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline void __syncwarp(unsigned mask = 4294967295U) {int volatile ___ = 1;(void)mask;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __all_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __any_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __uni_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __ballot_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __activemask() {int volatile ___ = 1;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_sync(unsigned mask, int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_sync(unsigned mask, float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 157
{ } 
#endif
#line 160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline __int64 __shfl(__int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 160
{ } 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_sync(unsigned mask, __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 161
{ } 
#endif
#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __int64 __shfl(unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 163
{ } 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_sync(unsigned mask, unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline __int64 __shfl_up(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 166
{ } 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_up_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __int64 __shfl_up(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_up_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline __int64 __shfl_down(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_down_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __int64 __shfl_down(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_down_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 176
{ } 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline __int64 __shfl_xor(__int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_xor_sync(unsigned mask, __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __int64 __shfl_xor(unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_xor_sync(unsigned mask, unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_sync(unsigned mask, double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 194
{ } 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_sync(unsigned mask, long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 199
{ } 
#endif
#line 201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 202
{ } 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 205
{ } 
#endif
#line 207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 207
{ } 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 208
{ } 
#endif
#line 210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 210
{ } 
#endif
#line 211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 211
{ } 
#endif
#line 213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 214
{ } 
#endif
#line 216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 217
{ } 
#endif
#line 219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 219
{ } 
#endif
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 220
{ } 
#endif
#line 89 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 121
{ } 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 131
{ } 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 155
{ } 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 157
{ } 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 161
{ } 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 166
{ } 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldca(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 174 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 174
{ } 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldca(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 186
{ } 
#endif
#line 187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 192
{ } 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 197
{ } 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 200
{ } 
#endif
#line 201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 202
{ } 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 203
{ } 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcs(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 205
{ } 
#endif
#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 206
{ } 
#endif
#line 207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 207
{ } 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 208
{ } 
#endif
#line 209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 209
{ } 
#endif
#line 210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 210
{ } 
#endif
#line 211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 211
{ } 
#endif
#line 213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 214
{ } 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 215
{ } 
#endif
#line 216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcs(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 217
{ } 
#endif
#line 218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 218
{ } 
#endif
#line 219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 219
{ } 
#endif
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 220
{ } 
#endif
#line 221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 221
{ } 
#endif
#line 222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 222
{ } 
#endif
#line 223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 223
{ } 
#endif
#line 225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 225
{ } 
#endif
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 226
{ } 
#endif
#line 227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 227
{ } 
#endif
#line 228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 228
{ } 
#endif
#line 229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 229
{ } 
#endif
#line 236 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 236
{ } 
#endif
#line 237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 237
{ } 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 240
{ } 
#endif
#line 241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 241
{ } 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 83
{ } 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 84
{ } 
#endif
#line 85 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 85
{ } 
#endif
#line 86 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 86
{ } 
#endif
#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 87
{ } 
#endif
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 88
{ } 
#endif
#line 89 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, float value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, double value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, int value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, float value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, double value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 117
surf1Dread(T *res, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 118
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
#line 122
::exit(___);}
#if 0
#line 118
{ 
#line 122
} 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 125
surf1Dread(::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 126
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 132
::exit(___);}
#if 0
#line 126
{ 
#line 132
} 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 135
surf1Dread(T *res, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 136
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
#line 140
::exit(___);}
#if 0
#line 136
{ 
#line 140
} 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 144
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 145
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 149
::exit(___);}
#if 0
#line 145
{ 
#line 149
} 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 152
surf2Dread(::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 153
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 159
::exit(___);}
#if 0
#line 153
{ 
#line 159
} 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 162
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 163
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
#line 167
::exit(___);}
#if 0
#line 163
{ 
#line 167
} 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 171
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 172
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 176
::exit(___);}
#if 0
#line 172
{ 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 179
surf3Dread(::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 180
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 186
::exit(___);}
#if 0
#line 180
{ 
#line 186
} 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 189
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 194
::exit(___);}
#if 0
#line 190
{ 
#line 194
} 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 199
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 200
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 204
::exit(___);}
#if 0
#line 200
{ 
#line 204
} 
#endif
#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 207
surf1DLayeredread(::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 208
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 214
::exit(___);}
#if 0
#line 208
{ 
#line 214
} 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 218
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 219
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
#line 223
::exit(___);}
#if 0
#line 219
{ 
#line 223
} 
#endif
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 227
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 228
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 232
::exit(___);}
#if 0
#line 228
{ 
#line 232
} 
#endif
#line 234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 235
surf2DLayeredread(::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 236
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 242
::exit(___);}
#if 0
#line 236
{ 
#line 242
} 
#endif
#line 245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 246
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 247
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 251
::exit(___);}
#if 0
#line 247
{ 
#line 251
} 
#endif
#line 254 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 255
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 256
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 260
::exit(___);}
#if 0
#line 256
{ 
#line 260
} 
#endif
#line 262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 263
surfCubemapread(::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 264
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 271
::exit(___);}
#if 0
#line 264
{ 
#line 271
} 
#endif
#line 273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 274
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 275
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 279
::exit(___);}
#if 0
#line 275
{ 
#line 279
} 
#endif
#line 282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 283
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 284
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 288
::exit(___);}
#if 0
#line 284
{ 
#line 288
} 
#endif
#line 290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 291
surfCubemapLayeredread(::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 292
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 298
::exit(___);}
#if 0
#line 292
{ 
#line 298
} 
#endif
#line 300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 301
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 302
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 306
::exit(___);}
#if 0
#line 302
{ 
#line 306
} 
#endif
#line 309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 310
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 311
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
#line 315
::exit(___);}
#if 0
#line 311
{ 
#line 315
} 
#endif
#line 317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 318
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 319
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 323
::exit(___);}
#if 0
#line 319
{ 
#line 323
} 
#endif
#line 327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 328
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 329
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 333
::exit(___);}
#if 0
#line 329
{ 
#line 333
} 
#endif
#line 335 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 336
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 337
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 341
::exit(___);}
#if 0
#line 337
{ 
#line 341
} 
#endif
#line 344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 345
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 346
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 350
::exit(___);}
#if 0
#line 346
{ 
#line 350
} 
#endif
#line 352 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 353
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 354
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 358
::exit(___);}
#if 0
#line 354
{ 
#line 358
} 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 362
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 363
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 367
::exit(___);}
#if 0
#line 363
{ 
#line 367
} 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 370
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 371
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 375
::exit(___);}
#if 0
#line 371
{ 
#line 375
} 
#endif
#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 379
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 380
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 384
::exit(___);}
#if 0
#line 380
{ 
#line 384
} 
#endif
#line 386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 387
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 388
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 392
::exit(___);}
#if 0
#line 388
{ 
#line 392
} 
#endif
#line 395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 396
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 397
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 401
::exit(___);}
#if 0
#line 397
{ 
#line 401
} 
#endif
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 404
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 405
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 409
::exit(___);}
#if 0
#line 405
{ 
#line 409
} 
#endif
#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 414
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 415
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 419
::exit(___);}
#if 0
#line 415
{ 
#line 419
} 
#endif
#line 421 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 422
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 423
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 427
::exit(___);}
#if 0
#line 423
{ 
#line 427
} 
#endif
#line 68 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> 
#line 69
struct __nv_tex_rmet_ret { }; 
#line 71
template<> struct __nv_tex_rmet_ret< char>  { typedef char type; }; 
#line 72
template<> struct __nv_tex_rmet_ret< signed char>  { typedef signed char type; }; 
#line 73
template<> struct __nv_tex_rmet_ret< unsigned char>  { typedef unsigned char type; }; 
#line 74
template<> struct __nv_tex_rmet_ret< char1>  { typedef char1 type; }; 
#line 75
template<> struct __nv_tex_rmet_ret< uchar1>  { typedef uchar1 type; }; 
#line 76
template<> struct __nv_tex_rmet_ret< char2>  { typedef char2 type; }; 
#line 77
template<> struct __nv_tex_rmet_ret< uchar2>  { typedef uchar2 type; }; 
#line 78
template<> struct __nv_tex_rmet_ret< char4>  { typedef char4 type; }; 
#line 79
template<> struct __nv_tex_rmet_ret< uchar4>  { typedef uchar4 type; }; 
#line 81
template<> struct __nv_tex_rmet_ret< short>  { typedef short type; }; 
#line 82
template<> struct __nv_tex_rmet_ret< unsigned short>  { typedef unsigned short type; }; 
#line 83
template<> struct __nv_tex_rmet_ret< short1>  { typedef short1 type; }; 
#line 84
template<> struct __nv_tex_rmet_ret< ushort1>  { typedef ushort1 type; }; 
#line 85
template<> struct __nv_tex_rmet_ret< short2>  { typedef short2 type; }; 
#line 86
template<> struct __nv_tex_rmet_ret< ushort2>  { typedef ushort2 type; }; 
#line 87
template<> struct __nv_tex_rmet_ret< short4>  { typedef short4 type; }; 
#line 88
template<> struct __nv_tex_rmet_ret< ushort4>  { typedef ushort4 type; }; 
#line 90
template<> struct __nv_tex_rmet_ret< int>  { typedef int type; }; 
#line 91
template<> struct __nv_tex_rmet_ret< unsigned>  { typedef unsigned type; }; 
#line 92
template<> struct __nv_tex_rmet_ret< int1>  { typedef int1 type; }; 
#line 93
template<> struct __nv_tex_rmet_ret< uint1>  { typedef uint1 type; }; 
#line 94
template<> struct __nv_tex_rmet_ret< int2>  { typedef int2 type; }; 
#line 95
template<> struct __nv_tex_rmet_ret< uint2>  { typedef uint2 type; }; 
#line 96
template<> struct __nv_tex_rmet_ret< int4>  { typedef int4 type; }; 
#line 97
template<> struct __nv_tex_rmet_ret< uint4>  { typedef uint4 type; }; 
#line 100
template<> struct __nv_tex_rmet_ret< long>  { typedef long type; }; 
#line 101
template<> struct __nv_tex_rmet_ret< unsigned long>  { typedef unsigned long type; }; 
#line 102
template<> struct __nv_tex_rmet_ret< long1>  { typedef long1 type; }; 
#line 103
template<> struct __nv_tex_rmet_ret< ulong1>  { typedef ulong1 type; }; 
#line 104
template<> struct __nv_tex_rmet_ret< long2>  { typedef long2 type; }; 
#line 105
template<> struct __nv_tex_rmet_ret< ulong2>  { typedef ulong2 type; }; 
#line 106
template<> struct __nv_tex_rmet_ret< long4>  { typedef long4 type; }; 
#line 107
template<> struct __nv_tex_rmet_ret< ulong4>  { typedef ulong4 type; }; 
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret< float>  { typedef float type; }; 
#line 110
template<> struct __nv_tex_rmet_ret< float1>  { typedef float1 type; }; 
#line 111
template<> struct __nv_tex_rmet_ret< float2>  { typedef float2 type; }; 
#line 112
template<> struct __nv_tex_rmet_ret< float4>  { typedef float4 type; }; 
#line 115
template< class T> struct __nv_tex_rmet_cast { typedef T *type; }; 
#line 117
template<> struct __nv_tex_rmet_cast< long>  { typedef int *type; }; 
#line 118
template<> struct __nv_tex_rmet_cast< unsigned long>  { typedef unsigned *type; }; 
#line 119
template<> struct __nv_tex_rmet_cast< long1>  { typedef int1 *type; }; 
#line 120
template<> struct __nv_tex_rmet_cast< ulong1>  { typedef uint1 *type; }; 
#line 121
template<> struct __nv_tex_rmet_cast< long2>  { typedef int2 *type; }; 
#line 122
template<> struct __nv_tex_rmet_cast< ulong2>  { typedef uint2 *type; }; 
#line 123
template<> struct __nv_tex_rmet_cast< long4>  { typedef int4 *type; }; 
#line 124
template<> struct __nv_tex_rmet_cast< ulong4>  { typedef uint4 *type; }; 
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 128
tex1Dfetch(texture< T, 1, cudaReadModeElementType>  t, int x) 
#line 129
{int volatile ___ = 1;(void)t;(void)x;
#line 135
::exit(___);}
#if 0
#line 129
{ 
#line 135
} 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> 
#line 138
struct __nv_tex_rmnf_ret { }; 
#line 140
template<> struct __nv_tex_rmnf_ret< char>  { typedef float type; }; 
#line 141
template<> struct __nv_tex_rmnf_ret< signed char>  { typedef float type; }; 
#line 142
template<> struct __nv_tex_rmnf_ret< unsigned char>  { typedef float type; }; 
#line 143
template<> struct __nv_tex_rmnf_ret< short>  { typedef float type; }; 
#line 144
template<> struct __nv_tex_rmnf_ret< unsigned short>  { typedef float type; }; 
#line 145
template<> struct __nv_tex_rmnf_ret< char1>  { typedef float1 type; }; 
#line 146
template<> struct __nv_tex_rmnf_ret< uchar1>  { typedef float1 type; }; 
#line 147
template<> struct __nv_tex_rmnf_ret< short1>  { typedef float1 type; }; 
#line 148
template<> struct __nv_tex_rmnf_ret< ushort1>  { typedef float1 type; }; 
#line 149
template<> struct __nv_tex_rmnf_ret< char2>  { typedef float2 type; }; 
#line 150
template<> struct __nv_tex_rmnf_ret< uchar2>  { typedef float2 type; }; 
#line 151
template<> struct __nv_tex_rmnf_ret< short2>  { typedef float2 type; }; 
#line 152
template<> struct __nv_tex_rmnf_ret< ushort2>  { typedef float2 type; }; 
#line 153
template<> struct __nv_tex_rmnf_ret< char4>  { typedef float4 type; }; 
#line 154
template<> struct __nv_tex_rmnf_ret< uchar4>  { typedef float4 type; }; 
#line 155
template<> struct __nv_tex_rmnf_ret< short4>  { typedef float4 type; }; 
#line 156
template<> struct __nv_tex_rmnf_ret< ushort4>  { typedef float4 type; }; 
#line 158
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 159
tex1Dfetch(texture< T, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 160
{int volatile ___ = 1;(void)t;(void)x;
#line 167
::exit(___);}
#if 0
#line 160
{ 
#line 167
} 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 171
tex1D(texture< T, 1, cudaReadModeElementType>  t, float x) 
#line 172
{int volatile ___ = 1;(void)t;(void)x;
#line 178
::exit(___);}
#if 0
#line 172
{ 
#line 178
} 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 181
tex1D(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 182
{int volatile ___ = 1;(void)t;(void)x;
#line 189
::exit(___);}
#if 0
#line 182
{ 
#line 189
} 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 194
tex2D(texture< T, 2, cudaReadModeElementType>  t, float x, float y) 
#line 195
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 202
::exit(___);}
#if 0
#line 195
{ 
#line 202
} 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 205
tex2D(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 206
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 213
::exit(___);}
#if 0
#line 206
{ 
#line 213
} 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 218
tex1DLayered(texture< T, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 219
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 225
::exit(___);}
#if 0
#line 219
{ 
#line 225
} 
#endif
#line 227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 228
tex1DLayered(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 229
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 236
::exit(___);}
#if 0
#line 229
{ 
#line 236
} 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 241
tex2DLayered(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 242
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 248
::exit(___);}
#if 0
#line 242
{ 
#line 248
} 
#endif
#line 250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 251
tex2DLayered(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 252
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 259
::exit(___);}
#if 0
#line 252
{ 
#line 259
} 
#endif
#line 262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 263
tex3D(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 264
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 270
::exit(___);}
#if 0
#line 264
{ 
#line 270
} 
#endif
#line 272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 273
tex3D(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 274
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 281
::exit(___);}
#if 0
#line 274
{ 
#line 281
} 
#endif
#line 284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 285
texCubemap(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 292
::exit(___);}
#if 0
#line 286
{ 
#line 292
} 
#endif
#line 294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 295
texCubemap(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 296
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 303
::exit(___);}
#if 0
#line 296
{ 
#line 303
} 
#endif
#line 306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> 
#line 307
struct __nv_tex2dgather_ret { }; 
#line 308
template<> struct __nv_tex2dgather_ret< char>  { typedef char4 type; }; 
#line 309
template<> struct __nv_tex2dgather_ret< signed char>  { typedef char4 type; }; 
#line 310
template<> struct __nv_tex2dgather_ret< char1>  { typedef char4 type; }; 
#line 311
template<> struct __nv_tex2dgather_ret< char2>  { typedef char4 type; }; 
#line 312
template<> struct __nv_tex2dgather_ret< char3>  { typedef char4 type; }; 
#line 313
template<> struct __nv_tex2dgather_ret< char4>  { typedef char4 type; }; 
#line 314
template<> struct __nv_tex2dgather_ret< unsigned char>  { typedef uchar4 type; }; 
#line 315
template<> struct __nv_tex2dgather_ret< uchar1>  { typedef uchar4 type; }; 
#line 316
template<> struct __nv_tex2dgather_ret< uchar2>  { typedef uchar4 type; }; 
#line 317
template<> struct __nv_tex2dgather_ret< uchar3>  { typedef uchar4 type; }; 
#line 318
template<> struct __nv_tex2dgather_ret< uchar4>  { typedef uchar4 type; }; 
#line 320
template<> struct __nv_tex2dgather_ret< short>  { typedef short4 type; }; 
#line 321
template<> struct __nv_tex2dgather_ret< short1>  { typedef short4 type; }; 
#line 322
template<> struct __nv_tex2dgather_ret< short2>  { typedef short4 type; }; 
#line 323
template<> struct __nv_tex2dgather_ret< short3>  { typedef short4 type; }; 
#line 324
template<> struct __nv_tex2dgather_ret< short4>  { typedef short4 type; }; 
#line 325
template<> struct __nv_tex2dgather_ret< unsigned short>  { typedef ushort4 type; }; 
#line 326
template<> struct __nv_tex2dgather_ret< ushort1>  { typedef ushort4 type; }; 
#line 327
template<> struct __nv_tex2dgather_ret< ushort2>  { typedef ushort4 type; }; 
#line 328
template<> struct __nv_tex2dgather_ret< ushort3>  { typedef ushort4 type; }; 
#line 329
template<> struct __nv_tex2dgather_ret< ushort4>  { typedef ushort4 type; }; 
#line 331
template<> struct __nv_tex2dgather_ret< int>  { typedef int4 type; }; 
#line 332
template<> struct __nv_tex2dgather_ret< int1>  { typedef int4 type; }; 
#line 333
template<> struct __nv_tex2dgather_ret< int2>  { typedef int4 type; }; 
#line 334
template<> struct __nv_tex2dgather_ret< int3>  { typedef int4 type; }; 
#line 335
template<> struct __nv_tex2dgather_ret< int4>  { typedef int4 type; }; 
#line 336
template<> struct __nv_tex2dgather_ret< unsigned>  { typedef uint4 type; }; 
#line 337
template<> struct __nv_tex2dgather_ret< uint1>  { typedef uint4 type; }; 
#line 338
template<> struct __nv_tex2dgather_ret< uint2>  { typedef uint4 type; }; 
#line 339
template<> struct __nv_tex2dgather_ret< uint3>  { typedef uint4 type; }; 
#line 340
template<> struct __nv_tex2dgather_ret< uint4>  { typedef uint4 type; }; 
#line 342
template<> struct __nv_tex2dgather_ret< float>  { typedef float4 type; }; 
#line 343
template<> struct __nv_tex2dgather_ret< float1>  { typedef float4 type; }; 
#line 344
template<> struct __nv_tex2dgather_ret< float2>  { typedef float4 type; }; 
#line 345
template<> struct __nv_tex2dgather_ret< float3>  { typedef float4 type; }; 
#line 346
template<> struct __nv_tex2dgather_ret< float4>  { typedef float4 type; }; 
#line 348
template< class T> static __forceinline typename __nv_tex2dgather_ret< T> ::type 
#line 349
tex2Dgather(texture< T, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
#line 350
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 357
::exit(___);}
#if 0
#line 350
{ 
#line 357
} 
#endif
#line 360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> struct __nv_tex2dgather_rmnf_ret { }; 
#line 361
template<> struct __nv_tex2dgather_rmnf_ret< char>  { typedef float4 type; }; 
#line 362
template<> struct __nv_tex2dgather_rmnf_ret< signed char>  { typedef float4 type; }; 
#line 363
template<> struct __nv_tex2dgather_rmnf_ret< unsigned char>  { typedef float4 type; }; 
#line 364
template<> struct __nv_tex2dgather_rmnf_ret< char1>  { typedef float4 type; }; 
#line 365
template<> struct __nv_tex2dgather_rmnf_ret< uchar1>  { typedef float4 type; }; 
#line 366
template<> struct __nv_tex2dgather_rmnf_ret< char2>  { typedef float4 type; }; 
#line 367
template<> struct __nv_tex2dgather_rmnf_ret< uchar2>  { typedef float4 type; }; 
#line 368
template<> struct __nv_tex2dgather_rmnf_ret< char3>  { typedef float4 type; }; 
#line 369
template<> struct __nv_tex2dgather_rmnf_ret< uchar3>  { typedef float4 type; }; 
#line 370
template<> struct __nv_tex2dgather_rmnf_ret< char4>  { typedef float4 type; }; 
#line 371
template<> struct __nv_tex2dgather_rmnf_ret< uchar4>  { typedef float4 type; }; 
#line 372
template<> struct __nv_tex2dgather_rmnf_ret< signed short>  { typedef float4 type; }; 
#line 373
template<> struct __nv_tex2dgather_rmnf_ret< unsigned short>  { typedef float4 type; }; 
#line 374
template<> struct __nv_tex2dgather_rmnf_ret< short1>  { typedef float4 type; }; 
#line 375
template<> struct __nv_tex2dgather_rmnf_ret< ushort1>  { typedef float4 type; }; 
#line 376
template<> struct __nv_tex2dgather_rmnf_ret< short2>  { typedef float4 type; }; 
#line 377
template<> struct __nv_tex2dgather_rmnf_ret< ushort2>  { typedef float4 type; }; 
#line 378
template<> struct __nv_tex2dgather_rmnf_ret< short3>  { typedef float4 type; }; 
#line 379
template<> struct __nv_tex2dgather_rmnf_ret< ushort3>  { typedef float4 type; }; 
#line 380
template<> struct __nv_tex2dgather_rmnf_ret< short4>  { typedef float4 type; }; 
#line 381
template<> struct __nv_tex2dgather_rmnf_ret< ushort4>  { typedef float4 type; }; 
#line 383
template< class T> static __forceinline typename __nv_tex2dgather_rmnf_ret< T> ::type 
#line 384
tex2Dgather(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
#line 385
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 392
::exit(___);}
#if 0
#line 385
{ 
#line 392
} 
#endif
#line 396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 397
tex1DLod(texture< T, 1, cudaReadModeElementType>  t, float x, float level) 
#line 398
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 404
::exit(___);}
#if 0
#line 398
{ 
#line 404
} 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 407
tex1DLod(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 408
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 415
::exit(___);}
#if 0
#line 408
{ 
#line 415
} 
#endif
#line 418 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 419
tex2DLod(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 420
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 426
::exit(___);}
#if 0
#line 420
{ 
#line 426
} 
#endif
#line 428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 429
tex2DLod(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 430
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 437
::exit(___);}
#if 0
#line 430
{ 
#line 437
} 
#endif
#line 440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 441
tex1DLayeredLod(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 442
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 448
::exit(___);}
#if 0
#line 442
{ 
#line 448
} 
#endif
#line 450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 451
tex1DLayeredLod(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 452
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 459
::exit(___);}
#if 0
#line 452
{ 
#line 459
} 
#endif
#line 462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 463
tex2DLayeredLod(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 464
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 470
::exit(___);}
#if 0
#line 464
{ 
#line 470
} 
#endif
#line 472 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 473
tex2DLayeredLod(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 474
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 481
::exit(___);}
#if 0
#line 474
{ 
#line 481
} 
#endif
#line 484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 485
tex3DLod(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 486
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 492
::exit(___);}
#if 0
#line 486
{ 
#line 492
} 
#endif
#line 494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 495
tex3DLod(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 503
::exit(___);}
#if 0
#line 496
{ 
#line 503
} 
#endif
#line 506 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 507
texCubemapLod(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 508
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 514
::exit(___);}
#if 0
#line 508
{ 
#line 514
} 
#endif
#line 516 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 517
texCubemapLod(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 518
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 525
::exit(___);}
#if 0
#line 518
{ 
#line 525
} 
#endif
#line 529 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 530
texCubemapLayered(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 537
::exit(___);}
#if 0
#line 531
{ 
#line 537
} 
#endif
#line 539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 540
texCubemapLayered(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 541
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 548
::exit(___);}
#if 0
#line 541
{ 
#line 548
} 
#endif
#line 552 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 553
texCubemapLayeredLod(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 554
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 560
::exit(___);}
#if 0
#line 554
{ 
#line 560
} 
#endif
#line 562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 563
texCubemapLayeredLod(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 564
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 571
::exit(___);}
#if 0
#line 564
{ 
#line 571
} 
#endif
#line 575 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 576
texCubemapGrad(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 577
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 583
::exit(___);}
#if 0
#line 577
{ 
#line 583
} 
#endif
#line 585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 586
texCubemapGrad(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 594
::exit(___);}
#if 0
#line 587
{ 
#line 594
} 
#endif
#line 598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 599
texCubemapLayeredGrad(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) 
#line 600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
#line 606
::exit(___);}
#if 0
#line 600
{ 
#line 606
} 
#endif
#line 608 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 609
texCubemapLayeredGrad(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) 
#line 610
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
#line 617
::exit(___);}
#if 0
#line 610
{ 
#line 617
} 
#endif
#line 621 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 622
tex1DGrad(texture< T, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 623
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 629
::exit(___);}
#if 0
#line 623
{ 
#line 629
} 
#endif
#line 631 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 632
tex1DGrad(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 633
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 640
::exit(___);}
#if 0
#line 633
{ 
#line 640
} 
#endif
#line 644 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 645
tex2DGrad(texture< T, 2, cudaReadModeElementType>  t, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 652
::exit(___);}
#if 0
#line 646
{ 
#line 652
} 
#endif
#line 654 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 655
tex2DGrad(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 656
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 663
::exit(___);}
#if 0
#line 656
{ 
#line 663
} 
#endif
#line 666 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 667
tex1DLayeredGrad(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 668
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 674
::exit(___);}
#if 0
#line 668
{ 
#line 674
} 
#endif
#line 676 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 677
tex1DLayeredGrad(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 678
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 685
::exit(___);}
#if 0
#line 678
{ 
#line 685
} 
#endif
#line 688 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 689
tex2DLayeredGrad(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 690
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 696
::exit(___);}
#if 0
#line 690
{ 
#line 696
} 
#endif
#line 698 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 699
tex2DLayeredGrad(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 700
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 707
::exit(___);}
#if 0
#line 700
{ 
#line 707
} 
#endif
#line 710 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 711
tex3DGrad(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 712
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 718
::exit(___);}
#if 0
#line 712
{ 
#line 718
} 
#endif
#line 720 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 721
tex3DGrad(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 722
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 729
::exit(___);}
#if 0
#line 722
{ 
#line 729
} 
#endif
#line 61 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> struct __nv_itex_trait { }; 
#line 62
template<> struct __nv_itex_trait< char>  { typedef void type; }; 
#line 63
template<> struct __nv_itex_trait< signed char>  { typedef void type; }; 
#line 64
template<> struct __nv_itex_trait< char1>  { typedef void type; }; 
#line 65
template<> struct __nv_itex_trait< char2>  { typedef void type; }; 
#line 66
template<> struct __nv_itex_trait< char4>  { typedef void type; }; 
#line 67
template<> struct __nv_itex_trait< unsigned char>  { typedef void type; }; 
#line 68
template<> struct __nv_itex_trait< uchar1>  { typedef void type; }; 
#line 69
template<> struct __nv_itex_trait< uchar2>  { typedef void type; }; 
#line 70
template<> struct __nv_itex_trait< uchar4>  { typedef void type; }; 
#line 71
template<> struct __nv_itex_trait< short>  { typedef void type; }; 
#line 72
template<> struct __nv_itex_trait< short1>  { typedef void type; }; 
#line 73
template<> struct __nv_itex_trait< short2>  { typedef void type; }; 
#line 74
template<> struct __nv_itex_trait< short4>  { typedef void type; }; 
#line 75
template<> struct __nv_itex_trait< unsigned short>  { typedef void type; }; 
#line 76
template<> struct __nv_itex_trait< ushort1>  { typedef void type; }; 
#line 77
template<> struct __nv_itex_trait< ushort2>  { typedef void type; }; 
#line 78
template<> struct __nv_itex_trait< ushort4>  { typedef void type; }; 
#line 79
template<> struct __nv_itex_trait< int>  { typedef void type; }; 
#line 80
template<> struct __nv_itex_trait< int1>  { typedef void type; }; 
#line 81
template<> struct __nv_itex_trait< int2>  { typedef void type; }; 
#line 82
template<> struct __nv_itex_trait< int4>  { typedef void type; }; 
#line 83
template<> struct __nv_itex_trait< unsigned>  { typedef void type; }; 
#line 84
template<> struct __nv_itex_trait< uint1>  { typedef void type; }; 
#line 85
template<> struct __nv_itex_trait< uint2>  { typedef void type; }; 
#line 86
template<> struct __nv_itex_trait< uint4>  { typedef void type; }; 
#line 88
template<> struct __nv_itex_trait< long>  { typedef void type; }; 
#line 89
template<> struct __nv_itex_trait< long1>  { typedef void type; }; 
#line 90
template<> struct __nv_itex_trait< long2>  { typedef void type; }; 
#line 91
template<> struct __nv_itex_trait< long4>  { typedef void type; }; 
#line 92
template<> struct __nv_itex_trait< unsigned long>  { typedef void type; }; 
#line 93
template<> struct __nv_itex_trait< ulong1>  { typedef void type; }; 
#line 94
template<> struct __nv_itex_trait< ulong2>  { typedef void type; }; 
#line 95
template<> struct __nv_itex_trait< ulong4>  { typedef void type; }; 
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template<> struct __nv_itex_trait< float>  { typedef void type; }; 
#line 98
template<> struct __nv_itex_trait< float1>  { typedef void type; }; 
#line 99
template<> struct __nv_itex_trait< float2>  { typedef void type; }; 
#line 100
template<> struct __nv_itex_trait< float4>  { typedef void type; }; 
#line 104
template< class T> static typename __nv_itex_trait< T> ::type 
#line 105
tex1Dfetch(T *ptr, ::cudaTextureObject_t obj, int x) 
#line 106
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;
#line 110
::exit(___);}
#if 0
#line 106
{ 
#line 110
} 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 113
tex1Dfetch(::cudaTextureObject_t texObject, int x) 
#line 114
{int volatile ___ = 1;(void)texObject;(void)x;
#line 120
::exit(___);}
#if 0
#line 114
{ 
#line 120
} 
#endif
#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 123
tex1D(T *ptr, ::cudaTextureObject_t obj, float x) 
#line 124
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;
#line 128
::exit(___);}
#if 0
#line 124
{ 
#line 128
} 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 132
tex1D(::cudaTextureObject_t texObject, float x) 
#line 133
{int volatile ___ = 1;(void)texObject;(void)x;
#line 139
::exit(___);}
#if 0
#line 133
{ 
#line 139
} 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 143
tex2D(T *ptr, ::cudaTextureObject_t obj, float x, float y) 
#line 144
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;
#line 148
::exit(___);}
#if 0
#line 144
{ 
#line 148
} 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 151
tex2D(::cudaTextureObject_t texObject, float x, float y) 
#line 152
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
#line 158
::exit(___);}
#if 0
#line 152
{ 
#line 158
} 
#endif
#line 160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 161
tex3D(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) 
#line 162
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;
#line 166
::exit(___);}
#if 0
#line 162
{ 
#line 166
} 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 169
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 170
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 176
::exit(___);}
#if 0
#line 170
{ 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 179
tex1DLayered(T *ptr, ::cudaTextureObject_t obj, float x, int layer) 
#line 180
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;
#line 184
::exit(___);}
#if 0
#line 180
{ 
#line 184
} 
#endif
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 187
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) 
#line 188
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
#line 194
::exit(___);}
#if 0
#line 188
{ 
#line 194
} 
#endif
#line 196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 197
tex2DLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer) 
#line 198
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;
#line 202
::exit(___);}
#if 0
#line 198
{ 
#line 202
} 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 205
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) 
#line 206
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
#line 212
::exit(___);}
#if 0
#line 206
{ 
#line 212
} 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 216
texCubemap(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) 
#line 217
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;
#line 221
::exit(___);}
#if 0
#line 217
{ 
#line 221
} 
#endif
#line 224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 225
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 226
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 232
::exit(___);}
#if 0
#line 226
{ 
#line 232
} 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 236
texCubemapLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer) 
#line 237
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;
#line 241
::exit(___);}
#if 0
#line 237
{ 
#line 241
} 
#endif
#line 243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 244
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 245
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 251
::exit(___);}
#if 0
#line 245
{ 
#line 251
} 
#endif
#line 253 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 254
tex2Dgather(T *ptr, ::cudaTextureObject_t obj, float x, float y, int comp = 0) 
#line 255
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)comp;
#line 259
::exit(___);}
#if 0
#line 255
{ 
#line 259
} 
#endif
#line 261 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 262
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) 
#line 263
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
#line 269
::exit(___);}
#if 0
#line 263
{ 
#line 269
} 
#endif
#line 273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 274
tex1DLod(T *ptr, ::cudaTextureObject_t obj, float x, float level) 
#line 275
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)level;
#line 279
::exit(___);}
#if 0
#line 275
{ 
#line 279
} 
#endif
#line 281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 282
tex1DLod(::cudaTextureObject_t texObject, float x, float level) 
#line 283
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
#line 289
::exit(___);}
#if 0
#line 283
{ 
#line 289
} 
#endif
#line 292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 293
tex2DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float level) 
#line 294
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;
#line 298
::exit(___);}
#if 0
#line 294
{ 
#line 298
} 
#endif
#line 300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 301
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) 
#line 302
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
#line 308
::exit(___);}
#if 0
#line 302
{ 
#line 308
} 
#endif
#line 311 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 312
tex3DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) 
#line 313
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;
#line 317
::exit(___);}
#if 0
#line 313
{ 
#line 317
} 
#endif
#line 319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 320
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 321
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 327
::exit(___);}
#if 0
#line 321
{ 
#line 327
} 
#endif
#line 330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 331
tex1DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float level) 
#line 332
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)level;
#line 336
::exit(___);}
#if 0
#line 332
{ 
#line 336
} 
#endif
#line 338 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 339
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) 
#line 340
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
#line 346
::exit(___);}
#if 0
#line 340
{ 
#line 346
} 
#endif
#line 349 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 350
tex2DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, float level) 
#line 351
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;
#line 355
::exit(___);}
#if 0
#line 351
{ 
#line 355
} 
#endif
#line 357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 358
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 359
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 365
::exit(___);}
#if 0
#line 359
{ 
#line 365
} 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 369
texCubemapLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) 
#line 370
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;
#line 374
::exit(___);}
#if 0
#line 370
{ 
#line 374
} 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 377
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 378
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 384
::exit(___);}
#if 0
#line 378
{ 
#line 384
} 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 388
texCubemapGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 389
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 393
::exit(___);}
#if 0
#line 389
{ 
#line 393
} 
#endif
#line 395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 396
texCubemapGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 397
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 403
::exit(___);}
#if 0
#line 397
{ 
#line 403
} 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 406
texCubemapLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, float level) 
#line 407
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 411
::exit(___);}
#if 0
#line 407
{ 
#line 411
} 
#endif
#line 413 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 414
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 415
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 421
::exit(___);}
#if 0
#line 415
{ 
#line 421
} 
#endif
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 424
tex1DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float dPdx, float dPdy) 
#line 425
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)dPdx;(void)dPdy;
#line 429
::exit(___);}
#if 0
#line 425
{ 
#line 429
} 
#endif
#line 431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 432
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 433
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 439
::exit(___);}
#if 0
#line 433
{ 
#line 439
} 
#endif
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 443
tex2DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 444
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 449
::exit(___);}
#if 0
#line 444
{ 
#line 449
} 
#endif
#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 452
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 453
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 459
::exit(___);}
#if 0
#line 453
{ 
#line 459
} 
#endif
#line 462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 463
tex3DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 464
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 468
::exit(___);}
#if 0
#line 464
{ 
#line 468
} 
#endif
#line 470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 471
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 472
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 478
::exit(___);}
#if 0
#line 472
{ 
#line 478
} 
#endif
#line 481 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 482
tex1DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy) 
#line 483
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 487
::exit(___);}
#if 0
#line 483
{ 
#line 487
} 
#endif
#line 489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 490
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 491
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 497
::exit(___);}
#if 0
#line 491
{ 
#line 497
} 
#endif
#line 500 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 501
tex2DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 502
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 506
::exit(___);}
#if 0
#line 502
{ 
#line 506
} 
#endif
#line 508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 509
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 510
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 516
::exit(___);}
#if 0
#line 510
{ 
#line 516
} 
#endif
#line 519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 520
texCubemapLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) 
#line 521
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
#line 525
::exit(___);}
#if 0
#line 521
{ 
#line 525
} 
#endif
#line 527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 528
texCubemapLayeredGrad(::cudaTextureObject_t texObject, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) 
#line 529
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
#line 535
::exit(___);}
#if 0
#line 529
{ 
#line 535
} 
#endif
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> struct __nv_isurf_trait { }; 
#line 61
template<> struct __nv_isurf_trait< char>  { typedef void type; }; 
#line 62
template<> struct __nv_isurf_trait< signed char>  { typedef void type; }; 
#line 63
template<> struct __nv_isurf_trait< char1>  { typedef void type; }; 
#line 64
template<> struct __nv_isurf_trait< unsigned char>  { typedef void type; }; 
#line 65
template<> struct __nv_isurf_trait< uchar1>  { typedef void type; }; 
#line 66
template<> struct __nv_isurf_trait< short>  { typedef void type; }; 
#line 67
template<> struct __nv_isurf_trait< short1>  { typedef void type; }; 
#line 68
template<> struct __nv_isurf_trait< unsigned short>  { typedef void type; }; 
#line 69
template<> struct __nv_isurf_trait< ushort1>  { typedef void type; }; 
#line 70
template<> struct __nv_isurf_trait< int>  { typedef void type; }; 
#line 71
template<> struct __nv_isurf_trait< int1>  { typedef void type; }; 
#line 72
template<> struct __nv_isurf_trait< unsigned>  { typedef void type; }; 
#line 73
template<> struct __nv_isurf_trait< uint1>  { typedef void type; }; 
#line 74
template<> struct __nv_isurf_trait< __int64>  { typedef void type; }; 
#line 75
template<> struct __nv_isurf_trait< longlong1>  { typedef void type; }; 
#line 76
template<> struct __nv_isurf_trait< unsigned __int64>  { typedef void type; }; 
#line 77
template<> struct __nv_isurf_trait< ulonglong1>  { typedef void type; }; 
#line 78
template<> struct __nv_isurf_trait< float>  { typedef void type; }; 
#line 79
template<> struct __nv_isurf_trait< float1>  { typedef void type; }; 
#line 81
template<> struct __nv_isurf_trait< char2>  { typedef void type; }; 
#line 82
template<> struct __nv_isurf_trait< uchar2>  { typedef void type; }; 
#line 83
template<> struct __nv_isurf_trait< short2>  { typedef void type; }; 
#line 84
template<> struct __nv_isurf_trait< ushort2>  { typedef void type; }; 
#line 85
template<> struct __nv_isurf_trait< int2>  { typedef void type; }; 
#line 86
template<> struct __nv_isurf_trait< uint2>  { typedef void type; }; 
#line 87
template<> struct __nv_isurf_trait< longlong2>  { typedef void type; }; 
#line 88
template<> struct __nv_isurf_trait< ulonglong2>  { typedef void type; }; 
#line 89
template<> struct __nv_isurf_trait< float2>  { typedef void type; }; 
#line 91
template<> struct __nv_isurf_trait< char4>  { typedef void type; }; 
#line 92
template<> struct __nv_isurf_trait< uchar4>  { typedef void type; }; 
#line 93
template<> struct __nv_isurf_trait< short4>  { typedef void type; }; 
#line 94
template<> struct __nv_isurf_trait< ushort4>  { typedef void type; }; 
#line 95
template<> struct __nv_isurf_trait< int4>  { typedef void type; }; 
#line 96
template<> struct __nv_isurf_trait< uint4>  { typedef void type; }; 
#line 97
template<> struct __nv_isurf_trait< float4>  { typedef void type; }; 
#line 100
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 101
surf1Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 102
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)mode;
#line 106
::exit(___);}
#if 0
#line 102
{ 
#line 106
} 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 109
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 110
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
#line 116
::exit(___);}
#if 0
#line 110
{ 
#line 116
} 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 119
surf2Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 120
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)mode;
#line 124
::exit(___);}
#if 0
#line 120
{ 
#line 124
} 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 127
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 128
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 134
::exit(___);}
#if 0
#line 128
{ 
#line 134
} 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 138
surf3Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 139
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)mode;
#line 143
::exit(___);}
#if 0
#line 139
{ 
#line 143
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 146
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 147
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 153
::exit(___);}
#if 0
#line 147
{ 
#line 153
} 
#endif
#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 156
surf1DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 157
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)mode;
#line 161
::exit(___);}
#if 0
#line 157
{ 
#line 161
} 
#endif
#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 164
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 165
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 171
::exit(___);}
#if 0
#line 165
{ 
#line 171
} 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 174
surf2DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 175
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)mode;
#line 179
::exit(___);}
#if 0
#line 175
{ 
#line 179
} 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 182
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 183
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 189
::exit(___);}
#if 0
#line 183
{ 
#line 189
} 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 192
surfCubemapread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 193
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)face;(void)mode;
#line 197
::exit(___);}
#if 0
#line 193
{ 
#line 197
} 
#endif
#line 199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 200
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 201
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 207
::exit(___);}
#if 0
#line 201
{ 
#line 207
} 
#endif
#line 209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 210
surfCubemapLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 211
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;
#line 215
::exit(___);}
#if 0
#line 211
{ 
#line 215
} 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 218
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 219
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 225
::exit(___);}
#if 0
#line 219
{ 
#line 225
} 
#endif
#line 227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 228
surf1Dwrite(T val, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 229
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)mode;
#line 233
::exit(___);}
#if 0
#line 229
{ 
#line 233
} 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 236
surf2Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 237
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)mode;
#line 241
::exit(___);}
#if 0
#line 237
{ 
#line 241
} 
#endif
#line 243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 244
surf3Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 245
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)z;(void)mode;
#line 249
::exit(___);}
#if 0
#line 245
{ 
#line 249
} 
#endif
#line 251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 252
surf1DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 253
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)layer;(void)mode;
#line 257
::exit(___);}
#if 0
#line 253
{ 
#line 257
} 
#endif
#line 259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 260
surf2DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 261
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layer;(void)mode;
#line 265
::exit(___);}
#if 0
#line 261
{ 
#line 265
} 
#endif
#line 267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 268
surfCubemapwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 269
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)face;(void)mode;
#line 273
::exit(___);}
#if 0
#line 269
{ 
#line 273
} 
#endif
#line 275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 276
surfCubemapLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 277
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;
#line 281
::exit(___);}
#if 0
#line 277
{ 
#line 281
} 
#endif
#line 68 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_launch_parameters.h"
extern "C" {
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v9.1\\include\\device_launch_parameters.h"
extern const uint3 __device_builtin_variable_threadIdx; 
#line 72
extern const uint3 __device_builtin_variable_blockIdx; 
#line 73
extern const dim3 __device_builtin_variable_blockDim; 
#line 74
extern const dim3 __device_builtin_variable_gridDim; 
#line 75
extern const int __device_builtin_variable_warpSize; 
#line 80
}
#line 185 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 186
cudaLaunchKernel(const T *
#line 187
func, ::dim3 
#line 188
gridDim, ::dim3 
#line 189
blockDim, void **
#line 190
args, ::size_t 
#line 191
sharedMem = 0, ::cudaStream_t 
#line 192
stream = 0) 
#line 194
{ 
#line 195
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 196
} 
#line 245
template< class T> static __inline ::cudaError_t 
#line 246
cudaLaunchCooperativeKernel(const T *
#line 247
func, ::dim3 
#line 248
gridDim, ::dim3 
#line 249
blockDim, void **
#line 250
args, ::size_t 
#line 251
sharedMem = 0, ::cudaStream_t 
#line 252
stream = 0) 
#line 254
{ 
#line 255
return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 256
} 
#line 283
template< class T> static __inline ::cudaError_t 
#line 284
cudaSetupArgument(T 
#line 285
arg, ::size_t 
#line 286
offset) 
#line 288
{ 
#line 289
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
#line 290
} 
#line 322
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 323
event, unsigned 
#line 324
flags) 
#line 326
{ 
#line 327
return ::cudaEventCreateWithFlags(event, flags); 
#line 328
} 
#line 385
static __inline cudaError_t cudaMallocHost(void **
#line 386
ptr, size_t 
#line 387
size, unsigned 
#line 388
flags) 
#line 390
{ 
#line 391
return ::cudaHostAlloc(ptr, size, flags); 
#line 392
} 
#line 394
template< class T> static __inline ::cudaError_t 
#line 395
cudaHostAlloc(T **
#line 396
ptr, ::size_t 
#line 397
size, unsigned 
#line 398
flags) 
#line 400
{ 
#line 401
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 402
} 
#line 404
template< class T> static __inline ::cudaError_t 
#line 405
cudaHostGetDevicePointer(T **
#line 406
pDevice, void *
#line 407
pHost, unsigned 
#line 408
flags) 
#line 410
{ 
#line 411
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 412
} 
#line 512
template< class T> static __inline ::cudaError_t 
#line 513
cudaMallocManaged(T **
#line 514
devPtr, ::size_t 
#line 515
size, unsigned 
#line 516
flags = 1) 
#line 518
{ 
#line 519
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
#line 520
} 
#line 591
template< class T> static __inline ::cudaError_t 
#line 592
cudaStreamAttachMemAsync(::cudaStream_t 
#line 593
stream, T *
#line 594
devPtr, ::size_t 
#line 595
length = 0, unsigned 
#line 596
flags = 4) 
#line 598
{ 
#line 599
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
#line 600
} 
#line 602
template< class T> __inline ::cudaError_t 
#line 603
cudaMalloc(T **
#line 604
devPtr, ::size_t 
#line 605
size) 
#line 607
{ 
#line 608
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 609
} 
#line 611
template< class T> static __inline ::cudaError_t 
#line 612
cudaMallocHost(T **
#line 613
ptr, ::size_t 
#line 614
size, unsigned 
#line 615
flags = 0) 
#line 617
{ 
#line 618
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 619
} 
#line 621
template< class T> static __inline ::cudaError_t 
#line 622
cudaMallocPitch(T **
#line 623
devPtr, ::size_t *
#line 624
pitch, ::size_t 
#line 625
width, ::size_t 
#line 626
height) 
#line 628
{ 
#line 629
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 630
} 
#line 667
template< class T> static __inline ::cudaError_t 
#line 668
cudaMemcpyToSymbol(const T &
#line 669
symbol, const void *
#line 670
src, ::size_t 
#line 671
count, ::size_t 
#line 672
offset = 0, ::cudaMemcpyKind 
#line 673
kind = cudaMemcpyHostToDevice) 
#line 675
{ 
#line 676
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 677
} 
#line 719
template< class T> static __inline ::cudaError_t 
#line 720
cudaMemcpyToSymbolAsync(const T &
#line 721
symbol, const void *
#line 722
src, ::size_t 
#line 723
count, ::size_t 
#line 724
offset = 0, ::cudaMemcpyKind 
#line 725
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 726
stream = 0) 
#line 728
{ 
#line 729
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 730
} 
#line 765
template< class T> static __inline ::cudaError_t 
#line 766
cudaMemcpyFromSymbol(void *
#line 767
dst, const T &
#line 768
symbol, ::size_t 
#line 769
count, ::size_t 
#line 770
offset = 0, ::cudaMemcpyKind 
#line 771
kind = cudaMemcpyDeviceToHost) 
#line 773
{ 
#line 774
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 775
} 
#line 817
template< class T> static __inline ::cudaError_t 
#line 818
cudaMemcpyFromSymbolAsync(void *
#line 819
dst, const T &
#line 820
symbol, ::size_t 
#line 821
count, ::size_t 
#line 822
offset = 0, ::cudaMemcpyKind 
#line 823
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 824
stream = 0) 
#line 826
{ 
#line 827
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 828
} 
#line 851
template< class T> static __inline ::cudaError_t 
#line 852
cudaGetSymbolAddress(void **
#line 853
devPtr, const T &
#line 854
symbol) 
#line 856
{ 
#line 857
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 858
} 
#line 881
template< class T> static __inline ::cudaError_t 
#line 882
cudaGetSymbolSize(::size_t *
#line 883
size, const T &
#line 884
symbol) 
#line 886
{ 
#line 887
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 888
} 
#line 923
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 924
cudaBindTexture(::size_t *
#line 925
offset, const texture< T, dim, readMode>  &
#line 926
tex, const void *
#line 927
devPtr, const ::cudaChannelFormatDesc &
#line 928
desc, ::size_t 
#line 929
size = 4294967295U) 
#line 931
{ 
#line 932
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
#line 933
} 
#line 967
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 968
cudaBindTexture(::size_t *
#line 969
offset, const texture< T, dim, readMode>  &
#line 970
tex, const void *
#line 971
devPtr, ::size_t 
#line 972
size = 4294967295U) 
#line 974
{ 
#line 975
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
#line 976
} 
#line 1022
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1023
cudaBindTexture2D(::size_t *
#line 1024
offset, const texture< T, dim, readMode>  &
#line 1025
tex, const void *
#line 1026
devPtr, const ::cudaChannelFormatDesc &
#line 1027
desc, ::size_t 
#line 1028
width, ::size_t 
#line 1029
height, ::size_t 
#line 1030
pitch) 
#line 1032
{ 
#line 1033
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
#line 1034
} 
#line 1079
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1080
cudaBindTexture2D(::size_t *
#line 1081
offset, const texture< T, dim, readMode>  &
#line 1082
tex, const void *
#line 1083
devPtr, ::size_t 
#line 1084
width, ::size_t 
#line 1085
height, ::size_t 
#line 1086
pitch) 
#line 1088
{ 
#line 1089
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
#line 1090
} 
#line 1120
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1121
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1122
tex, ::cudaArray_const_t 
#line 1123
array, const ::cudaChannelFormatDesc &
#line 1124
desc) 
#line 1126
{ 
#line 1127
return ::cudaBindTextureToArray(&tex, array, &desc); 
#line 1128
} 
#line 1157
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1158
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1159
tex, ::cudaArray_const_t 
#line 1160
array) 
#line 1162
{ 
#line 1163
::cudaChannelFormatDesc desc; 
#line 1164
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1166
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
#line 1167
} 
#line 1197
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1198
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1199
tex, ::cudaMipmappedArray_const_t 
#line 1200
mipmappedArray, const ::cudaChannelFormatDesc &
#line 1201
desc) 
#line 1203
{ 
#line 1204
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
#line 1205
} 
#line 1234
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1235
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1236
tex, ::cudaMipmappedArray_const_t 
#line 1237
mipmappedArray) 
#line 1239
{ 
#line 1240
::cudaChannelFormatDesc desc; 
#line 1241
::cudaArray_t levelArray; 
#line 1242
::cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
#line 1244
if (err != (cudaSuccess)) { 
#line 1245
return err; 
#line 1246
}  
#line 1247
err = ::cudaGetChannelDesc(&desc, levelArray); 
#line 1249
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
#line 1250
} 
#line 1273
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1274
cudaUnbindTexture(const texture< T, dim, readMode>  &
#line 1275
tex) 
#line 1277
{ 
#line 1278
return ::cudaUnbindTexture(&tex); 
#line 1279
} 
#line 1307
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1308
cudaGetTextureAlignmentOffset(::size_t *
#line 1309
offset, const texture< T, dim, readMode>  &
#line 1310
tex) 
#line 1312
{ 
#line 1313
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
#line 1314
} 
#line 1359
template< class T> static __inline ::cudaError_t 
#line 1360
cudaFuncSetCacheConfig(T *
#line 1361
func, ::cudaFuncCache 
#line 1362
cacheConfig) 
#line 1364
{ 
#line 1365
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1366
} 
#line 1368
template< class T> static __inline ::cudaError_t 
#line 1369
cudaFuncSetSharedMemConfig(T *
#line 1370
func, ::cudaSharedMemConfig 
#line 1371
config) 
#line 1373
{ 
#line 1374
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1375
} 
#line 1404
template< class T> __inline ::cudaError_t 
#line 1405
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
#line 1406
numBlocks, T 
#line 1407
func, int 
#line 1408
blockSize, ::size_t 
#line 1409
dynamicSMemSize) 
#line 1410
{ 
#line 1411
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
#line 1412
} 
#line 1455
template< class T> __inline ::cudaError_t 
#line 1456
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
#line 1457
numBlocks, T 
#line 1458
func, int 
#line 1459
blockSize, ::size_t 
#line 1460
dynamicSMemSize, unsigned 
#line 1461
flags) 
#line 1462
{ 
#line 1463
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
#line 1464
} 
#line 1469
class __cudaOccupancyB2DHelper { 
#line 1470
size_t n; 
#line 1472
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
#line 1473
size_t operator()(int) 
#line 1474
{ 
#line 1475
return n; 
#line 1476
} 
#line 1477
}; 
#line 1524
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1525
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
#line 1526
minGridSize, int *
#line 1527
blockSize, T 
#line 1528
func, UnaryFunction 
#line 1529
blockSizeToDynamicSMemSize, int 
#line 1530
blockSizeLimit = 0, unsigned 
#line 1531
flags = 0) 
#line 1532
{ 
#line 1533
::cudaError_t status; 
#line 1536
int device; 
#line 1537
::cudaFuncAttributes attr; 
#line 1540
int maxThreadsPerMultiProcessor; 
#line 1541
int warpSize; 
#line 1542
int devMaxThreadsPerBlock; 
#line 1543
int multiProcessorCount; 
#line 1544
int funcMaxThreadsPerBlock; 
#line 1545
int occupancyLimit; 
#line 1546
int granularity; 
#line 1549
int maxBlockSize = 0; 
#line 1550
int numBlocks = 0; 
#line 1551
int maxOccupancy = 0; 
#line 1554
int blockSizeToTryAligned; 
#line 1555
int blockSizeToTry; 
#line 1556
int blockSizeLimitAligned; 
#line 1557
int occupancyInBlocks; 
#line 1558
int occupancyInThreads; 
#line 1559
::size_t dynamicSMemSize; 
#line 1565
if (((!minGridSize) || (!blockSize)) || (!func)) { 
#line 1566
return cudaErrorInvalidValue; 
#line 1567
}  
#line 1573
status = ::cudaGetDevice(&device); 
#line 1574
if (status != (cudaSuccess)) { 
#line 1575
return status; 
#line 1576
}  
#line 1578
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
#line 1582
if (status != (cudaSuccess)) { 
#line 1583
return status; 
#line 1584
}  
#line 1586
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
#line 1590
if (status != (cudaSuccess)) { 
#line 1591
return status; 
#line 1592
}  
#line 1594
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
#line 1598
if (status != (cudaSuccess)) { 
#line 1599
return status; 
#line 1600
}  
#line 1602
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
#line 1606
if (status != (cudaSuccess)) { 
#line 1607
return status; 
#line 1608
}  
#line 1610
status = cudaFuncGetAttributes(&attr, func); 
#line 1611
if (status != (cudaSuccess)) { 
#line 1612
return status; 
#line 1613
}  
#line 1615
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
#line 1621
occupancyLimit = maxThreadsPerMultiProcessor; 
#line 1622
granularity = warpSize; 
#line 1624
if (blockSizeLimit == 0) { 
#line 1625
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1626
}  
#line 1628
if (devMaxThreadsPerBlock < blockSizeLimit) { 
#line 1629
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1630
}  
#line 1632
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
#line 1633
blockSizeLimit = funcMaxThreadsPerBlock; 
#line 1634
}  
#line 1636
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
#line 1638
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
#line 1642
if (blockSizeLimit < blockSizeToTryAligned) { 
#line 1643
blockSizeToTry = blockSizeLimit; 
#line 1644
} else { 
#line 1645
blockSizeToTry = blockSizeToTryAligned; 
#line 1646
}  
#line 1648
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
#line 1650
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
#line 1657
if (status != (cudaSuccess)) { 
#line 1658
return status; 
#line 1659
}  
#line 1661
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
#line 1663
if (occupancyInThreads > maxOccupancy) { 
#line 1664
maxBlockSize = blockSizeToTry; 
#line 1665
numBlocks = occupancyInBlocks; 
#line 1666
maxOccupancy = occupancyInThreads; 
#line 1667
}  
#line 1671
if (occupancyLimit == maxOccupancy) { 
#line 1672
break; 
#line 1673
}  
#line 1674
}  
#line 1682
(*minGridSize) = (numBlocks * multiProcessorCount); 
#line 1683
(*blockSize) = maxBlockSize; 
#line 1685
return status; 
#line 1686
} 
#line 1719
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1720
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
#line 1721
minGridSize, int *
#line 1722
blockSize, T 
#line 1723
func, UnaryFunction 
#line 1724
blockSizeToDynamicSMemSize, int 
#line 1725
blockSizeLimit = 0) 
#line 1726
{ 
#line 1727
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
#line 1728
} 
#line 1764
template< class T> static __inline ::cudaError_t 
#line 1765
cudaOccupancyMaxPotentialBlockSize(int *
#line 1766
minGridSize, int *
#line 1767
blockSize, T 
#line 1768
func, ::size_t 
#line 1769
dynamicSMemSize = 0, int 
#line 1770
blockSizeLimit = 0) 
#line 1771
{ 
#line 1772
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
#line 1773
} 
#line 1823
template< class T> static __inline ::cudaError_t 
#line 1824
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
#line 1825
minGridSize, int *
#line 1826
blockSize, T 
#line 1827
func, ::size_t 
#line 1828
dynamicSMemSize = 0, int 
#line 1829
blockSizeLimit = 0, unsigned 
#line 1830
flags = 0) 
#line 1831
{ 
#line 1832
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
#line 1833
} 
#line 1874
template< class T> static __inline ::cudaError_t 
#line 1875
cudaLaunch(T *
#line 1876
func) 
#line 1878
{ 
#line 1879
return ::cudaLaunch((const void *)func); 
#line 1880
} 
#line 1911
template< class T> __inline ::cudaError_t 
#line 1912
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 1913
attr, T *
#line 1914
entry) 
#line 1916
{ 
#line 1917
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 1918
} 
#line 1953
template< class T> static __inline ::cudaError_t 
#line 1954
cudaFuncSetAttribute(T *
#line 1955
entry, ::cudaFuncAttribute 
#line 1956
attr, int 
#line 1957
value) 
#line 1959
{ 
#line 1960
return ::cudaFuncSetAttribute((const void *)entry, attr, value); 
#line 1961
} 
#line 1983
template< class T, int dim> static __inline ::cudaError_t 
#line 1984
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1985
surf, ::cudaArray_const_t 
#line 1986
array, const ::cudaChannelFormatDesc &
#line 1987
desc) 
#line 1989
{ 
#line 1990
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
#line 1991
} 
#line 2012
template< class T, int dim> static __inline ::cudaError_t 
#line 2013
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 2014
surf, ::cudaArray_const_t 
#line 2015
array) 
#line 2017
{ 
#line 2018
::cudaChannelFormatDesc desc; 
#line 2019
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 2021
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
#line 2022
} 
#line 2036 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda_runtime.h"
#pragma warning(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_printf_options() 
#line 85
{ 
#line 86
static unsigned __int64 _OptionsStorage; 
#line 87
return &_OptionsStorage; 
#line 88
} 
#line 93
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_scanf_options() 
#line 94
{ 
#line 95
static unsigned __int64 _OptionsStorage; 
#line 96
return &_OptionsStorage; 
#line 97
} 
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_stdio_config.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 28
typedef 
#line 25
struct _iobuf { 
#line 27
void *_Placeholder; 
#line 28
} FILE; 
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) FILE *__cdecl __acrt_iob_func(unsigned _Ix); 
#line 48
__declspec(dllimport) wint_t __cdecl fgetwc(FILE * _Stream); 
#line 53
__declspec(dllimport) wint_t __cdecl _fgetwchar(); 
#line 56
__declspec(dllimport) wint_t __cdecl fputwc(__wchar_t _Character, FILE * _Stream); 
#line 61
__declspec(dllimport) wint_t __cdecl _fputwchar(__wchar_t _Character); 
#line 66
__declspec(dllimport) wint_t __cdecl getwc(FILE * _Stream); 
#line 71
__declspec(dllimport) wint_t __cdecl getwchar(); 
#line 76
__declspec(dllimport) __wchar_t *__cdecl fgetws(__wchar_t * _Buffer, int _BufferCount, FILE * _Stream); 
#line 83
__declspec(dllimport) int __cdecl fputws(const __wchar_t * _Buffer, FILE * _Stream); 
#line 90
__declspec(dllimport) __wchar_t *__cdecl _getws_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 95
extern "C++" {template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _getws_s ( _Buffer, _Size ); }}
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) wint_t __cdecl putwc(__wchar_t _Character, FILE * _Stream); 
#line 108
__declspec(dllimport) wint_t __cdecl putwchar(__wchar_t _Character); 
#line 113
__declspec(dllimport) int __cdecl _putws(const __wchar_t * _Buffer); 
#line 118
__declspec(dllimport) wint_t __cdecl ungetwc(wint_t _Character, FILE * _Stream); 
#line 124
__declspec(dllimport) FILE *__cdecl _wfdopen(int _FileHandle, const __wchar_t * _Mode); 
#line 130
__declspec(dllimport) FILE *__cdecl _wfopen(const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 136
__declspec(dllimport) errno_t __cdecl _wfopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 144
__declspec(dllimport) FILE *__cdecl _wfreopen(const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 151
__declspec(dllimport) errno_t __cdecl _wfreopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 159
__declspec(dllimport) FILE *__cdecl _wfsopen(const __wchar_t * _FileName, const __wchar_t * _Mode, int _ShFlag); 
#line 165
__declspec(dllimport) void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 172
__declspec(dllimport) FILE *__cdecl _wpopen(const __wchar_t * _Command, const __wchar_t * _Mode); 
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl _wremove(const __wchar_t * _FileName); 
#line 187
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wtempnam(const __wchar_t * _Directory, const __wchar_t * _FilePrefix); 
#line 196
__declspec(dllimport) errno_t __cdecl _wtmpnam_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 201
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }}
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) __wchar_t *__cdecl _wtmpnam(__wchar_t * _Buffer); 
#line 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * _Stream); 
#line 226
__declspec(dllimport) wint_t __cdecl _fputwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 232
__declspec(dllimport) wint_t __cdecl _getwc_nolock(FILE * _Stream); 
#line 237
__declspec(dllimport) wint_t __cdecl _putwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 243
__declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t _Character, FILE * _Stream); 
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfwprintf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 278
__declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 287
__declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 296
__inline int __cdecl _vfwprintf_l(FILE *const 
#line 297
_Stream, const __wchar_t *const 
#line 298
_Format, const _locale_t 
#line 299
_Locale, va_list 
#line 300
_ArgList) 
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 306
return __stdio_common_vfwprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 307
} 
#line 311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf(FILE *const 
#line 312
_Stream, const __wchar_t *const 
#line 313
_Format, va_list 
#line 314
_ArgList) 
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 320
return _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 321
} 
#line 325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_s_l(FILE *const 
#line 326
_Stream, const __wchar_t *const 
#line 327
_Format, const _locale_t 
#line 328
_Locale, va_list 
#line 329
_ArgList) 
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 335
return __stdio_common_vfwprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 336
} 
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf_s(FILE *const 
#line 343
_Stream, const __wchar_t *const 
#line 344
_Format, va_list 
#line 345
_ArgList) 
#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 351
return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 352
} 
#line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p_l(FILE *const 
#line 359
_Stream, const __wchar_t *const 
#line 360
_Format, const _locale_t 
#line 361
_Locale, va_list 
#line 362
_ArgList) 
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 368
return __stdio_common_vfwprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 369
} 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p(FILE *const 
#line 374
_Stream, const __wchar_t *const 
#line 375
_Format, va_list 
#line 376
_ArgList) 
#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 382
return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 383
} 
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_l(const __wchar_t *const 
#line 388
_Format, const _locale_t 
#line 389
_Locale, va_list 
#line 390
_ArgList) 
#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 396
return _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 397
} 
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf(const __wchar_t *const 
#line 402
_Format, va_list 
#line 403
_ArgList) 
#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 409
return _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 410
} 
#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_s_l(const __wchar_t *const 
#line 415
_Format, const _locale_t 
#line 416
_Locale, va_list 
#line 417
_ArgList) 
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 423
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 424
} 
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf_s(const __wchar_t *const 
#line 431
_Format, va_list 
#line 432
_ArgList) 
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 438
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 439
} 
#line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p_l(const __wchar_t *const 
#line 446
_Format, const _locale_t 
#line 447
_Locale, va_list 
#line 448
_ArgList) 
#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 454
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 455
} 
#line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p(const __wchar_t *const 
#line 460
_Format, va_list 
#line 461
_ArgList) 
#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 467
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 468
} 
#line 472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_l(FILE *const 
#line 473
_Stream, const __wchar_t *const 
#line 474
_Format, const _locale_t 
#line 475
_Locale, ...) 
#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 481
int _Result; 
#line 482
va_list _ArgList; 
#line 483
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 484
_Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 485
(void)(_ArgList = ((va_list)0)); 
#line 486
return _Result; 
#line 487
} 
#line 491 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf(FILE *const 
#line 492
_Stream, const __wchar_t *const 
#line 493
_Format, ...) 
#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 499
int _Result; 
#line 500
va_list _ArgList; 
#line 501
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 502
_Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 503
(void)(_ArgList = ((va_list)0)); 
#line 504
return _Result; 
#line 505
} 
#line 509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_s_l(FILE *const 
#line 510
_Stream, const __wchar_t *const 
#line 511
_Format, const _locale_t 
#line 512
_Locale, ...) 
#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 518
int _Result; 
#line 519
va_list _ArgList; 
#line 520
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 521
_Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 522
(void)(_ArgList = ((va_list)0)); 
#line 523
return _Result; 
#line 524
} 
#line 530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf_s(FILE *const 
#line 531
_Stream, const __wchar_t *const 
#line 532
_Format, ...) 
#line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 538
int _Result; 
#line 539
va_list _ArgList; 
#line 540
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 541
_Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 542
(void)(_ArgList = ((va_list)0)); 
#line 543
return _Result; 
#line 544
} 
#line 550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p_l(FILE *const 
#line 551
_Stream, const __wchar_t *const 
#line 552
_Format, const _locale_t 
#line 553
_Locale, ...) 
#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 559
int _Result; 
#line 560
va_list _ArgList; 
#line 561
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 562
_Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 563
(void)(_ArgList = ((va_list)0)); 
#line 564
return _Result; 
#line 565
} 
#line 569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p(FILE *const 
#line 570
_Stream, const __wchar_t *const 
#line 571
_Format, ...) 
#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 577
int _Result; 
#line 578
va_list _ArgList; 
#line 579
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 580
_Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 581
(void)(_ArgList = ((va_list)0)); 
#line 582
return _Result; 
#line 583
} 
#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_l(const __wchar_t *const 
#line 588
_Format, const _locale_t 
#line 589
_Locale, ...) 
#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 595
int _Result; 
#line 596
va_list _ArgList; 
#line 597
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 598
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 599
(void)(_ArgList = ((va_list)0)); 
#line 600
return _Result; 
#line 601
} 
#line 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf(const __wchar_t *const 
#line 606
_Format, ...) 
#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 612
int _Result; 
#line 613
va_list _ArgList; 
#line 614
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 615
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 616
(void)(_ArgList = ((va_list)0)); 
#line 617
return _Result; 
#line 618
} 
#line 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_s_l(const __wchar_t *const 
#line 623
_Format, const _locale_t 
#line 624
_Locale, ...) 
#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 630
int _Result; 
#line 631
va_list _ArgList; 
#line 632
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 633
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 634
(void)(_ArgList = ((va_list)0)); 
#line 635
return _Result; 
#line 636
} 
#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf_s(const __wchar_t *const 
#line 643
_Format, ...) 
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 649
int _Result; 
#line 650
va_list _ArgList; 
#line 651
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 652
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 653
(void)(_ArgList = ((va_list)0)); 
#line 654
return _Result; 
#line 655
} 
#line 661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p_l(const __wchar_t *const 
#line 662
_Format, const _locale_t 
#line 663
_Locale, ...) 
#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 669
int _Result; 
#line 670
va_list _ArgList; 
#line 671
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 672
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 673
(void)(_ArgList = ((va_list)0)); 
#line 674
return _Result; 
#line 675
} 
#line 679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p(const __wchar_t *const 
#line 680
_Format, ...) 
#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 686
int _Result; 
#line 687
va_list _ArgList; 
#line 688
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 689
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 690
(void)(_ArgList = ((va_list)0)); 
#line 691
return _Result; 
#line 692
} 
#line 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfwscanf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 711
__inline int __cdecl _vfwscanf_l(FILE *const 
#line 712
_Stream, const __wchar_t *const 
#line 713
_Format, const _locale_t 
#line 714
_Locale, va_list 
#line 715
_ArgList) 
#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 721
return __stdio_common_vfwscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 724
} 
#line 728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf(FILE *const 
#line 729
_Stream, const __wchar_t *const 
#line 730
_Format, va_list 
#line 731
_ArgList) 
#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 737
return _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 738
} 
#line 742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwscanf_s_l(FILE *const 
#line 743
_Stream, const __wchar_t *const 
#line 744
_Format, const _locale_t 
#line 745
_Locale, va_list 
#line 746
_ArgList) 
#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 752
return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 755
} 
#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf_s(FILE *const 
#line 762
_Stream, const __wchar_t *const 
#line 763
_Format, va_list 
#line 764
_ArgList) 
#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 770
return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 771
} 
#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_l(const __wchar_t *const 
#line 777
_Format, const _locale_t 
#line 778
_Locale, va_list 
#line 779
_ArgList) 
#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 785
return _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 786
} 
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf(const __wchar_t *const 
#line 791
_Format, va_list 
#line 792
_ArgList) 
#line 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 798
return _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 799
} 
#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_s_l(const __wchar_t *const 
#line 804
_Format, const _locale_t 
#line 805
_Locale, va_list 
#line 806
_ArgList) 
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 812
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 813
} 
#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf_s(const __wchar_t *const 
#line 820
_Format, va_list 
#line 821
_ArgList) 
#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 827
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 828
} 
#line 834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_l(FILE *const 
#line 835
_Stream, const __wchar_t *const 
#line 836
_Format, const _locale_t 
#line 837
_Locale, ...) 
#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 843
int _Result; 
#line 844
va_list _ArgList; 
#line 845
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 846
_Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 847
(void)(_ArgList = ((va_list)0)); 
#line 848
return _Result; 
#line 849
} 
#line 853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf(FILE *const 
#line 854
_Stream, const __wchar_t *const 
#line 855
_Format, ...) 
#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 861
int _Result; 
#line 862
va_list _ArgList; 
#line 863
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 864
_Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 865
(void)(_ArgList = ((va_list)0)); 
#line 866
return _Result; 
#line 867
} 
#line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_s_l(FILE *const 
#line 872
_Stream, const __wchar_t *const 
#line 873
_Format, const _locale_t 
#line 874
_Locale, ...) 
#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 880
int _Result; 
#line 881
va_list _ArgList; 
#line 882
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 883
_Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 884
(void)(_ArgList = ((va_list)0)); 
#line 885
return _Result; 
#line 886
} 
#line 892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf_s(FILE *const 
#line 893
_Stream, const __wchar_t *const 
#line 894
_Format, ...) 
#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 900
int _Result; 
#line 901
va_list _ArgList; 
#line 902
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 903
_Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 904
(void)(_ArgList = ((va_list)0)); 
#line 905
return _Result; 
#line 906
} 
#line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_l(const __wchar_t *const 
#line 913
_Format, const _locale_t 
#line 914
_Locale, ...) 
#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 920
int _Result; 
#line 921
va_list _ArgList; 
#line 922
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 923
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 924
(void)(_ArgList = ((va_list)0)); 
#line 925
return _Result; 
#line 926
} 
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf(const __wchar_t *const 
#line 931
_Format, ...) 
#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 937
int _Result; 
#line 938
va_list _ArgList; 
#line 939
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 940
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 941
(void)(_ArgList = ((va_list)0)); 
#line 942
return _Result; 
#line 943
} 
#line 947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_s_l(const __wchar_t *const 
#line 948
_Format, const _locale_t 
#line 949
_Locale, ...) 
#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 955
int _Result; 
#line 956
va_list _ArgList; 
#line 957
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 958
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 959
(void)(_ArgList = ((va_list)0)); 
#line 960
return _Result; 
#line 961
} 
#line 967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf_s(const __wchar_t *const 
#line 968
_Format, ...) 
#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 974
int _Result; 
#line 975
va_list _ArgList; 
#line 976
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 977
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 978
(void)(_ArgList = ((va_list)0)); 
#line 979
return _Result; 
#line 980
} 
#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vswprintf(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1014
__declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1025
__declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1037
__declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1048
__inline int __cdecl _vsnwprintf_l(__wchar_t *const 
#line 1049
_Buffer, const size_t 
#line 1050
_BufferCount, const __wchar_t *const 
#line 1051
_Format, const _locale_t 
#line 1052
_Locale, va_list 
#line 1053
_ArgList) 
#line 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1059
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1063
return (_Result < 0) ? -1 : _Result; 
#line 1064
} 
#line 1067 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4793)
#line 1072
__inline int __cdecl _vsnwprintf_s_l(__wchar_t *const 
#line 1073
_Buffer, const size_t 
#line 1074
_BufferCount, const size_t 
#line 1075
_MaxCount, const __wchar_t *const 
#line 1076
_Format, const _locale_t 
#line 1077
_Locale, va_list 
#line 1078
_ArgList) 
#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1084
const int _Result = __stdio_common_vsnwprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1088
return (_Result < 0) ? -1 : _Result; 
#line 1089
} 
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf_s(__wchar_t *const 
#line 1095
_Buffer, const size_t 
#line 1096
_BufferCount, const size_t 
#line 1097
_MaxCount, const __wchar_t *const 
#line 1098
_Format, va_list 
#line 1099
_ArgList) 
#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1105
return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1106
} 
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, ...); __inline int __cdecl _vsnwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, va_list _Args); 
#line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1122
__inline int __cdecl _vsnwprintf(__wchar_t *
#line 1123
_Buffer, size_t 
#line 1124
_BufferCount, const __wchar_t *
#line 1125
_Format, va_list 
#line 1126
_ArgList) 
#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 1139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, va_list _ArgList ) throw ( ) { return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c_l(__wchar_t *const 
#line 1151
_Buffer, const size_t 
#line 1152
_BufferCount, const __wchar_t *const 
#line 1153
_Format, const _locale_t 
#line 1154
_Locale, va_list 
#line 1155
_ArgList) 
#line 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1161
const int _Result = __stdio_common_vswprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1165
return (_Result < 0) ? -1 : _Result; 
#line 1166
} 
#line 1171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c(__wchar_t *const 
#line 1172
_Buffer, const size_t 
#line 1173
_BufferCount, const __wchar_t *const 
#line 1174
_Format, va_list 
#line 1175
_ArgList) 
#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1181
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1182
} 
#line 1187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_l(__wchar_t *const 
#line 1188
_Buffer, const size_t 
#line 1189
_BufferCount, const __wchar_t *const 
#line 1190
_Format, const _locale_t 
#line 1191
_Locale, va_list 
#line 1192
_ArgList) 
#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
} 
#line 1207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __vswprintf_l(__wchar_t *const 
#line 1208
_Buffer, const __wchar_t *const 
#line 1209
_Format, const _locale_t 
#line 1210
_Locale, va_list 
#line 1211
_ArgList) 
#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1217
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1218
} 
#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf(__wchar_t *const 
#line 1224
_Buffer, const __wchar_t *const 
#line 1225
_Format, va_list 
#line 1226
_ArgList) 
#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1232
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#line 1233
} 
#line 1238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf(__wchar_t *const 
#line 1239
_Buffer, const size_t 
#line 1240
_BufferCount, const __wchar_t *const 
#line 1241
_Format, va_list 
#line 1242
_ArgList) 
#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1248
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1249
} 
#line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_s_l(__wchar_t *const 
#line 1255
_Buffer, const size_t 
#line 1256
_BufferCount, const __wchar_t *const 
#line 1257
_Format, const _locale_t 
#line 1258
_Locale, va_list 
#line 1259
_ArgList) 
#line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1265
const int _Result = __stdio_common_vswprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1269
return (_Result < 0) ? -1 : _Result; 
#line 1270
} 
#line 1276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf_s(__wchar_t *const 
#line 1277
_Buffer, const size_t 
#line 1278
_BufferCount, const __wchar_t *const 
#line 1279
_Format, va_list 
#line 1280
_ArgList) 
#line 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1286
return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1287
} 
#line 1292 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p_l(__wchar_t *const 
#line 1303
_Buffer, const size_t 
#line 1304
_BufferCount, const __wchar_t *const 
#line 1305
_Format, const _locale_t 
#line 1306
_Locale, va_list 
#line 1307
_ArgList) 
#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1313
const int _Result = __stdio_common_vswprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1317
return (_Result < 0) ? -1 : _Result; 
#line 1318
} 
#line 1323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p(__wchar_t *const 
#line 1324
_Buffer, const size_t 
#line 1325
_BufferCount, const __wchar_t *const 
#line 1326
_Format, va_list 
#line 1327
_ArgList) 
#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1333
return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1334
} 
#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_l(const __wchar_t *const 
#line 1340
_Format, const _locale_t 
#line 1341
_Locale, va_list 
#line 1342
_ArgList) 
#line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1348
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1352
return (_Result < 0) ? -1 : _Result; 
#line 1353
} 
#line 1358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf(const __wchar_t *const 
#line 1359
_Format, va_list 
#line 1360
_ArgList) 
#line 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1366
return _vscwprintf_l(_Format, 0, _ArgList); 
#line 1367
} 
#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p_l(const __wchar_t *const 
#line 1373
_Format, const _locale_t 
#line 1374
_Locale, va_list 
#line 1375
_ArgList) 
#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1381
const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1385
return (_Result < 0) ? -1 : _Result; 
#line 1386
} 
#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p(const __wchar_t *const 
#line 1392
_Format, va_list 
#line 1393
_ArgList) 
#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1399
return _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1400
} 
#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __swprintf_l(__wchar_t *const 
#line 1406
_Buffer, const __wchar_t *const 
#line 1407
_Format, const _locale_t 
#line 1408
_Locale, ...) 
#line 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1414
int _Result; 
#line 1415
va_list _ArgList; 
#line 1416
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1417
_Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 1418
(void)(_ArgList = ((va_list)0)); 
#line 1419
return _Result; 
#line 1420
} 
#line 1425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_l(__wchar_t *const 
#line 1426
_Buffer, const size_t 
#line 1427
_BufferCount, const __wchar_t *const 
#line 1428
_Format, const _locale_t 
#line 1429
_Locale, ...) 
#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1435
int _Result; 
#line 1436
va_list _ArgList; 
#line 1437
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1438
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1439
(void)(_ArgList = ((va_list)0)); 
#line 1440
return _Result; 
#line 1441
} 
#line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t *const 
#line 1447
_Buffer, const __wchar_t *const 
#line 1448
_Format, ...) 
#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1454
int _Result; 
#line 1455
va_list _ArgList; 
#line 1456
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1457
_Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList); 
#line 1458
(void)(_ArgList = ((va_list)0)); 
#line 1459
return _Result; 
#line 1460
} 
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf(__wchar_t *const 
#line 1466
_Buffer, const size_t 
#line 1467
_BufferCount, const __wchar_t *const 
#line 1468
_Format, ...) 
#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1474
int _Result; 
#line 1475
va_list _ArgList; 
#line 1476
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1477
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1478
(void)(_ArgList = ((va_list)0)); 
#line 1479
return _Result; 
#line 1480
} 
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#line 1486
#pragma warning(disable:4793 4996)
#line 1488
__inline int __cdecl __swprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, ...); __inline int __cdecl __vswprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, va_list _Args); 
#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t * _Buffer, const __wchar_t * _Format, ...); __inline int __cdecl _vswprintf(__wchar_t * _Buffer, const __wchar_t * _Format, va_list _Args); 
#line 1504 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1508
__inline int __cdecl _swprintf_s_l(__wchar_t *const 
#line 1509
_Buffer, const size_t 
#line 1510
_BufferCount, const __wchar_t *const 
#line 1511
_Format, const _locale_t 
#line 1512
_Locale, ...) 
#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1518
int _Result; 
#line 1519
va_list _ArgList; 
#line 1520
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1521
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1522
(void)(_ArgList = ((va_list)0)); 
#line 1523
return _Result; 
#line 1524
} 
#line 1530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf_s(__wchar_t *const 
#line 1531
_Buffer, const size_t 
#line 1532
_BufferCount, const __wchar_t *const 
#line 1533
_Format, ...) 
#line 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1539
int _Result; 
#line 1540
va_list _ArgList; 
#line 1541
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1542
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1543
(void)(_ArgList = ((va_list)0)); 
#line 1544
return _Result; 
#line 1545
} 
#line 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_va_start_verify_argument_type < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p_l(__wchar_t *const 
#line 1560
_Buffer, const size_t 
#line 1561
_BufferCount, const __wchar_t *const 
#line 1562
_Format, const _locale_t 
#line 1563
_Locale, ...) 
#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1569
int _Result; 
#line 1570
va_list _ArgList; 
#line 1571
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1572
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1573
(void)(_ArgList = ((va_list)0)); 
#line 1574
return _Result; 
#line 1575
} 
#line 1580 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p(__wchar_t *const 
#line 1581
_Buffer, const size_t 
#line 1582
_BufferCount, const __wchar_t *const 
#line 1583
_Format, ...) 
#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1589
int _Result; 
#line 1590
va_list _ArgList; 
#line 1591
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1592
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1593
(void)(_ArgList = ((va_list)0)); 
#line 1594
return _Result; 
#line 1595
} 
#line 1600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c_l(__wchar_t *const 
#line 1601
_Buffer, const size_t 
#line 1602
_BufferCount, const __wchar_t *const 
#line 1603
_Format, const _locale_t 
#line 1604
_Locale, ...) 
#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1610
int _Result; 
#line 1611
va_list _ArgList; 
#line 1612
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1613
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1614
(void)(_ArgList = ((va_list)0)); 
#line 1615
return _Result; 
#line 1616
} 
#line 1621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c(__wchar_t *const 
#line 1622
_Buffer, const size_t 
#line 1623
_BufferCount, const __wchar_t *const 
#line 1624
_Format, ...) 
#line 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1630
int _Result; 
#line 1631
va_list _ArgList; 
#line 1632
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1633
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1634
(void)(_ArgList = ((va_list)0)); 
#line 1635
return _Result; 
#line 1636
} 
#line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_l(__wchar_t *const 
#line 1642
_Buffer, const size_t 
#line 1643
_BufferCount, const __wchar_t *const 
#line 1644
_Format, const _locale_t 
#line 1645
_Locale, ...) 
#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1651
int _Result; 
#line 1652
va_list _ArgList; 
#line 1653
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1655
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 1660
(void)(_ArgList = ((va_list)0)); 
#line 1661
return _Result; 
#line 1662
} 
#line 1667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t *
#line 1668
_Buffer, size_t 
#line 1669
_BufferCount, const __wchar_t *
#line 1670
_Format, ...) 
#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1676
int _Result; 
#line 1677
va_list _ArgList; 
#line 1678
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1680
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
#line 1685
(void)(_ArgList = ((va_list)0)); 
#line 1686
return _Result; 
#line 1687
} 
#line 1692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s_l(__wchar_t *const 
#line 1693
_Buffer, const size_t 
#line 1694
_BufferCount, const size_t 
#line 1695
_MaxCount, const __wchar_t *const 
#line 1696
_Format, const _locale_t 
#line 1697
_Locale, ...) 
#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1703
int _Result; 
#line 1704
va_list _ArgList; 
#line 1705
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1706
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1707
(void)(_ArgList = ((va_list)0)); 
#line 1708
return _Result; 
#line 1709
} 
#line 1714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s(__wchar_t *const 
#line 1715
_Buffer, const size_t 
#line 1716
_BufferCount, const size_t 
#line 1717
_MaxCount, const __wchar_t *const 
#line 1718
_Format, ...) 
#line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1724
int _Result; 
#line 1725
va_list _ArgList; 
#line 1726
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1727
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1728
(void)(_ArgList = ((va_list)0)); 
#line 1729
return _Result; 
#line 1730
} 
#line 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_va_start_verify_argument_type < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_l(const __wchar_t *const 
#line 1743
_Format, const _locale_t 
#line 1744
_Locale, ...) 
#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1750
int _Result; 
#line 1751
va_list _ArgList; 
#line 1752
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1753
_Result = _vscwprintf_l(_Format, _Locale, _ArgList); 
#line 1754
(void)(_ArgList = ((va_list)0)); 
#line 1755
return _Result; 
#line 1756
} 
#line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf(const __wchar_t *const 
#line 1762
_Format, ...) 
#line 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1768
int _Result; 
#line 1769
va_list _ArgList; 
#line 1770
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1771
_Result = _vscwprintf_l(_Format, 0, _ArgList); 
#line 1772
(void)(_ArgList = ((va_list)0)); 
#line 1773
return _Result; 
#line 1774
} 
#line 1779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p_l(const __wchar_t *const 
#line 1780
_Format, const _locale_t 
#line 1781
_Locale, ...) 
#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1787
int _Result; 
#line 1788
va_list _ArgList; 
#line 1789
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1790
_Result = _vscwprintf_p_l(_Format, _Locale, _ArgList); 
#line 1791
(void)(_ArgList = ((va_list)0)); 
#line 1792
return _Result; 
#line 1793
} 
#line 1798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p(const __wchar_t *const 
#line 1799
_Format, ...) 
#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1805
int _Result; 
#line 1806
va_list _ArgList; 
#line 1807
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1808
_Result = _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1809
(void)(_ArgList = ((va_list)0)); 
#line 1810
return _Result; 
#line 1811
} 
#line 1816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4141 4412 4793 4996 6054)
#line 1822
extern "C++" 
#line 1821
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1822
swprintf(__wchar_t *const 
#line 1823
_Buffer, const __wchar_t *const 
#line 1824
_Format, ...) throw() 
#line 1826
{ 
#line 1827
int _Result; 
#line 1828
va_list _ArgList; 
#line 1829
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#pragma warning(suppress: 28719)
_Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1832
(void)(_ArgList = ((va_list)0)); 
#line 1833
return _Result; 
#line 1834
} 
#line 1837
extern "C++" 
#line 1836
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1837
vswprintf(__wchar_t *const 
#line 1838
_Buffer, const __wchar_t *const 
#line 1839
_Format, va_list 
#line 1840
_ArgList) throw() 
#line 1842
{ 
#pragma warning(suppress: 28719)
return vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1845
} 
#line 1848
extern "C++" 
#line 1847
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1848
_swprintf_l(__wchar_t *const 
#line 1849
_Buffer, const __wchar_t *const 
#line 1850
_Format, const _locale_t 
#line 1851
_Locale, ...) throw() 
#line 1853
{ 
#line 1854
int _Result; 
#line 1855
va_list _ArgList; 
#line 1856
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1857
_Result = _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1858
(void)(_ArgList = ((va_list)0)); 
#line 1859
return _Result; 
#line 1860
} 
#line 1863
extern "C++" 
#line 1862
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1863
_vswprintf_l(__wchar_t *const 
#line 1864
_Buffer, const __wchar_t *const 
#line 1865
_Format, const _locale_t 
#line 1866
_Locale, va_list 
#line 1867
_ArgList) throw() 
#line 1869
{ 
#line 1870
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1871
} 
#line 1875 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vswscanf(unsigned __int64 _Options, const __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1903
__inline int __cdecl _vswscanf_l(const __wchar_t *const 
#line 1904
_Buffer, const __wchar_t *const 
#line 1905
_Format, const _locale_t 
#line 1906
_Locale, va_list 
#line 1907
_ArgList) 
#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1913
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1916
} 
#line 1921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf(const __wchar_t *
#line 1922
_Buffer, const __wchar_t *
#line 1923
_Format, va_list 
#line 1924
_ArgList) 
#line 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1930
return _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 1931
} 
#line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswscanf_s_l(const __wchar_t *const 
#line 1937
_Buffer, const __wchar_t *const 
#line 1938
_Format, const _locale_t 
#line 1939
_Locale, va_list 
#line 1940
_ArgList) 
#line 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1946
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1949
} 
#line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf_s(const __wchar_t *const 
#line 1957
_Buffer, const __wchar_t *const 
#line 1958
_Format, va_list 
#line 1959
_ArgList) 
#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1965
return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 1966
} 
#line 1971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswscanf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_l(const __wchar_t *const 
#line 1982
_Buffer, const size_t 
#line 1983
_BufferCount, const __wchar_t *const 
#line 1984
_Format, const _locale_t 
#line 1985
_Locale, va_list 
#line 1986
_ArgList) 
#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1992
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1995
} 
#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_s_l(const __wchar_t *const 
#line 2001
_Buffer, const size_t 
#line 2002
_BufferCount, const __wchar_t *const 
#line 2003
_Format, const _locale_t 
#line 2004
_Locale, va_list 
#line 2005
_ArgList) 
#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2011
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2014
} 
#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_l(const __wchar_t *const 
#line 2020
_Buffer, const __wchar_t *const 
#line 2021
_Format, _locale_t 
#line 2022
_Locale, ...) 
#line 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2028
int _Result; 
#line 2029
va_list _ArgList; 
#line 2030
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2031
_Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2032
(void)(_ArgList = ((va_list)0)); 
#line 2033
return _Result; 
#line 2034
} 
#line 2039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf(const __wchar_t *const 
#line 2040
_Buffer, const __wchar_t *const 
#line 2041
_Format, ...) 
#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2047
int _Result; 
#line 2048
va_list _ArgList; 
#line 2049
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2050
_Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2051
(void)(_ArgList = ((va_list)0)); 
#line 2052
return _Result; 
#line 2053
} 
#line 2058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_s_l(const __wchar_t *const 
#line 2059
_Buffer, const __wchar_t *const 
#line 2060
_Format, const _locale_t 
#line 2061
_Locale, ...) 
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2067
int _Result; 
#line 2068
va_list _ArgList; 
#line 2069
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2070
_Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2071
(void)(_ArgList = ((va_list)0)); 
#line 2072
return _Result; 
#line 2073
} 
#line 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf_s(const __wchar_t *const 
#line 2081
_Buffer, const __wchar_t *const 
#line 2082
_Format, ...) 
#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2088
int _Result; 
#line 2089
va_list _ArgList; 
#line 2090
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2091
_Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2092
(void)(_ArgList = ((va_list)0)); 
#line 2093
return _Result; 
#line 2094
} 
#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_l(const __wchar_t *const 
#line 2102
_Buffer, const size_t 
#line 2103
_BufferCount, const __wchar_t *const 
#line 2104
_Format, const _locale_t 
#line 2105
_Locale, ...) 
#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2111
int _Result; 
#line 2112
va_list _ArgList; 
#line 2113
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2115
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 2120
(void)(_ArgList = ((va_list)0)); 
#line 2121
return _Result; 
#line 2122
} 
#line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf(const __wchar_t *const 
#line 2128
_Buffer, const size_t 
#line 2129
_BufferCount, const __wchar_t *const 
#line 2130
_Format, ...) 
#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2136
int _Result; 
#line 2137
va_list _ArgList; 
#line 2138
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2140
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
#line 2145
(void)(_ArgList = ((va_list)0)); 
#line 2146
return _Result; 
#line 2147
} 
#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s_l(const __wchar_t *const 
#line 2153
_Buffer, const size_t 
#line 2154
_BufferCount, const __wchar_t *const 
#line 2155
_Format, const _locale_t 
#line 2156
_Locale, ...) 
#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2162
int _Result; 
#line 2163
va_list _ArgList; 
#line 2164
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2165
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2166
(void)(_ArgList = ((va_list)0)); 
#line 2167
return _Result; 
#line 2168
} 
#line 2173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s(const __wchar_t *const 
#line 2174
_Buffer, const size_t 
#line 2175
_BufferCount, const __wchar_t *const 
#line 2176
_Format, ...) 
#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2182
int _Result; 
#line 2183
va_list _ArgList; 
#line 2184
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2185
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2186
(void)(_ArgList = ((va_list)0)); 
#line 2187
return _Result; 
#line 2188
} 
#line 2198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wstdio.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
typedef __int64 fpos_t; 
#line 75
__declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(FILE * _Stream, char *** _Base, char *** _Pointer, int ** _Count); 
#line 91
__declspec(dllimport) errno_t __cdecl clearerr_s(FILE * _Stream); 
#line 96
__declspec(dllimport) errno_t __cdecl fopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode); 
#line 104
__declspec(dllimport) size_t __cdecl fread_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 113
__declspec(dllimport) errno_t __cdecl freopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode, FILE * _OldStream); 
#line 121
__declspec(dllimport) char *__cdecl gets_s(char * _Buffer, rsize_t _Size); 
#line 127
__declspec(dllimport) errno_t __cdecl tmpfile_s(FILE ** _Stream); 
#line 133
__declspec(dllimport) errno_t __cdecl tmpnam_s(char * _Buffer, rsize_t _Size); 
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) void __cdecl clearerr(FILE * _Stream); 
#line 146
__declspec(dllimport) int __cdecl fclose(FILE * _Stream); 
#line 151
__declspec(dllimport) int __cdecl _fcloseall(); 
#line 154
__declspec(dllimport) FILE *__cdecl _fdopen(int _FileHandle, const char * _Mode); 
#line 160
__declspec(dllimport) int __cdecl feof(FILE * _Stream); 
#line 165
__declspec(dllimport) int __cdecl ferror(FILE * _Stream); 
#line 170
__declspec(dllimport) int __cdecl fflush(FILE * _Stream); 
#line 176
__declspec(dllimport) int __cdecl fgetc(FILE * _Stream); 
#line 181
__declspec(dllimport) int __cdecl _fgetchar(); 
#line 185
__declspec(dllimport) int __cdecl fgetpos(FILE * _Stream, fpos_t * _Position); 
#line 192
__declspec(dllimport) char *__cdecl fgets(char * _Buffer, int _MaxCount, FILE * _Stream); 
#line 199
__declspec(dllimport) int __cdecl _fileno(FILE * _Stream); 
#line 204
__declspec(dllimport) int __cdecl _flushall(); 
#line 207
__declspec(dllimport) FILE *__cdecl fopen(const char * _FileName, const char * _Mode); 
#line 215
__declspec(dllimport) int __cdecl fputc(int _Character, FILE * _Stream); 
#line 221
__declspec(dllimport) int __cdecl _fputchar(int _Character); 
#line 227
__declspec(dllimport) int __cdecl fputs(const char * _Buffer, FILE * _Stream); 
#line 233
__declspec(dllimport) size_t __cdecl fread(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 242
__declspec(dllimport) FILE *__cdecl freopen(const char * _FileName, const char * _Mode, FILE * _Stream); 
#line 249
__declspec(dllimport) FILE *__cdecl _fsopen(const char * _FileName, const char * _Mode, int _ShFlag); 
#line 257
__declspec(dllimport) int __cdecl fsetpos(FILE * _Stream, const fpos_t * _Position); 
#line 264
__declspec(dllimport) int __cdecl fseek(FILE * _Stream, long _Offset, int _Origin); 
#line 272
__declspec(dllimport) int __cdecl _fseeki64(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 280
__declspec(dllimport) long __cdecl ftell(FILE * _Stream); 
#line 286
__declspec(dllimport) __int64 __cdecl _ftelli64(FILE * _Stream); 
#line 291
__declspec(dllimport) size_t __cdecl fwrite(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 300
__declspec(dllimport) int __cdecl getc(FILE * _Stream); 
#line 305
__declspec(dllimport) int __cdecl getchar(); 
#line 308
__declspec(dllimport) int __cdecl _getmaxstdio(); 
#line 310
extern "C++" {template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }}
#line 315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl _getw(FILE * _Stream); 
#line 319
__declspec(dllimport) void __cdecl perror(const char * _ErrorMessage); 
#line 327
__declspec(dllimport) int __cdecl _pclose(FILE * _Stream); 
#line 332
__declspec(dllimport) FILE *__cdecl _popen(const char * _Command, const char * _Mode); 
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl putc(int _Character, FILE * _Stream); 
#line 347
__declspec(dllimport) int __cdecl putchar(int _Character); 
#line 352
__declspec(dllimport) int __cdecl puts(const char * _Buffer); 
#line 358
__declspec(dllimport) int __cdecl _putw(int _Word, FILE * _Stream); 
#line 363
__declspec(dllimport) int __cdecl remove(const char * _FileName); 
#line 368
__declspec(dllimport) int __cdecl rename(const char * _OldFileName, const char * _NewFileName); 
#line 373
__declspec(dllimport) int __cdecl _unlink(const char * _FileName); 
#line 380
__declspec(dllimport) int __cdecl unlink(const char * _FileName); 
#line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) void __cdecl rewind(FILE * _Stream); 
#line 391
__declspec(dllimport) int __cdecl _rmtmp(); 
#line 394
__declspec(dllimport) void __cdecl setbuf(FILE * _Stream, char * _Buffer); 
#line 400
__declspec(dllimport) int __cdecl _setmaxstdio(int _Maximum); 
#line 406
__declspec(dllimport) int __cdecl setvbuf(FILE * _Stream, char * _Buffer, int _Mode, size_t _Size); 
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _tempnam(const char * _DirectoryName, const char * _FilePrefix); 
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) FILE *__cdecl tmpfile(); 
#line 431
extern "C++" {template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buffer, _Size ); }}
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(dllimport) char *__cdecl tmpnam(char * _Buffer); 
#line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 448
__declspec(dllimport) int __cdecl ungetc(int _Character, FILE * _Stream); 
#line 460
__declspec(dllimport) void __cdecl _lock_file(FILE * _Stream); 
#line 464
__declspec(dllimport) void __cdecl _unlock_file(FILE * _Stream); 
#line 470
__declspec(dllimport) int __cdecl _fclose_nolock(FILE * _Stream); 
#line 476
__declspec(dllimport) int __cdecl _fflush_nolock(FILE * _Stream); 
#line 482
__declspec(dllimport) int __cdecl _fgetc_nolock(FILE * _Stream); 
#line 488
__declspec(dllimport) int __cdecl _fputc_nolock(int _Character, FILE * _Stream); 
#line 494
__declspec(dllimport) size_t __cdecl _fread_nolock(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 503
__declspec(dllimport) size_t __cdecl _fread_nolock_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 512
__declspec(dllimport) int __cdecl _fseek_nolock(FILE * _Stream, long _Offset, int _Origin); 
#line 519
__declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 526
__declspec(dllimport) long __cdecl _ftell_nolock(FILE * _Stream); 
#line 531
__declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * _Stream); 
#line 536
__declspec(dllimport) size_t __cdecl _fwrite_nolock(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 544
__declspec(dllimport) int __cdecl _getc_nolock(FILE * _Stream); 
#line 549
__declspec(dllimport) int __cdecl _putc_nolock(int _Character, FILE * _Stream); 
#line 555
__declspec(dllimport) int __cdecl _ungetc_nolock(int _Character, FILE * _Stream); 
#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int *__cdecl __p__commode(); 
#line 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfprintf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 613
__declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 622
__declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 631
__inline int __cdecl _vfprintf_l(FILE *const 
#line 632
_Stream, const char *const 
#line 633
_Format, const _locale_t 
#line 634
_Locale, va_list 
#line 635
_ArgList) 
#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 641
return __stdio_common_vfprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 642
} 
#line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf(FILE *const 
#line 647
_Stream, const char *const 
#line 648
_Format, va_list 
#line 649
_ArgList) 
#line 654 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 655
return _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 656
} 
#line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_s_l(FILE *const 
#line 661
_Stream, const char *const 
#line 662
_Format, const _locale_t 
#line 663
_Locale, va_list 
#line 664
_ArgList) 
#line 669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 670
return __stdio_common_vfprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 671
} 
#line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf_s(FILE *const 
#line 678
_Stream, const char *const 
#line 679
_Format, va_list 
#line 680
_ArgList) 
#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 686
return _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 687
} 
#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p_l(FILE *const 
#line 694
_Stream, const char *const 
#line 695
_Format, const _locale_t 
#line 696
_Locale, va_list 
#line 697
_ArgList) 
#line 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 703
return __stdio_common_vfprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 704
} 
#line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p(FILE *const 
#line 709
_Stream, const char *const 
#line 710
_Format, va_list 
#line 711
_ArgList) 
#line 716 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 717
return _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 718
} 
#line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_l(const char *const 
#line 723
_Format, const _locale_t 
#line 724
_Locale, va_list 
#line 725
_ArgList) 
#line 730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 731
return _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 732
} 
#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf(const char *const 
#line 737
_Format, va_list 
#line 738
_ArgList) 
#line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 744
return _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 745
} 
#line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_s_l(const char *const 
#line 750
_Format, const _locale_t 
#line 751
_Locale, va_list 
#line 752
_ArgList) 
#line 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 758
return _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 759
} 
#line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf_s(const char *const 
#line 766
_Format, va_list 
#line 767
_ArgList) 
#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 773
return _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 774
} 
#line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p_l(const char *const 
#line 781
_Format, const _locale_t 
#line 782
_Locale, va_list 
#line 783
_ArgList) 
#line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 789
return _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 790
} 
#line 794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p(const char *const 
#line 795
_Format, va_list 
#line 796
_ArgList) 
#line 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 802
return _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 803
} 
#line 807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_l(FILE *const 
#line 808
_Stream, const char *const 
#line 809
_Format, const _locale_t 
#line 810
_Locale, ...) 
#line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 816
int _Result; 
#line 817
va_list _ArgList; 
#line 818
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 819
_Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 820
(void)(_ArgList = ((va_list)0)); 
#line 821
return _Result; 
#line 822
} 
#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf(FILE *const 
#line 827
_Stream, const char *const 
#line 828
_Format, ...) 
#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 834
int _Result; 
#line 835
va_list _ArgList; 
#line 836
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 837
_Result = _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 838
(void)(_ArgList = ((va_list)0)); 
#line 839
return _Result; 
#line 840
} 
#line 843 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl _set_printf_count_output(int _Value); 
#line 847
__declspec(dllimport) int __cdecl _get_printf_count_output(); 
#line 850
__inline int __cdecl _fprintf_s_l(FILE *const 
#line 851
_Stream, const char *const 
#line 852
_Format, const _locale_t 
#line 853
_Locale, ...) 
#line 858 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 859
int _Result; 
#line 860
va_list _ArgList; 
#line 861
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 862
_Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 863
(void)(_ArgList = ((va_list)0)); 
#line 864
return _Result; 
#line 865
} 
#line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf_s(FILE *const 
#line 872
_Stream, const char *const 
#line 873
_Format, ...) 
#line 878 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 879
int _Result; 
#line 880
va_list _ArgList; 
#line 881
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 882
_Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 883
(void)(_ArgList = ((va_list)0)); 
#line 884
return _Result; 
#line 885
} 
#line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p_l(FILE *const 
#line 892
_Stream, const char *const 
#line 893
_Format, const _locale_t 
#line 894
_Locale, ...) 
#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 900
int _Result; 
#line 901
va_list _ArgList; 
#line 902
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 903
_Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 904
(void)(_ArgList = ((va_list)0)); 
#line 905
return _Result; 
#line 906
} 
#line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p(FILE *const 
#line 911
_Stream, const char *const 
#line 912
_Format, ...) 
#line 917 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 918
int _Result; 
#line 919
va_list _ArgList; 
#line 920
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 921
_Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 922
(void)(_ArgList = ((va_list)0)); 
#line 923
return _Result; 
#line 924
} 
#line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_l(const char *const 
#line 929
_Format, const _locale_t 
#line 930
_Locale, ...) 
#line 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 936
int _Result; 
#line 937
va_list _ArgList; 
#line 938
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 939
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 940
(void)(_ArgList = ((va_list)0)); 
#line 941
return _Result; 
#line 942
} 
#line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl printf(const char *const 
#line 947
_Format, ...) 
#line 952 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 953
int _Result; 
#line 954
va_list _ArgList; 
#line 955
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 956
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 957
(void)(_ArgList = ((va_list)0)); 
#line 958
return _Result; 
#line 959
} 
#line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_s_l(const char *const 
#line 964
_Format, const _locale_t 
#line 965
_Locale, ...) 
#line 970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 971
int _Result; 
#line 972
va_list _ArgList; 
#line 973
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 974
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 975
(void)(_ArgList = ((va_list)0)); 
#line 976
return _Result; 
#line 977
} 
#line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl printf_s(const char *const 
#line 984
_Format, ...) 
#line 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 990
int _Result; 
#line 991
va_list _ArgList; 
#line 992
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 993
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 994
(void)(_ArgList = ((va_list)0)); 
#line 995
return _Result; 
#line 996
} 
#line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p_l(const char *const 
#line 1003
_Format, const _locale_t 
#line 1004
_Locale, ...) 
#line 1009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1010
int _Result; 
#line 1011
va_list _ArgList; 
#line 1012
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1013
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 1014
(void)(_ArgList = ((va_list)0)); 
#line 1015
return _Result; 
#line 1016
} 
#line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p(const char *const 
#line 1021
_Format, ...) 
#line 1026 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1027
int _Result; 
#line 1028
va_list _ArgList; 
#line 1029
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1030
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 1031
(void)(_ArgList = ((va_list)0)); 
#line 1032
return _Result; 
#line 1033
} 
#line 1042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfscanf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _Arglist); 
#line 1051
__inline int __cdecl _vfscanf_l(FILE *const 
#line 1052
_Stream, const char *const 
#line 1053
_Format, const _locale_t 
#line 1054
_Locale, va_list 
#line 1055
_ArgList) 
#line 1060 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1061
return __stdio_common_vfscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 1064
} 
#line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf(FILE *const 
#line 1069
_Stream, const char *const 
#line 1070
_Format, va_list 
#line 1071
_ArgList) 
#line 1076 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1077
return _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1078
} 
#line 1082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vfscanf_s_l(FILE *const 
#line 1083
_Stream, const char *const 
#line 1084
_Format, const _locale_t 
#line 1085
_Locale, va_list 
#line 1086
_ArgList) 
#line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1092
return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 1095
} 
#line 1102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf_s(FILE *const 
#line 1103
_Stream, const char *const 
#line 1104
_Format, va_list 
#line 1105
_ArgList) 
#line 1110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1111
return _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1112
} 
#line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_l(const char *const 
#line 1119
_Format, const _locale_t 
#line 1120
_Locale, va_list 
#line 1121
_ArgList) 
#line 1126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1127
return _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1128
} 
#line 1132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf(const char *const 
#line 1133
_Format, va_list 
#line 1134
_ArgList) 
#line 1139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1140
return _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1141
} 
#line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_s_l(const char *const 
#line 1146
_Format, const _locale_t 
#line 1147
_Locale, va_list 
#line 1148
_ArgList) 
#line 1153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1154
return _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1155
} 
#line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf_s(const char *const 
#line 1162
_Format, va_list 
#line 1163
_ArgList) 
#line 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1169
return _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1170
} 
#line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_l(FILE *const 
#line 1177
_Stream, const char *const 
#line 1178
_Format, const _locale_t 
#line 1179
_Locale, ...) 
#line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1185
int _Result; 
#line 1186
va_list _ArgList; 
#line 1187
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1188
_Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 1189
(void)(_ArgList = ((va_list)0)); 
#line 1190
return _Result; 
#line 1191
} 
#line 1195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf(FILE *const 
#line 1196
_Stream, const char *const 
#line 1197
_Format, ...) 
#line 1202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1203
int _Result; 
#line 1204
va_list _ArgList; 
#line 1205
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1206
_Result = _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1207
(void)(_ArgList = ((va_list)0)); 
#line 1208
return _Result; 
#line 1209
} 
#line 1213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_s_l(FILE *const 
#line 1214
_Stream, const char *const 
#line 1215
_Format, const _locale_t 
#line 1216
_Locale, ...) 
#line 1221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1222
int _Result; 
#line 1223
va_list _ArgList; 
#line 1224
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1225
_Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 1226
(void)(_ArgList = ((va_list)0)); 
#line 1227
return _Result; 
#line 1228
} 
#line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf_s(FILE *const 
#line 1235
_Stream, const char *const 
#line 1236
_Format, ...) 
#line 1241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1242
int _Result; 
#line 1243
va_list _ArgList; 
#line 1244
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1245
_Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1246
(void)(_ArgList = ((va_list)0)); 
#line 1247
return _Result; 
#line 1248
} 
#line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_l(const char *const 
#line 1255
_Format, const _locale_t 
#line 1256
_Locale, ...) 
#line 1261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1262
int _Result; 
#line 1263
va_list _ArgList; 
#line 1264
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1265
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1266
(void)(_ArgList = ((va_list)0)); 
#line 1267
return _Result; 
#line 1268
} 
#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl scanf(const char *const 
#line 1273
_Format, ...) 
#line 1278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1279
int _Result; 
#line 1280
va_list _ArgList; 
#line 1281
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1282
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1283
(void)(_ArgList = ((va_list)0)); 
#line 1284
return _Result; 
#line 1285
} 
#line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_s_l(const char *const 
#line 1290
_Format, const _locale_t 
#line 1291
_Locale, ...) 
#line 1296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1297
int _Result; 
#line 1298
va_list _ArgList; 
#line 1299
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1300
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1301
(void)(_ArgList = ((va_list)0)); 
#line 1302
return _Result; 
#line 1303
} 
#line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl scanf_s(const char *const 
#line 1310
_Format, ...) 
#line 1315 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1316
int _Result; 
#line 1317
va_list _ArgList; 
#line 1318
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1319
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1320
(void)(_ArgList = ((va_list)0)); 
#line 1321
return _Result; 
#line 1322
} 
#line 1335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vsprintf(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1345
__declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1355
__declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1366
__declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1377
__inline int __cdecl _vsnprintf_l(char *const 
#line 1378
_Buffer, const size_t 
#line 1379
_BufferCount, const char *const 
#line 1380
_Format, const _locale_t 
#line 1381
_Locale, va_list 
#line 1382
_ArgList) 
#line 1387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1388
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1392
return (_Result < 0) ? -1 : _Result; 
#line 1393
} 
#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf(char *const 
#line 1399
_Buffer, const size_t 
#line 1400
_BufferCount, const char *const 
#line 1401
_Format, va_list 
#line 1402
_ArgList) 
#line 1407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 1428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf(char *const 
#line 1429
_Buffer, const size_t 
#line 1430
_BufferCount, const char *const 
#line 1431
_Format, va_list 
#line 1432
_ArgList) 
#line 1437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1438
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1442
return (_Result < 0) ? -1 : _Result; 
#line 1443
} 
#line 1448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_l(char *const 
#line 1449
_Buffer, const char *const 
#line 1450
_Format, const _locale_t 
#line 1451
_Locale, va_list 
#line 1452
_ArgList) 
#line 1457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#pragma warning(pop)
} 
#line 1467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf(char *const 
#line 1468
_Buffer, const char *const 
#line 1469
_Format, va_list 
#line 1470
_ArgList) 
#line 1475 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 1485 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_s_l(char *const 
#line 1486
_Buffer, const size_t 
#line 1487
_BufferCount, const char *const 
#line 1488
_Format, const _locale_t 
#line 1489
_Locale, va_list 
#line 1490
_ArgList) 
#line 1495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1496
const int _Result = __stdio_common_vsprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1500
return (_Result < 0) ? -1 : _Result; 
#line 1501
} 
#line 1508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf_s(char *const 
#line 1509
_Buffer, const size_t 
#line 1510
_BufferCount, const char *const 
#line 1511
_Format, va_list 
#line 1512
_ArgList) 
#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1518
return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1519
} 
#line 1522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p_l(char *const 
#line 1535
_Buffer, const size_t 
#line 1536
_BufferCount, const char *const 
#line 1537
_Format, const _locale_t 
#line 1538
_Locale, va_list 
#line 1539
_ArgList) 
#line 1544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1545
const int _Result = __stdio_common_vsprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1549
return (_Result < 0) ? -1 : _Result; 
#line 1550
} 
#line 1555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p(char *const 
#line 1556
_Buffer, const size_t 
#line 1557
_BufferCount, const char *const 
#line 1558
_Format, va_list 
#line 1559
_ArgList) 
#line 1564 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1565
return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1566
} 
#line 1571 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s_l(char *const 
#line 1572
_Buffer, const size_t 
#line 1573
_BufferCount, const size_t 
#line 1574
_MaxCount, const char *const 
#line 1575
_Format, const _locale_t 
#line 1576
_Locale, va_list 
#line 1577
_ArgList) 
#line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1583
const int _Result = __stdio_common_vsnprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1587
return (_Result < 0) ? -1 : _Result; 
#line 1588
} 
#line 1593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s(char *const 
#line 1594
_Buffer, const size_t 
#line 1595
_BufferCount, const size_t 
#line 1596
_MaxCount, const char *const 
#line 1597
_Format, va_list 
#line 1598
_ArgList) 
#line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1604
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1605
} 
#line 1608 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf_s(char *const 
#line 1622
_Buffer, const size_t 
#line 1623
_BufferCount, const size_t 
#line 1624
_MaxCount, const char *const 
#line 1625
_Format, va_list 
#line 1626
_ArgList) 
#line 1631 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1632
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1633
} 
#line 1636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_l(const char *const 
#line 1649
_Format, const _locale_t 
#line 1650
_Locale, va_list 
#line 1651
_ArgList) 
#line 1656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1657
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1661
return (_Result < 0) ? -1 : _Result; 
#line 1662
} 
#line 1666 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf(const char *const 
#line 1667
_Format, va_list 
#line 1668
_ArgList) 
#line 1673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1674
return _vscprintf_l(_Format, 0, _ArgList); 
#line 1675
} 
#line 1679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p_l(const char *const 
#line 1680
_Format, const _locale_t 
#line 1681
_Locale, va_list 
#line 1682
_ArgList) 
#line 1687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1688
const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1692
return (_Result < 0) ? -1 : _Result; 
#line 1693
} 
#line 1697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p(const char *const 
#line 1698
_Format, va_list 
#line 1699
_ArgList) 
#line 1704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1705
return _vscprintf_p_l(_Format, 0, _ArgList); 
#line 1706
} 
#line 1710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c_l(char *const 
#line 1711
_Buffer, const size_t 
#line 1712
_BufferCount, const char *const 
#line 1713
_Format, const _locale_t 
#line 1714
_Locale, va_list 
#line 1715
_ArgList) 
#line 1720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1721
const int _Result = __stdio_common_vsprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1725
return (_Result < 0) ? -1 : _Result; 
#line 1726
} 
#line 1731 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c(char *const 
#line 1732
_Buffer, const size_t 
#line 1733
_BufferCount, const char *const 
#line 1734
_Format, va_list 
#line 1735
_ArgList) 
#line 1740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1741
return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1742
} 
#line 1747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_l(char *const 
#line 1748
_Buffer, const char *const 
#line 1749
_Format, const _locale_t 
#line 1750
_Locale, ...) 
#line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1756
int _Result; 
#line 1757
va_list _ArgList; 
#line 1758
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1760
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 1765
(void)(_ArgList = ((va_list)0)); 
#line 1766
return _Result; 
#line 1767
} 
#line 1772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf(char *const 
#line 1773
_Buffer, const char *const 
#line 1774
_Format, ...) 
#line 1779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1780
int _Result; 
#line 1781
va_list _ArgList; 
#line 1782
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1784
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList); 
#pragma warning(pop)
#line 1789
(void)(_ArgList = ((va_list)0)); 
#line 1790
return _Result; 
#line 1791
} 
#line 1794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 4996)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__inline int __cdecl sprintf(char * _Buffer, const char * _Format, ...); __inline int __cdecl vsprintf(char * _Buffer, const char * _Format, va_list _Args); 
#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 1808
__inline int __cdecl _sprintf_s_l(char *const 
#line 1809
_Buffer, const size_t 
#line 1810
_BufferCount, const char *const 
#line 1811
_Format, const _locale_t 
#line 1812
_Locale, ...) 
#line 1817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1818
int _Result; 
#line 1819
va_list _ArgList; 
#line 1820
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1821
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1822
(void)(_ArgList = ((va_list)0)); 
#line 1823
return _Result; 
#line 1824
} 
#line 1831 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf_s(char *const 
#line 1832
_Buffer, const size_t 
#line 1833
_BufferCount, const char *const 
#line 1834
_Format, ...) 
#line 1839 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1840
int _Result; 
#line 1841
va_list _ArgList; 
#line 1842
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1843
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1844
(void)(_ArgList = ((va_list)0)); 
#line 1845
return _Result; 
#line 1846
} 
#line 1851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_va_start_verify_argument_type < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 1860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p_l(char *const 
#line 1861
_Buffer, const size_t 
#line 1862
_BufferCount, const char *const 
#line 1863
_Format, const _locale_t 
#line 1864
_Locale, ...) 
#line 1869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1870
int _Result; 
#line 1871
va_list _ArgList; 
#line 1872
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1873
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1874
(void)(_ArgList = ((va_list)0)); 
#line 1875
return _Result; 
#line 1876
} 
#line 1881 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p(char *const 
#line 1882
_Buffer, const size_t 
#line 1883
_BufferCount, const char *const 
#line 1884
_Format, ...) 
#line 1889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1890
int _Result; 
#line 1891
va_list _ArgList; 
#line 1892
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 1893
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1894
(void)(_ArgList = ((va_list)0)); 
#line 1895
return _Result; 
#line 1896
} 
#line 1901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_l(char *const 
#line 1902
_Buffer, const size_t 
#line 1903
_BufferCount, const char *const 
#line 1904
_Format, const _locale_t 
#line 1905
_Locale, ...) 
#line 1910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1911
int _Result; 
#line 1912
va_list _ArgList; 
#line 1913
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 1915
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 1920
(void)(_ArgList = ((va_list)0)); 
#line 1921
return _Result; 
#line 1922
} 
#line 1938 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl snprintf(char *const 
#line 1939
_Buffer, const size_t 
#line 1940
_BufferCount, const char *const 
#line 1941
_Format, ...) 
#line 1946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1947
int _Result; 
#line 1948
va_list _ArgList; 
#line 1949
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#pragma warning(suppress:28719)
_Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1952
(void)(_ArgList = ((va_list)0)); 
#line 1953
return _Result; 
#line 1954
} 
#line 1959 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char *const 
#line 1960
_Buffer, const size_t 
#line 1961
_BufferCount, const char *const 
#line 1962
_Format, ...) 
#line 1967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1968
int _Result; 
#line 1969
va_list _ArgList; 
#line 1970
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#pragma warning(suppress:28719)
_Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1973
(void)(_ArgList = ((va_list)0)); 
#line 1974
return _Result; 
#line 1975
} 
#line 1978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char * _Buffer, size_t _BufferCount, const char * _Format, ...); __inline int __cdecl _vsnprintf(char * _Buffer, size_t _BufferCount, const char * _Format, va_list _Args); 
#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c_l(char *const 
#line 1990
_Buffer, const size_t 
#line 1991
_BufferCount, const char *const 
#line 1992
_Format, const _locale_t 
#line 1993
_Locale, ...) 
#line 1998 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 1999
int _Result; 
#line 2000
va_list _ArgList; 
#line 2001
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2002
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2003
(void)(_ArgList = ((va_list)0)); 
#line 2004
return _Result; 
#line 2005
} 
#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c(char *const 
#line 2011
_Buffer, const size_t 
#line 2012
_BufferCount, const char *const 
#line 2013
_Format, ...) 
#line 2018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2019
int _Result; 
#line 2020
va_list _ArgList; 
#line 2021
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2022
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2023
(void)(_ArgList = ((va_list)0)); 
#line 2024
return _Result; 
#line 2025
} 
#line 2030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s_l(char *const 
#line 2031
_Buffer, const size_t 
#line 2032
_BufferCount, const size_t 
#line 2033
_MaxCount, const char *const 
#line 2034
_Format, const _locale_t 
#line 2035
_Locale, ...) 
#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2041
int _Result; 
#line 2042
va_list _ArgList; 
#line 2043
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2044
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 2045
(void)(_ArgList = ((va_list)0)); 
#line 2046
return _Result; 
#line 2047
} 
#line 2052 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s(char *const 
#line 2053
_Buffer, const size_t 
#line 2054
_BufferCount, const size_t 
#line 2055
_MaxCount, const char *const 
#line 2056
_Format, ...) 
#line 2061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2062
int _Result; 
#line 2063
va_list _ArgList; 
#line 2064
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2065
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 2066
(void)(_ArgList = ((va_list)0)); 
#line 2067
return _Result; 
#line 2068
} 
#line 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_va_start_verify_argument_type < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_l(const char *const 
#line 2081
_Format, const _locale_t 
#line 2082
_Locale, ...) 
#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2088
int _Result; 
#line 2089
va_list _ArgList; 
#line 2090
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2091
_Result = _vscprintf_l(_Format, _Locale, _ArgList); 
#line 2092
(void)(_ArgList = ((va_list)0)); 
#line 2093
return _Result; 
#line 2094
} 
#line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf(const char *const 
#line 2099
_Format, ...) 
#line 2104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2105
int _Result; 
#line 2106
va_list _ArgList; 
#line 2107
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2108
_Result = _vscprintf_l(_Format, 0, _ArgList); 
#line 2109
(void)(_ArgList = ((va_list)0)); 
#line 2110
return _Result; 
#line 2111
} 
#line 2115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p_l(const char *const 
#line 2116
_Format, const _locale_t 
#line 2117
_Locale, ...) 
#line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2123
int _Result; 
#line 2124
va_list _ArgList; 
#line 2125
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2126
_Result = _vscprintf_p_l(_Format, _Locale, _ArgList); 
#line 2127
(void)(_ArgList = ((va_list)0)); 
#line 2128
return _Result; 
#line 2129
} 
#line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p(const char *const 
#line 2134
_Format, ...) 
#line 2139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2140
int _Result; 
#line 2141
va_list _ArgList; 
#line 2142
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2143
_Result = _vscprintf_p(_Format, _ArgList); 
#line 2144
(void)(_ArgList = ((va_list)0)); 
#line 2145
return _Result; 
#line 2146
} 
#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vsscanf(unsigned __int64 _Options, const char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 2164
__inline int __cdecl _vsscanf_l(const char *const 
#line 2165
_Buffer, const char *const 
#line 2166
_Format, const _locale_t 
#line 2167
_Locale, va_list 
#line 2168
_ArgList) 
#line 2173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2174
return __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2177
} 
#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl vsscanf(const char *const 
#line 2182
_Buffer, const char *const 
#line 2183
_Format, va_list 
#line 2184
_ArgList) 
#line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2190
return _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2191
} 
#line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _vsscanf_s_l(const char *const 
#line 2196
_Buffer, const char *const 
#line 2197
_Format, const _locale_t 
#line 2198
_Locale, va_list 
#line 2199
_ArgList) 
#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2205
return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2208
} 
#line 2213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable:6530)
#line 2217
__inline int __cdecl vsscanf_s(const char *const 
#line 2218
_Buffer, const char *const 
#line 2219
_Format, va_list 
#line 2220
_ArgList) 
#line 2225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2226
return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2227
} 
#line 2230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsscanf_s ( char const ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 2237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_l(const char *const 
#line 2243
_Buffer, const char *const 
#line 2244
_Format, const _locale_t 
#line 2245
_Locale, ...) 
#line 2250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2251
int _Result; 
#line 2252
va_list _ArgList; 
#line 2253
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2254
_Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2255
(void)(_ArgList = ((va_list)0)); 
#line 2256
return _Result; 
#line 2257
} 
#line 2261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf(const char *const 
#line 2262
_Buffer, const char *const 
#line 2263
_Format, ...) 
#line 2268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2269
int _Result; 
#line 2270
va_list _ArgList; 
#line 2271
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2272
_Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2273
(void)(_ArgList = ((va_list)0)); 
#line 2274
return _Result; 
#line 2275
} 
#line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_s_l(const char *const 
#line 2280
_Buffer, const char *const 
#line 2281
_Format, const _locale_t 
#line 2282
_Locale, ...) 
#line 2287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2288
int _Result; 
#line 2289
va_list _ArgList; 
#line 2290
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2291
_Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2292
(void)(_ArgList = ((va_list)0)); 
#line 2293
return _Result; 
#line 2294
} 
#line 2300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf_s(const char *const 
#line 2301
_Buffer, const char *const 
#line 2302
_Format, ...) 
#line 2307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2308
int _Result; 
#line 2309
va_list _ArgList; 
#line 2310
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2312
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = vsscanf_s(_Buffer, _Format, _ArgList); 
#pragma warning(pop)
#line 2317
(void)(_ArgList = ((va_list)0)); 
#line 2318
return _Result; 
#line 2319
} 
#line 2324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable:6530)
#line 2328
__inline int __cdecl _snscanf_l(const char *const 
#line 2329
_Buffer, const size_t 
#line 2330
_BufferCount, const char *const 
#line 2331
_Format, const _locale_t 
#line 2332
_Locale, ...) 
#line 2337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2338
int _Result; 
#line 2339
va_list _ArgList; 
#line 2340
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2342
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2346
(void)(_ArgList = ((va_list)0)); 
#line 2347
return _Result; 
#line 2348
} 
#line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf(const char *const 
#line 2353
_Buffer, const size_t 
#line 2354
_BufferCount, const char *const 
#line 2355
_Format, ...) 
#line 2360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2361
int _Result; 
#line 2362
va_list _ArgList; 
#line 2363
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2365
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2369
(void)(_ArgList = ((va_list)0)); 
#line 2370
return _Result; 
#line 2371
} 
#line 2376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s_l(const char *const 
#line 2377
_Buffer, const size_t 
#line 2378
_BufferCount, const char *const 
#line 2379
_Format, const _locale_t 
#line 2380
_Locale, ...) 
#line 2385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2386
int _Result; 
#line 2387
va_list _ArgList; 
#line 2388
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 2390
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2394
(void)(_ArgList = ((va_list)0)); 
#line 2395
return _Result; 
#line 2396
} 
#line 2400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s(const char *const 
#line 2401
_Buffer, const size_t 
#line 2402
_BufferCount, const char *const 
#line 2403
_Format, ...) 
#line 2408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
{ 
#line 2409
int _Result; 
#line 2410
va_list _ArgList; 
#line 2411
(void)(__vcrt_va_start_verify_argument_type< const char *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 2413
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2417
(void)(_ArgList = ((va_list)0)); 
#line 2418
return _Result; 
#line 2419
} 
#line 2422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) char *__cdecl tempnam(const char * _Directory, const char * _FilePrefix); 
#line 2454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl fcloseall(); 
#line 2455
__declspec(dllimport) FILE *__cdecl fdopen(int _FileHandle, const char * _Format); 
#line 2456
__declspec(dllimport) int __cdecl fgetchar(); 
#line 2457
__declspec(dllimport) int __cdecl fileno(FILE * _Stream); 
#line 2458
__declspec(dllimport) int __cdecl flushall(); 
#line 2459
__declspec(dllimport) int __cdecl fputchar(int _Ch); 
#line 2460
__declspec(dllimport) int __cdecl getw(FILE * _Stream); 
#line 2461
__declspec(dllimport) int __cdecl putw(int _Ch, FILE * _Stream); 
#line 2462
__declspec(dllimport) int __cdecl rmtmp(); 
#line 2469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\stdio.h"
}__pragma( pack ( pop )) 
#line 55 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef unsigned cuuint32_t; 
#line 56
typedef unsigned __int64 cuuint64_t; 
#line 216 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
extern "C" {
#line 226 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef unsigned __int64 CUdeviceptr; 
#line 233 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef int CUdevice; 
#line 234
typedef struct CUctx_st *CUcontext; 
#line 235
typedef struct CUmod_st *CUmodule; 
#line 236
typedef struct CUfunc_st *CUfunction; 
#line 237
typedef struct CUarray_st *CUarray; 
#line 238
typedef struct CUmipmappedArray_st *CUmipmappedArray; 
#line 239
typedef struct CUtexref_st *CUtexref; 
#line 240
typedef struct CUsurfref_st *CUsurfref; 
#line 241
typedef CUevent_st *CUevent; 
#line 242
typedef CUstream_st *CUstream; 
#line 243
typedef struct CUgraphicsResource_st *CUgraphicsResource; 
#line 244
typedef unsigned __int64 CUtexObject; 
#line 245
typedef unsigned __int64 CUsurfObject; 
#line 249
typedef 
#line 247
struct CUuuid_st { 
#line 248
char bytes[16]; 
#line 249
} CUuuid; 
#line 264
typedef 
#line 262
struct CUipcEventHandle_st { 
#line 263
char reserved[64]; 
#line 264
} CUipcEventHandle; 
#line 271
typedef 
#line 269
struct CUipcMemHandle_st { 
#line 270
char reserved[64]; 
#line 271
} CUipcMemHandle; 
#line 278
typedef 
#line 276
enum CUipcMem_flags_enum { 
#line 277
CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1
#line 278
} CUipcMem_flags; 
#line 289 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef 
#line 285
enum CUmemAttach_flags_enum { 
#line 286
CU_MEM_ATTACH_GLOBAL = 1, 
#line 287
CU_MEM_ATTACH_HOST, 
#line 288
CU_MEM_ATTACH_SINGLE = 4
#line 289
} CUmemAttach_flags; 
#line 306
typedef 
#line 294
enum CUctx_flags_enum { 
#line 295
CU_CTX_SCHED_AUTO, 
#line 296
CU_CTX_SCHED_SPIN, 
#line 297
CU_CTX_SCHED_YIELD, 
#line 298
CU_CTX_SCHED_BLOCKING_SYNC = 4, 
#line 299
CU_CTX_BLOCKING_SYNC = 4, 
#line 302
CU_CTX_SCHED_MASK = 7, 
#line 303
CU_CTX_MAP_HOST, 
#line 304
CU_CTX_LMEM_RESIZE_TO_MAX = 16, 
#line 305
CU_CTX_FLAGS_MASK = 31
#line 306
} CUctx_flags; 
#line 314
typedef 
#line 311
enum CUstream_flags_enum { 
#line 312
CU_STREAM_DEFAULT, 
#line 313
CU_STREAM_NON_BLOCKING
#line 314
} CUstream_flags; 
#line 344
typedef 
#line 339
enum CUevent_flags_enum { 
#line 340
CU_EVENT_DEFAULT, 
#line 341
CU_EVENT_BLOCKING_SYNC, 
#line 342
CU_EVENT_DISABLE_TIMING, 
#line 343
CU_EVENT_INTERPROCESS = 4
#line 344
} CUevent_flags; 
#line 367
typedef 
#line 350
enum CUstreamWaitValue_flags_enum { 
#line 351
CU_STREAM_WAIT_VALUE_GEQ, 
#line 354
CU_STREAM_WAIT_VALUE_EQ, 
#line 355
CU_STREAM_WAIT_VALUE_AND, 
#line 356
CU_STREAM_WAIT_VALUE_NOR, 
#line 360
CU_STREAM_WAIT_VALUE_FLUSH = 1073741824
#line 367
} CUstreamWaitValue_flags; 
#line 380
typedef 
#line 372
enum CUstreamWriteValue_flags_enum { 
#line 373
CU_STREAM_WRITE_VALUE_DEFAULT, 
#line 374
CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER
#line 380
} CUstreamWriteValue_flags; 
#line 392
typedef 
#line 385
enum CUstreamBatchMemOpType_enum { 
#line 386
CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1, 
#line 387
CU_STREAM_MEM_OP_WRITE_VALUE_32, 
#line 388
CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4, 
#line 389
CU_STREAM_MEM_OP_WRITE_VALUE_64, 
#line 390
CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3
#line 392
} CUstreamBatchMemOpType; 
#line 424
typedef 
#line 397
union CUstreamBatchMemOpParams_union { 
#line 398
CUstreamBatchMemOpType operation; 
#line 399
struct CUstreamMemOpWaitValueParams_st { 
#line 400
CUstreamBatchMemOpType operation; 
#line 401
CUdeviceptr address; 
#line 402
union { 
#line 403
cuuint32_t value; 
#line 404
cuuint64_t value64; 
#line 405
}; 
#line 406
unsigned flags; 
#line 407
CUdeviceptr alias; 
#line 408
} waitValue; 
#line 409
struct CUstreamMemOpWriteValueParams_st { 
#line 410
CUstreamBatchMemOpType operation; 
#line 411
CUdeviceptr address; 
#line 412
union { 
#line 413
cuuint32_t value; 
#line 414
cuuint64_t value64; 
#line 415
}; 
#line 416
unsigned flags; 
#line 417
CUdeviceptr alias; 
#line 418
} writeValue; 
#line 419
struct CUstreamMemOpFlushRemoteWritesParams_st { 
#line 420
CUstreamBatchMemOpType operation; 
#line 421
unsigned flags; 
#line 422
} flushRemoteWrites; 
#line 423
cuuint64_t pad[6]; 
#line 424
} CUstreamBatchMemOpParams; 
#line 433 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef 
#line 430
enum CUoccupancy_flags_enum { 
#line 431
CU_OCCUPANCY_DEFAULT, 
#line 432
CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE
#line 433
} CUoccupancy_flags; 
#line 447
typedef 
#line 438
enum CUarray_format_enum { 
#line 439
CU_AD_FORMAT_UNSIGNED_INT8 = 1, 
#line 440
CU_AD_FORMAT_UNSIGNED_INT16, 
#line 441
CU_AD_FORMAT_UNSIGNED_INT32, 
#line 442
CU_AD_FORMAT_SIGNED_INT8 = 8, 
#line 443
CU_AD_FORMAT_SIGNED_INT16, 
#line 444
CU_AD_FORMAT_SIGNED_INT32, 
#line 445
CU_AD_FORMAT_HALF = 16, 
#line 446
CU_AD_FORMAT_FLOAT = 32
#line 447
} CUarray_format; 
#line 457
typedef 
#line 452
enum CUaddress_mode_enum { 
#line 453
CU_TR_ADDRESS_MODE_WRAP, 
#line 454
CU_TR_ADDRESS_MODE_CLAMP, 
#line 455
CU_TR_ADDRESS_MODE_MIRROR, 
#line 456
CU_TR_ADDRESS_MODE_BORDER
#line 457
} CUaddress_mode; 
#line 465
typedef 
#line 462
enum CUfilter_mode_enum { 
#line 463
CU_TR_FILTER_MODE_POINT, 
#line 464
CU_TR_FILTER_MODE_LINEAR
#line 465
} CUfilter_mode; 
#line 574
typedef 
#line 470
enum CUdevice_attribute_enum { 
#line 471
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1, 
#line 472
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X, 
#line 473
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y, 
#line 474
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z, 
#line 475
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X, 
#line 476
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y, 
#line 477
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z, 
#line 478
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK, 
#line 479
CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8, 
#line 480
CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY, 
#line 481
CU_DEVICE_ATTRIBUTE_WARP_SIZE, 
#line 482
CU_DEVICE_ATTRIBUTE_MAX_PITCH, 
#line 483
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, 
#line 484
CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12, 
#line 485
CU_DEVICE_ATTRIBUTE_CLOCK_RATE, 
#line 486
CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT, 
#line 487
CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, 
#line 488
CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, 
#line 489
CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, 
#line 490
CU_DEVICE_ATTRIBUTE_INTEGRATED, 
#line 491
CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, 
#line 492
CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, 
#line 493
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH, 
#line 494
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH, 
#line 495
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT, 
#line 496
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH, 
#line 497
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT, 
#line 498
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH, 
#line 499
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH, 
#line 500
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT, 
#line 501
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS, 
#line 502
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27, 
#line 503
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT, 
#line 504
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES, 
#line 505
CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, 
#line 506
CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, 
#line 507
CU_DEVICE_ATTRIBUTE_ECC_ENABLED, 
#line 508
CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, 
#line 509
CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, 
#line 510
CU_DEVICE_ATTRIBUTE_TCC_DRIVER, 
#line 511
CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, 
#line 512
CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, 
#line 513
CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, 
#line 514
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, 
#line 515
CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, 
#line 516
CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, 
#line 517
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH, 
#line 518
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS, 
#line 519
CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER, 
#line 520
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH, 
#line 521
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT, 
#line 522
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE, 
#line 523
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE, 
#line 524
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE, 
#line 525
CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, 
#line 526
CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT, 
#line 527
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH, 
#line 528
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH, 
#line 529
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS, 
#line 530
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH, 
#line 531
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH, 
#line 532
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT, 
#line 533
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH, 
#line 534
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT, 
#line 535
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH, 
#line 536
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH, 
#line 537
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS, 
#line 538
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH, 
#line 539
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT, 
#line 540
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS, 
#line 541
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH, 
#line 542
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH, 
#line 543
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS, 
#line 544
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH, 
#line 545
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH, 
#line 546
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT, 
#line 547
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH, 
#line 548
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH, 
#line 549
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT, 
#line 550
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, 
#line 551
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, 
#line 552
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH, 
#line 553
CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED, 
#line 554
CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED, 
#line 555
CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED, 
#line 556
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR, 
#line 557
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR, 
#line 558
CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY, 
#line 559
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD, 
#line 560
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID, 
#line 561
CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED, 
#line 562
CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO, 
#line 563
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS, 
#line 564
CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS, 
#line 565
CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED, 
#line 566
CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM, 
#line 567
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS, 
#line 568
CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS, 
#line 569
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR, 
#line 570
CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH, 
#line 571
CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH, 
#line 572
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN, 
#line 573
CU_DEVICE_ATTRIBUTE_MAX
#line 574
} CUdevice_attribute; 
#line 590
typedef 
#line 579
struct CUdevprop_st { 
#line 580
int maxThreadsPerBlock; 
#line 581
int maxThreadsDim[3]; 
#line 582
int maxGridSize[3]; 
#line 583
int sharedMemPerBlock; 
#line 584
int totalConstantMemory; 
#line 585
int SIMDWidth; 
#line 586
int memPitch; 
#line 587
int regsPerBlock; 
#line 588
int clockRate; 
#line 589
int textureAlign; 
#line 590
} CUdevprop; 
#line 604
typedef 
#line 595
enum CUpointer_attribute_enum { 
#line 596
CU_POINTER_ATTRIBUTE_CONTEXT = 1, 
#line 597
CU_POINTER_ATTRIBUTE_MEMORY_TYPE, 
#line 598
CU_POINTER_ATTRIBUTE_DEVICE_POINTER, 
#line 599
CU_POINTER_ATTRIBUTE_HOST_POINTER, 
#line 600
CU_POINTER_ATTRIBUTE_P2P_TOKENS, 
#line 601
CU_POINTER_ATTRIBUTE_SYNC_MEMOPS, 
#line 602
CU_POINTER_ATTRIBUTE_BUFFER_ID, 
#line 603
CU_POINTER_ATTRIBUTE_IS_MANAGED
#line 604
} CUpointer_attribute; 
#line 679
typedef 
#line 609
enum CUfunction_attribute_enum { 
#line 615
CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, 
#line 622
CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES, 
#line 628
CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES, 
#line 633
CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, 
#line 638
CU_FUNC_ATTRIBUTE_NUM_REGS, 
#line 647
CU_FUNC_ATTRIBUTE_PTX_VERSION, 
#line 656
CU_FUNC_ATTRIBUTE_BINARY_VERSION, 
#line 662
CU_FUNC_ATTRIBUTE_CACHE_MODE_CA, 
#line 669
CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, 
#line 676
CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT, 
#line 678
CU_FUNC_ATTRIBUTE_MAX
#line 679
} CUfunction_attribute; 
#line 689
typedef 
#line 684
enum CUfunc_cache_enum { 
#line 685
CU_FUNC_CACHE_PREFER_NONE, 
#line 686
CU_FUNC_CACHE_PREFER_SHARED, 
#line 687
CU_FUNC_CACHE_PREFER_L1, 
#line 688
CU_FUNC_CACHE_PREFER_EQUAL
#line 689
} CUfunc_cache; 
#line 698
typedef 
#line 694
enum CUsharedconfig_enum { 
#line 695
CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE, 
#line 696
CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE, 
#line 697
CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE
#line 698
} CUsharedconfig; 
#line 707
typedef 
#line 703
enum CUshared_carveout_enum { 
#line 704
CU_SHAREDMEM_CARVEOUT_DEFAULT = (-1), 
#line 705
CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100, 
#line 706
CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0
#line 707
} CUshared_carveout; 
#line 717
typedef 
#line 712
enum CUmemorytype_enum { 
#line 713
CU_MEMORYTYPE_HOST = 1, 
#line 714
CU_MEMORYTYPE_DEVICE, 
#line 715
CU_MEMORYTYPE_ARRAY, 
#line 716
CU_MEMORYTYPE_UNIFIED
#line 717
} CUmemorytype; 
#line 726
typedef 
#line 722
enum CUcomputemode_enum { 
#line 723
CU_COMPUTEMODE_DEFAULT, 
#line 724
CU_COMPUTEMODE_PROHIBITED = 2, 
#line 725
CU_COMPUTEMODE_EXCLUSIVE_PROCESS
#line 726
} CUcomputemode; 
#line 738
typedef 
#line 731
enum CUmem_advise_enum { 
#line 732
CU_MEM_ADVISE_SET_READ_MOSTLY = 1, 
#line 733
CU_MEM_ADVISE_UNSET_READ_MOSTLY, 
#line 734
CU_MEM_ADVISE_SET_PREFERRED_LOCATION, 
#line 735
CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION, 
#line 736
CU_MEM_ADVISE_SET_ACCESSED_BY, 
#line 737
CU_MEM_ADVISE_UNSET_ACCESSED_BY
#line 738
} CUmem_advise; 
#line 745
typedef 
#line 740
enum CUmem_range_attribute_enum { 
#line 741
CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1, 
#line 742
CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION, 
#line 743
CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY, 
#line 744
CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION
#line 745
} CUmem_range_attribute; 
#line 889
typedef 
#line 750
enum CUjit_option_enum { 
#line 757
CU_JIT_MAX_REGISTERS, 
#line 772
CU_JIT_THREADS_PER_BLOCK, 
#line 780
CU_JIT_WALL_TIME, 
#line 789
CU_JIT_INFO_LOG_BUFFER, 
#line 798
CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES, 
#line 807
CU_JIT_ERROR_LOG_BUFFER, 
#line 816
CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES, 
#line 824
CU_JIT_OPTIMIZATION_LEVEL, 
#line 832
CU_JIT_TARGET_FROM_CUCONTEXT, 
#line 840
CU_JIT_TARGET, 
#line 849
CU_JIT_FALLBACK_STRATEGY, 
#line 857
CU_JIT_GENERATE_DEBUG_INFO, 
#line 864
CU_JIT_LOG_VERBOSE, 
#line 871
CU_JIT_GENERATE_LINE_INFO, 
#line 879
CU_JIT_CACHE_MODE, 
#line 884
CU_JIT_NEW_SM3X_OPT, 
#line 885
CU_JIT_FAST_COMPILE, 
#line 887
CU_JIT_NUM_OPTIONS
#line 889
} CUjit_option; 
#line 911
typedef 
#line 894
enum CUjit_target_enum { 
#line 896
CU_TARGET_COMPUTE_20 = 20, 
#line 897
CU_TARGET_COMPUTE_21, 
#line 898
CU_TARGET_COMPUTE_30 = 30, 
#line 899
CU_TARGET_COMPUTE_32 = 32, 
#line 900
CU_TARGET_COMPUTE_35 = 35, 
#line 901
CU_TARGET_COMPUTE_37 = 37, 
#line 902
CU_TARGET_COMPUTE_50 = 50, 
#line 903
CU_TARGET_COMPUTE_52 = 52, 
#line 904
CU_TARGET_COMPUTE_53, 
#line 905
CU_TARGET_COMPUTE_60 = 60, 
#line 906
CU_TARGET_COMPUTE_61, 
#line 907
CU_TARGET_COMPUTE_62, 
#line 908
CU_TARGET_COMPUTE_70 = 70, 
#line 909
CU_TARGET_COMPUTE_73 = 73, 
#line 910
CU_TARGET_COMPUTE_75 = 75
#line 911
} CUjit_target; 
#line 922
typedef 
#line 916
enum CUjit_fallback_enum { 
#line 918
CU_PREFER_PTX, 
#line 920
CU_PREFER_BINARY
#line 922
} CUjit_fallback; 
#line 932
typedef 
#line 927
enum CUjit_cacheMode_enum { 
#line 929
CU_JIT_CACHE_OPTION_NONE, 
#line 930
CU_JIT_CACHE_OPTION_CG, 
#line 931
CU_JIT_CACHE_OPTION_CA
#line 932
} CUjit_cacheMode; 
#line 970
typedef 
#line 937
enum CUjitInputType_enum { 
#line 943
CU_JIT_INPUT_CUBIN, 
#line 949
CU_JIT_INPUT_PTX, 
#line 955
CU_JIT_INPUT_FATBINARY, 
#line 961
CU_JIT_INPUT_OBJECT, 
#line 967
CU_JIT_INPUT_LIBRARY, 
#line 969
CU_JIT_NUM_INPUT_TYPES
#line 970
} CUjitInputType; 
#line 973
typedef struct CUlinkState_st *CUlinkState; 
#line 985 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef 
#line 979
enum CUgraphicsRegisterFlags_enum { 
#line 980
CU_GRAPHICS_REGISTER_FLAGS_NONE, 
#line 981
CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY, 
#line 982
CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD, 
#line 983
CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4, 
#line 984
CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8
#line 985
} CUgraphicsRegisterFlags; 
#line 994
typedef 
#line 990
enum CUgraphicsMapResourceFlags_enum { 
#line 991
CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE, 
#line 992
CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY, 
#line 993
CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD
#line 994
} CUgraphicsMapResourceFlags; 
#line 1006
typedef 
#line 999
enum CUarray_cubemap_face_enum { 
#line 1000
CU_CUBEMAP_FACE_POSITIVE_X, 
#line 1001
CU_CUBEMAP_FACE_NEGATIVE_X, 
#line 1002
CU_CUBEMAP_FACE_POSITIVE_Y, 
#line 1003
CU_CUBEMAP_FACE_NEGATIVE_Y, 
#line 1004
CU_CUBEMAP_FACE_POSITIVE_Z, 
#line 1005
CU_CUBEMAP_FACE_NEGATIVE_Z
#line 1006
} CUarray_cubemap_face; 
#line 1018
typedef 
#line 1011
enum CUlimit_enum { 
#line 1012
CU_LIMIT_STACK_SIZE, 
#line 1013
CU_LIMIT_PRINTF_FIFO_SIZE, 
#line 1014
CU_LIMIT_MALLOC_HEAP_SIZE, 
#line 1015
CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH, 
#line 1016
CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT, 
#line 1017
CU_LIMIT_MAX
#line 1018
} CUlimit; 
#line 1028
typedef 
#line 1023
enum CUresourcetype_enum { 
#line 1024
CU_RESOURCE_TYPE_ARRAY, 
#line 1025
CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, 
#line 1026
CU_RESOURCE_TYPE_LINEAR, 
#line 1027
CU_RESOURCE_TYPE_PITCH2D
#line 1028
} CUresourcetype; 
#line 1442
typedef 
#line 1033
enum cudaError_enum { 
#line 1039
CUDA_SUCCESS, 
#line 1045
CUDA_ERROR_INVALID_VALUE, 
#line 1051
CUDA_ERROR_OUT_OF_MEMORY, 
#line 1057
CUDA_ERROR_NOT_INITIALIZED, 
#line 1062
CUDA_ERROR_DEINITIALIZED, 
#line 1069
CUDA_ERROR_PROFILER_DISABLED, 
#line 1077
CUDA_ERROR_PROFILER_NOT_INITIALIZED, 
#line 1084
CUDA_ERROR_PROFILER_ALREADY_STARTED, 
#line 1091
CUDA_ERROR_PROFILER_ALREADY_STOPPED, 
#line 1097
CUDA_ERROR_NO_DEVICE = 100, 
#line 1103
CUDA_ERROR_INVALID_DEVICE, 
#line 1110
CUDA_ERROR_INVALID_IMAGE = 200, 
#line 1120
CUDA_ERROR_INVALID_CONTEXT, 
#line 1129
CUDA_ERROR_CONTEXT_ALREADY_CURRENT, 
#line 1134
CUDA_ERROR_MAP_FAILED = 205, 
#line 1139
CUDA_ERROR_UNMAP_FAILED, 
#line 1145
CUDA_ERROR_ARRAY_IS_MAPPED, 
#line 1150
CUDA_ERROR_ALREADY_MAPPED, 
#line 1158
CUDA_ERROR_NO_BINARY_FOR_GPU, 
#line 1163
CUDA_ERROR_ALREADY_ACQUIRED, 
#line 1168
CUDA_ERROR_NOT_MAPPED, 
#line 1174
CUDA_ERROR_NOT_MAPPED_AS_ARRAY, 
#line 1180
CUDA_ERROR_NOT_MAPPED_AS_POINTER, 
#line 1186
CUDA_ERROR_ECC_UNCORRECTABLE, 
#line 1192
CUDA_ERROR_UNSUPPORTED_LIMIT, 
#line 1199
CUDA_ERROR_CONTEXT_ALREADY_IN_USE, 
#line 1205
CUDA_ERROR_PEER_ACCESS_UNSUPPORTED, 
#line 1210
CUDA_ERROR_INVALID_PTX, 
#line 1215
CUDA_ERROR_INVALID_GRAPHICS_CONTEXT, 
#line 1221
CUDA_ERROR_NVLINK_UNCORRECTABLE, 
#line 1226
CUDA_ERROR_JIT_COMPILER_NOT_FOUND, 
#line 1231
CUDA_ERROR_INVALID_SOURCE = 300, 
#line 1236
CUDA_ERROR_FILE_NOT_FOUND, 
#line 1241
CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND, 
#line 1246
CUDA_ERROR_SHARED_OBJECT_INIT_FAILED, 
#line 1251
CUDA_ERROR_OPERATING_SYSTEM, 
#line 1257
CUDA_ERROR_INVALID_HANDLE = 400, 
#line 1263
CUDA_ERROR_NOT_FOUND = 500, 
#line 1271
CUDA_ERROR_NOT_READY = 600, 
#line 1280
CUDA_ERROR_ILLEGAL_ADDRESS = 700, 
#line 1291
CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES, 
#line 1301
CUDA_ERROR_LAUNCH_TIMEOUT, 
#line 1307
CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING, 
#line 1314
CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED, 
#line 1321
CUDA_ERROR_PEER_ACCESS_NOT_ENABLED, 
#line 1327
CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708, 
#line 1334
CUDA_ERROR_CONTEXT_IS_DESTROYED, 
#line 1342
CUDA_ERROR_ASSERT, 
#line 1349
CUDA_ERROR_TOO_MANY_PEERS, 
#line 1355
CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED, 
#line 1361
CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED, 
#line 1370
CUDA_ERROR_HARDWARE_STACK_ERROR, 
#line 1378
CUDA_ERROR_ILLEGAL_INSTRUCTION, 
#line 1387
CUDA_ERROR_MISALIGNED_ADDRESS, 
#line 1398
CUDA_ERROR_INVALID_ADDRESS_SPACE, 
#line 1406
CUDA_ERROR_INVALID_PC, 
#line 1416
CUDA_ERROR_LAUNCH_FAILED, 
#line 1425
CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE, 
#line 1430
CUDA_ERROR_NOT_PERMITTED = 800, 
#line 1436
CUDA_ERROR_NOT_SUPPORTED, 
#line 1441
CUDA_ERROR_UNKNOWN = 999
#line 1442
} CUresult; 
#line 1451
typedef 
#line 1447
enum CUdevice_P2PAttribute_enum { 
#line 1448
CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1, 
#line 1449
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED, 
#line 1450
CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED
#line 1451
} CUdevice_P2PAttribute; 
#line 1465 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef void (__stdcall *CUstreamCallback)(CUstream hStream, CUresult status, void * userData); 
#line 1473
typedef size_t (__stdcall *CUoccupancyB2DSize)(int blockSize); 
#line 1549
typedef 
#line 1528
struct CUDA_MEMCPY2D_st { 
#line 1529
size_t srcXInBytes; 
#line 1530
size_t srcY; 
#line 1532
CUmemorytype srcMemoryType; 
#line 1533
const void *srcHost; 
#line 1534
CUdeviceptr srcDevice; 
#line 1535
CUarray srcArray; 
#line 1536
size_t srcPitch; 
#line 1538
size_t dstXInBytes; 
#line 1539
size_t dstY; 
#line 1541
CUmemorytype dstMemoryType; 
#line 1542
void *dstHost; 
#line 1543
CUdeviceptr dstDevice; 
#line 1544
CUarray dstArray; 
#line 1545
size_t dstPitch; 
#line 1547
size_t WidthInBytes; 
#line 1548
size_t Height; 
#line 1549
} CUDA_MEMCPY2D; 
#line 1582
typedef 
#line 1554
struct CUDA_MEMCPY3D_st { 
#line 1555
size_t srcXInBytes; 
#line 1556
size_t srcY; 
#line 1557
size_t srcZ; 
#line 1558
size_t srcLOD; 
#line 1559
CUmemorytype srcMemoryType; 
#line 1560
const void *srcHost; 
#line 1561
CUdeviceptr srcDevice; 
#line 1562
CUarray srcArray; 
#line 1563
void *reserved0; 
#line 1564
size_t srcPitch; 
#line 1565
size_t srcHeight; 
#line 1567
size_t dstXInBytes; 
#line 1568
size_t dstY; 
#line 1569
size_t dstZ; 
#line 1570
size_t dstLOD; 
#line 1571
CUmemorytype dstMemoryType; 
#line 1572
void *dstHost; 
#line 1573
CUdeviceptr dstDevice; 
#line 1574
CUarray dstArray; 
#line 1575
void *reserved1; 
#line 1576
size_t dstPitch; 
#line 1577
size_t dstHeight; 
#line 1579
size_t WidthInBytes; 
#line 1580
size_t Height; 
#line 1581
size_t Depth; 
#line 1582
} CUDA_MEMCPY3D; 
#line 1615
typedef 
#line 1587
struct CUDA_MEMCPY3D_PEER_st { 
#line 1588
size_t srcXInBytes; 
#line 1589
size_t srcY; 
#line 1590
size_t srcZ; 
#line 1591
size_t srcLOD; 
#line 1592
CUmemorytype srcMemoryType; 
#line 1593
const void *srcHost; 
#line 1594
CUdeviceptr srcDevice; 
#line 1595
CUarray srcArray; 
#line 1596
CUcontext srcContext; 
#line 1597
size_t srcPitch; 
#line 1598
size_t srcHeight; 
#line 1600
size_t dstXInBytes; 
#line 1601
size_t dstY; 
#line 1602
size_t dstZ; 
#line 1603
size_t dstLOD; 
#line 1604
CUmemorytype dstMemoryType; 
#line 1605
void *dstHost; 
#line 1606
CUdeviceptr dstDevice; 
#line 1607
CUarray dstArray; 
#line 1608
CUcontext dstContext; 
#line 1609
size_t dstPitch; 
#line 1610
size_t dstHeight; 
#line 1612
size_t WidthInBytes; 
#line 1613
size_t Height; 
#line 1614
size_t Depth; 
#line 1615
} CUDA_MEMCPY3D_PEER; 
#line 1627
typedef 
#line 1620
struct CUDA_ARRAY_DESCRIPTOR_st { 
#line 1622
size_t Width; 
#line 1623
size_t Height; 
#line 1625
CUarray_format Format; 
#line 1626
unsigned NumChannels; 
#line 1627
} CUDA_ARRAY_DESCRIPTOR; 
#line 1641
typedef 
#line 1632
struct CUDA_ARRAY3D_DESCRIPTOR_st { 
#line 1634
size_t Width; 
#line 1635
size_t Height; 
#line 1636
size_t Depth; 
#line 1638
CUarray_format Format; 
#line 1639
unsigned NumChannels; 
#line 1640
unsigned Flags; 
#line 1641
} CUDA_ARRAY3D_DESCRIPTOR; 
#line 1681 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef 
#line 1650
struct CUDA_RESOURCE_DESC_st { 
#line 1652
CUresourcetype resType; 
#line 1654
union { 
#line 1655
struct { 
#line 1656
CUarray hArray; 
#line 1657
} array; 
#line 1658
struct { 
#line 1659
CUmipmappedArray hMipmappedArray; 
#line 1660
} mipmap; 
#line 1661
struct { 
#line 1662
CUdeviceptr devPtr; 
#line 1663
CUarray_format format; 
#line 1664
unsigned numChannels; 
#line 1665
size_t sizeInBytes; 
#line 1666
} linear; 
#line 1667
struct { 
#line 1668
CUdeviceptr devPtr; 
#line 1669
CUarray_format format; 
#line 1670
unsigned numChannels; 
#line 1671
size_t width; 
#line 1672
size_t height; 
#line 1673
size_t pitchInBytes; 
#line 1674
} pitch2D; 
#line 1675
struct { 
#line 1676
int reserved[32]; 
#line 1677
} reserved; 
#line 1678
} res; 
#line 1680
unsigned flags; 
#line 1681
} CUDA_RESOURCE_DESC; 
#line 1697
typedef 
#line 1686
struct CUDA_TEXTURE_DESC_st { 
#line 1687
CUaddress_mode addressMode[3]; 
#line 1688
CUfilter_mode filterMode; 
#line 1689
unsigned flags; 
#line 1690
unsigned maxAnisotropy; 
#line 1691
CUfilter_mode mipmapFilterMode; 
#line 1692
float mipmapLevelBias; 
#line 1693
float minMipmapLevelClamp; 
#line 1694
float maxMipmapLevelClamp; 
#line 1695
float borderColor[4]; 
#line 1696
int reserved[12]; 
#line 1697
} CUDA_TEXTURE_DESC; 
#line 1739
typedef 
#line 1702
enum CUresourceViewFormat_enum { 
#line 1704
CU_RES_VIEW_FORMAT_NONE, 
#line 1705
CU_RES_VIEW_FORMAT_UINT_1X8, 
#line 1706
CU_RES_VIEW_FORMAT_UINT_2X8, 
#line 1707
CU_RES_VIEW_FORMAT_UINT_4X8, 
#line 1708
CU_RES_VIEW_FORMAT_SINT_1X8, 
#line 1709
CU_RES_VIEW_FORMAT_SINT_2X8, 
#line 1710
CU_RES_VIEW_FORMAT_SINT_4X8, 
#line 1711
CU_RES_VIEW_FORMAT_UINT_1X16, 
#line 1712
CU_RES_VIEW_FORMAT_UINT_2X16, 
#line 1713
CU_RES_VIEW_FORMAT_UINT_4X16, 
#line 1714
CU_RES_VIEW_FORMAT_SINT_1X16, 
#line 1715
CU_RES_VIEW_FORMAT_SINT_2X16, 
#line 1716
CU_RES_VIEW_FORMAT_SINT_4X16, 
#line 1717
CU_RES_VIEW_FORMAT_UINT_1X32, 
#line 1718
CU_RES_VIEW_FORMAT_UINT_2X32, 
#line 1719
CU_RES_VIEW_FORMAT_UINT_4X32, 
#line 1720
CU_RES_VIEW_FORMAT_SINT_1X32, 
#line 1721
CU_RES_VIEW_FORMAT_SINT_2X32, 
#line 1722
CU_RES_VIEW_FORMAT_SINT_4X32, 
#line 1723
CU_RES_VIEW_FORMAT_FLOAT_1X16, 
#line 1724
CU_RES_VIEW_FORMAT_FLOAT_2X16, 
#line 1725
CU_RES_VIEW_FORMAT_FLOAT_4X16, 
#line 1726
CU_RES_VIEW_FORMAT_FLOAT_1X32, 
#line 1727
CU_RES_VIEW_FORMAT_FLOAT_2X32, 
#line 1728
CU_RES_VIEW_FORMAT_FLOAT_4X32, 
#line 1729
CU_RES_VIEW_FORMAT_UNSIGNED_BC1, 
#line 1730
CU_RES_VIEW_FORMAT_UNSIGNED_BC2, 
#line 1731
CU_RES_VIEW_FORMAT_UNSIGNED_BC3, 
#line 1732
CU_RES_VIEW_FORMAT_UNSIGNED_BC4, 
#line 1733
CU_RES_VIEW_FORMAT_SIGNED_BC4, 
#line 1734
CU_RES_VIEW_FORMAT_UNSIGNED_BC5, 
#line 1735
CU_RES_VIEW_FORMAT_SIGNED_BC5, 
#line 1736
CU_RES_VIEW_FORMAT_UNSIGNED_BC6H, 
#line 1737
CU_RES_VIEW_FORMAT_SIGNED_BC6H, 
#line 1738
CU_RES_VIEW_FORMAT_UNSIGNED_BC7
#line 1739
} CUresourceViewFormat; 
#line 1755
typedef 
#line 1744
struct CUDA_RESOURCE_VIEW_DESC_st { 
#line 1746
CUresourceViewFormat format; 
#line 1747
size_t width; 
#line 1748
size_t height; 
#line 1749
size_t depth; 
#line 1750
unsigned firstMipmapLevel; 
#line 1751
unsigned lastMipmapLevel; 
#line 1752
unsigned firstLayer; 
#line 1753
unsigned lastLayer; 
#line 1754
unsigned reserved[16]; 
#line 1755
} CUDA_RESOURCE_VIEW_DESC; 
#line 1763
typedef 
#line 1760
struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st { 
#line 1761
unsigned __int64 p2pToken; 
#line 1762
unsigned vaSpaceToken; 
#line 1763
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS; 
#line 1783 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
typedef 
#line 1772
struct CUDA_LAUNCH_PARAMS_st { 
#line 1773
CUfunction function; 
#line 1774
unsigned gridDimX; 
#line 1775
unsigned gridDimY; 
#line 1776
unsigned gridDimZ; 
#line 1777
unsigned blockDimX; 
#line 1778
unsigned blockDimY; 
#line 1779
unsigned blockDimZ; 
#line 1780
unsigned sharedMemBytes; 
#line 1781
CUstream hStream; 
#line 1782
void **kernelParams; 
#line 1783
} CUDA_LAUNCH_PARAMS; 
#line 1946 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuGetErrorString(CUresult error, const char ** pStr); 
#line 1967
CUresult __stdcall cuGetErrorName(CUresult error, const char ** pStr); 
#line 1999
CUresult __stdcall cuInit(unsigned Flags); 
#line 2033
CUresult __stdcall cuDriverGetVersion(int * driverVersion); 
#line 2073
CUresult __stdcall cuDeviceGet(CUdevice * device, int ordinal); 
#line 2099
CUresult __stdcall cuDeviceGetCount(int * count); 
#line 2128
CUresult __stdcall cuDeviceGetName(char * name, int len, CUdevice dev); 
#line 2156
CUresult __stdcall cuDeviceTotalMem_v2(size_t * bytes, CUdevice dev); 
#line 2357 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuDeviceGetAttribute(int * pi, CUdevice_attribute attrib, CUdevice dev); 
#line 2434
CUresult __stdcall cuDeviceGetProperties(CUdevprop * prop, CUdevice dev); 
#line 2467
CUresult __stdcall cuDeviceComputeCapability(int * major, int * minor, CUdevice dev); 
#line 2535
CUresult __stdcall cuDevicePrimaryCtxRetain(CUcontext * pctx, CUdevice dev); 
#line 2569
CUresult __stdcall cuDevicePrimaryCtxRelease(CUdevice dev); 
#line 2633
CUresult __stdcall cuDevicePrimaryCtxSetFlags(CUdevice dev, unsigned flags); 
#line 2659
CUresult __stdcall cuDevicePrimaryCtxGetState(CUdevice dev, unsigned * flags, int * active); 
#line 2697
CUresult __stdcall cuDevicePrimaryCtxReset(CUdevice dev); 
#line 2803 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuCtxCreate_v2(CUcontext * pctx, unsigned flags, CUdevice dev); 
#line 2843 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuCtxDestroy_v2(CUcontext ctx); 
#line 2879 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuCtxPushCurrent_v2(CUcontext ctx); 
#line 2913
CUresult __stdcall cuCtxPopCurrent_v2(CUcontext * pctx); 
#line 2943
CUresult __stdcall cuCtxSetCurrent(CUcontext ctx); 
#line 2966
CUresult __stdcall cuCtxGetCurrent(CUcontext * pctx); 
#line 2997 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuCtxGetDevice(CUdevice * device); 
#line 3026
CUresult __stdcall cuCtxGetFlags(unsigned * flags); 
#line 3057 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuCtxSynchronize(); 
#line 3142
CUresult __stdcall cuCtxSetLimit(CUlimit limit, size_t value); 
#line 3182
CUresult __stdcall cuCtxGetLimit(size_t * pvalue, CUlimit limit); 
#line 3226
CUresult __stdcall cuCtxGetCacheConfig(CUfunc_cache * pconfig); 
#line 3277
CUresult __stdcall cuCtxSetCacheConfig(CUfunc_cache config); 
#line 3320
CUresult __stdcall cuCtxGetSharedMemConfig(CUsharedconfig * pConfig); 
#line 3373
CUresult __stdcall cuCtxSetSharedMemConfig(CUsharedconfig config); 
#line 3411 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuCtxGetApiVersion(CUcontext ctx, unsigned * version); 
#line 3451
CUresult __stdcall cuCtxGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
#line 3506
CUresult __stdcall cuCtxAttach(CUcontext * pctx, unsigned flags); 
#line 3542
CUresult __stdcall cuCtxDetach(CUcontext ctx); 
#line 3597
CUresult __stdcall cuModuleLoad(CUmodule * module, const char * fname); 
#line 3634
CUresult __stdcall cuModuleLoadData(CUmodule * module, const void * image); 
#line 3677
CUresult __stdcall cuModuleLoadDataEx(CUmodule * module, const void * image, unsigned numOptions, CUjit_option * options, void ** optionValues); 
#line 3719
CUresult __stdcall cuModuleLoadFatBinary(CUmodule * module, const void * fatCubin); 
#line 3744
CUresult __stdcall cuModuleUnload(CUmodule hmod); 
#line 3774
CUresult __stdcall cuModuleGetFunction(CUfunction * hfunc, CUmodule hmod, const char * name); 
#line 3810
CUresult __stdcall cuModuleGetGlobal_v2(CUdeviceptr * dptr, size_t * bytes, CUmodule hmod, const char * name); 
#line 3845 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuModuleGetTexRef(CUtexref * pTexRef, CUmodule hmod, const char * name); 
#line 3877
CUresult __stdcall cuModuleGetSurfRef(CUsurfref * pSurfRef, CUmodule hmod, const char * name); 
#line 3920
CUresult __stdcall cuLinkCreate_v2(unsigned numOptions, CUjit_option * options, void ** optionValues, CUlinkState * stateOut); 
#line 3957
CUresult __stdcall cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void * data, size_t size, const char * name, unsigned numOptions, CUjit_option * options, void ** optionValues); 
#line 3996
CUresult __stdcall cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char * path, unsigned numOptions, CUjit_option * options, void ** optionValues); 
#line 4023
CUresult __stdcall cuLinkComplete(CUlinkState state, void ** cubinOut, size_t * sizeOut); 
#line 4037
CUresult __stdcall cuLinkDestroy(CUlinkState state); 
#line 4086 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemGetInfo_v2(size_t * free, size_t * total); 
#line 4120
CUresult __stdcall cuMemAlloc_v2(CUdeviceptr * dptr, size_t bytesize); 
#line 4182
CUresult __stdcall cuMemAllocPitch_v2(CUdeviceptr * dptr, size_t * pPitch, size_t WidthInBytes, size_t Height, unsigned ElementSizeBytes); 
#line 4212
CUresult __stdcall cuMemFree_v2(CUdeviceptr dptr); 
#line 4246
CUresult __stdcall cuMemGetAddressRange_v2(CUdeviceptr * pbase, size_t * psize, CUdeviceptr dptr); 
#line 4293
CUresult __stdcall cuMemAllocHost_v2(void ** pp, size_t bytesize); 
#line 4324 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemFreeHost(void * p); 
#line 4406
CUresult __stdcall cuMemHostAlloc(void ** pp, size_t bytesize, unsigned Flags); 
#line 4460
CUresult __stdcall cuMemHostGetDevicePointer_v2(CUdeviceptr * pdptr, void * p, unsigned Flags); 
#line 4488 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemHostGetFlags(unsigned * pFlags, void * p); 
#line 4600
CUresult __stdcall cuMemAllocManaged(CUdeviceptr * dptr, size_t bytesize, unsigned flags); 
#line 4633 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuDeviceGetByPCIBusId(CUdevice * dev, const char * pciBusId); 
#line 4665
CUresult __stdcall cuDeviceGetPCIBusId(char * pciBusId, int len, CUdevice dev); 
#line 4708
CUresult __stdcall cuIpcGetEventHandle(CUipcEventHandle * pHandle, CUevent event); 
#line 4746
CUresult __stdcall cuIpcOpenEventHandle(CUevent * phEvent, CUipcEventHandle handle); 
#line 4784
CUresult __stdcall cuIpcGetMemHandle(CUipcMemHandle * pHandle, CUdeviceptr dptr); 
#line 4836
CUresult __stdcall cuIpcOpenMemHandle(CUdeviceptr * pdptr, CUipcMemHandle handle, unsigned Flags); 
#line 4868
CUresult __stdcall cuIpcCloseMemHandle(CUdeviceptr dptr); 
#line 4954 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemHostRegister_v2(void * p, size_t bytesize, unsigned Flags); 
#line 4980
CUresult __stdcall cuMemHostUnregister(void * p); 
#line 5019
CUresult __stdcall cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount); 
#line 5049
CUresult __stdcall cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount); 
#line 5087 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount); 
#line 5122
CUresult __stdcall cuMemcpyDtoH_v2(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount); 
#line 5158
CUresult __stdcall cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount); 
#line 5194
CUresult __stdcall cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount); 
#line 5232
CUresult __stdcall cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
#line 5268
CUresult __stdcall cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount); 
#line 5304
CUresult __stdcall cuMemcpyAtoH_v2(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
#line 5344
CUresult __stdcall cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
#line 5508
CUresult __stdcall cuMemcpy2D_v2(const CUDA_MEMCPY2D * pCopy); 
#line 5670
CUresult __stdcall cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D * pCopy); 
#line 5839
CUresult __stdcall cuMemcpy3D_v2(const CUDA_MEMCPY3D * pCopy); 
#line 5865 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER * pCopy); 
#line 5908
CUresult __stdcall cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream); 
#line 5940
CUresult __stdcall cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream); 
#line 5981 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount, CUstream hStream); 
#line 6020
CUresult __stdcall cuMemcpyDtoHAsync_v2(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
#line 6060
CUresult __stdcall cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
#line 6100
CUresult __stdcall cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount, CUstream hStream); 
#line 6140
CUresult __stdcall cuMemcpyAtoHAsync_v2(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream); 
#line 6308
CUresult __stdcall cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D * pCopy, CUstream hStream); 
#line 6481
CUresult __stdcall cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D * pCopy, CUstream hStream); 
#line 6509 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER * pCopy, CUstream hStream); 
#line 6546 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N); 
#line 6581
CUresult __stdcall cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N); 
#line 6616
CUresult __stdcall cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned ui, size_t N); 
#line 6656
CUresult __stdcall cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height); 
#line 6697
CUresult __stdcall cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height); 
#line 6738
CUresult __stdcall cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height); 
#line 6775
CUresult __stdcall cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream); 
#line 6812
CUresult __stdcall cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream); 
#line 6848
CUresult __stdcall cuMemsetD32Async(CUdeviceptr dstDevice, unsigned ui, size_t N, CUstream hStream); 
#line 6890
CUresult __stdcall cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream); 
#line 6933
CUresult __stdcall cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream); 
#line 6976
CUresult __stdcall cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height, CUstream hStream); 
#line 7080
CUresult __stdcall cuArrayCreate_v2(CUarray * pHandle, const CUDA_ARRAY_DESCRIPTOR * pAllocateArray); 
#line 7114
CUresult __stdcall cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
#line 7146 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuArrayDestroy(CUarray hArray); 
#line 7327
CUresult __stdcall cuArray3DCreate_v2(CUarray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pAllocateArray); 
#line 7364
CUresult __stdcall cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
#line 7509 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMipmappedArrayCreate(CUmipmappedArray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc, unsigned numMipmapLevels); 
#line 7539
CUresult __stdcall cuMipmappedArrayGetLevel(CUarray * pLevelArray, CUmipmappedArray hMipmappedArray, unsigned level); 
#line 7563
CUresult __stdcall cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray); 
#line 7810 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuPointerGetAttribute(void * data, CUpointer_attribute attribute, CUdeviceptr ptr); 
#line 7880 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuMemPrefetchAsync(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream); 
#line 7967
CUresult __stdcall cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device); 
#line 8025
CUresult __stdcall cuMemRangeGetAttribute(void * data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count); 
#line 8065
CUresult __stdcall cuMemRangeGetAttributes(void ** data, size_t * dataSizes, CUmem_range_attribute * attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count); 
#line 8109 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuPointerSetAttribute(const void * value, CUpointer_attribute attribute, CUdeviceptr ptr); 
#line 8153 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuPointerGetAttributes(unsigned numAttributes, CUpointer_attribute * attributes, void ** data, CUdeviceptr ptr); 
#line 8203 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuStreamCreate(CUstream * phStream, unsigned Flags); 
#line 8252
CUresult __stdcall cuStreamCreateWithPriority(CUstream * phStream, unsigned flags, int priority); 
#line 8283
CUresult __stdcall cuStreamGetPriority(CUstream hStream, int * priority); 
#line 8311
CUresult __stdcall cuStreamGetFlags(CUstream hStream, unsigned * flags); 
#line 8343
CUresult __stdcall cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned Flags); 
#line 8410
CUresult __stdcall cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void * userData, unsigned flags); 
#line 8490
CUresult __stdcall cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned flags); 
#line 8522 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuStreamQuery(CUstream hStream); 
#line 8550
CUresult __stdcall cuStreamSynchronize(CUstream hStream); 
#line 8580
CUresult __stdcall cuStreamDestroy_v2(CUstream hStream); 
#line 8637 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuEventCreate(CUevent * phEvent, unsigned Flags); 
#line 8678
CUresult __stdcall cuEventRecord(CUevent hEvent, CUstream hStream); 
#line 8710
CUresult __stdcall cuEventQuery(CUevent hEvent); 
#line 8741
CUresult __stdcall cuEventSynchronize(CUevent hEvent); 
#line 8771
CUresult __stdcall cuEventDestroy_v2(CUevent hEvent); 
#line 8816 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuEventElapsedTime(float * pMilliseconds, CUevent hStart, CUevent hEnd); 
#line 8854
CUresult __stdcall cuStreamWaitValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
#line 8891
CUresult __stdcall cuStreamWaitValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
#line 8927
CUresult __stdcall cuStreamWriteValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
#line 8963
CUresult __stdcall cuStreamWriteValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned flags); 
#line 8998
CUresult __stdcall cuStreamBatchMemOp(CUstream stream, unsigned count, CUstreamBatchMemOpParams * paramArray, unsigned flags); 
#line 9072 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuFuncGetAttribute(int * pi, CUfunction_attribute attrib, CUfunction hfunc); 
#line 9119
CUresult __stdcall cuFuncSetAttribute(CUfunction hfunc, CUfunction_attribute attrib, int value); 
#line 9164 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config); 
#line 9217
CUresult __stdcall cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config); 
#line 9332 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuLaunchKernel(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams, void ** extra); 
#line 9421 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuLaunchCooperativeKernel(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams); 
#line 9565
CUresult __stdcall cuLaunchCooperativeKernelMultiDevice(CUDA_LAUNCH_PARAMS * launchParamsList, unsigned numDevices, unsigned flags); 
#line 9617 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z); 
#line 9651
CUresult __stdcall cuFuncSetSharedSize(CUfunction hfunc, unsigned bytes); 
#line 9683
CUresult __stdcall cuParamSetSize(CUfunction hfunc, unsigned numbytes); 
#line 9716
CUresult __stdcall cuParamSeti(CUfunction hfunc, int offset, unsigned value); 
#line 9749
CUresult __stdcall cuParamSetf(CUfunction hfunc, int offset, float value); 
#line 9784
CUresult __stdcall cuParamSetv(CUfunction hfunc, int offset, void * ptr, unsigned numbytes); 
#line 9821
CUresult __stdcall cuLaunch(CUfunction f); 
#line 9860
CUresult __stdcall cuLaunchGrid(CUfunction f, int grid_width, int grid_height); 
#line 9907
CUresult __stdcall cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream); 
#line 9932
CUresult __stdcall cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef); 
#line 9972
CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize); 
#line 10014
CUresult __stdcall cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
#line 10066
CUresult __stdcall cuOccupancyMaxPotentialBlockSize(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit); 
#line 10112
CUresult __stdcall cuOccupancyMaxPotentialBlockSizeWithFlags(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned flags); 
#line 10156 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned Flags); 
#line 10184
CUresult __stdcall cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned Flags); 
#line 10229
CUresult __stdcall cuTexRefSetAddress_v2(size_t * ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes); 
#line 10282
CUresult __stdcall cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR * desc, CUdeviceptr dptr, size_t Pitch); 
#line 10316 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents); 
#line 10360
CUresult __stdcall cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am); 
#line 10394
CUresult __stdcall cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
#line 10428
CUresult __stdcall cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
#line 10455
CUresult __stdcall cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias); 
#line 10484
CUresult __stdcall cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp); 
#line 10512
CUresult __stdcall cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned maxAniso); 
#line 10546
CUresult __stdcall cuTexRefSetBorderColor(CUtexref hTexRef, float * pBorderColor); 
#line 10585
CUresult __stdcall cuTexRefSetFlags(CUtexref hTexRef, unsigned Flags); 
#line 10611
CUresult __stdcall cuTexRefGetAddress_v2(CUdeviceptr * pdptr, CUtexref hTexRef); 
#line 10637 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuTexRefGetArray(CUarray * phArray, CUtexref hTexRef); 
#line 10662
CUresult __stdcall cuTexRefGetMipmappedArray(CUmipmappedArray * phMipmappedArray, CUtexref hTexRef); 
#line 10688
CUresult __stdcall cuTexRefGetAddressMode(CUaddress_mode * pam, CUtexref hTexRef, int dim); 
#line 10712
CUresult __stdcall cuTexRefGetFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
#line 10738
CUresult __stdcall cuTexRefGetFormat(CUarray_format * pFormat, int * pNumChannels, CUtexref hTexRef); 
#line 10762
CUresult __stdcall cuTexRefGetMipmapFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
#line 10786
CUresult __stdcall cuTexRefGetMipmapLevelBias(float * pbias, CUtexref hTexRef); 
#line 10811
CUresult __stdcall cuTexRefGetMipmapLevelClamp(float * pminMipmapLevelClamp, float * pmaxMipmapLevelClamp, CUtexref hTexRef); 
#line 10835
CUresult __stdcall cuTexRefGetMaxAnisotropy(int * pmaxAniso, CUtexref hTexRef); 
#line 10862
CUresult __stdcall cuTexRefGetBorderColor(float * pBorderColor, CUtexref hTexRef); 
#line 10885
CUresult __stdcall cuTexRefGetFlags(unsigned * pFlags, CUtexref hTexRef); 
#line 10924
CUresult __stdcall cuTexRefCreate(CUtexref * pTexRef); 
#line 10944
CUresult __stdcall cuTexRefDestroy(CUtexref hTexRef); 
#line 10986
CUresult __stdcall cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned Flags); 
#line 11007
CUresult __stdcall cuSurfRefGetArray(CUarray * phArray, CUsurfref hSurfRef); 
#line 11231
CUresult __stdcall cuTexObjectCreate(CUtexObject * pTexObject, const CUDA_RESOURCE_DESC * pResDesc, const CUDA_TEXTURE_DESC * pTexDesc, const CUDA_RESOURCE_VIEW_DESC * pResViewDesc); 
#line 11251
CUresult __stdcall cuTexObjectDestroy(CUtexObject texObject); 
#line 11272
CUresult __stdcall cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUtexObject texObject); 
#line 11293
CUresult __stdcall cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC * pTexDesc, CUtexObject texObject); 
#line 11315
CUresult __stdcall cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC * pResViewDesc, CUtexObject texObject); 
#line 11358
CUresult __stdcall cuSurfObjectCreate(CUsurfObject * pSurfObject, const CUDA_RESOURCE_DESC * pResDesc); 
#line 11378
CUresult __stdcall cuSurfObjectDestroy(CUsurfObject surfObject); 
#line 11399
CUresult __stdcall cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUsurfObject surfObject); 
#line 11444 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuDeviceCanAccessPeer(int * canAccessPeer, CUdevice dev, CUdevice peerDev); 
#line 11495
CUresult __stdcall cuCtxEnablePeerAccess(CUcontext peerContext, unsigned Flags); 
#line 11522
CUresult __stdcall cuCtxDisablePeerAccess(CUcontext peerContext); 
#line 11564 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuDeviceGetP2PAttribute(int * value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice); 
#line 11610 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuGraphicsUnregisterResource(CUgraphicsResource resource); 
#line 11650
CUresult __stdcall cuGraphicsSubResourceGetMappedArray(CUarray * pArray, CUgraphicsResource resource, unsigned arrayIndex, unsigned mipLevel); 
#line 11683
CUresult __stdcall cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray * pMipmappedArray, CUgraphicsResource resource); 
#line 11720 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr * pDevPtr, size_t * pSize, CUgraphicsResource resource); 
#line 11762 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
CUresult __stdcall cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned flags); 
#line 11802
CUresult __stdcall cuGraphicsMapResources(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
#line 11839
CUresult __stdcall cuGraphicsUnmapResources(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
#line 11843
CUresult __stdcall cuGetExportTable(const void ** ppExportTable, const CUuuid * pExportTableId); 
#line 12168 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v9.1\\include\\cuda.h"
}
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\omp.h"
extern "C" {
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\omp.h"
typedef void *omp_lock_t; 
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\omp.h"
typedef void *omp_nest_lock_t; 
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\omp.h"
#pragma comment(lib, "vcompd")
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\omp.h"
__declspec(dllimport) void __cdecl 
#line 41
omp_set_num_threads(int _Num_threads); 
#line 45
__declspec(dllimport) int __cdecl 
#line 46
omp_get_num_threads(); 
#line 50
__declspec(dllimport) int __cdecl 
#line 51
omp_get_max_threads(); 
#line 55
__declspec(dllimport) int __cdecl 
#line 56
omp_get_thread_num(); 
#line 60
__declspec(dllimport) int __cdecl 
#line 61
omp_get_num_procs(); 
#line 65
__declspec(dllimport) void __cdecl 
#line 66
omp_set_dynamic(int _Dynamic_threads); 
#line 70
__declspec(dllimport) int __cdecl 
#line 71
omp_get_dynamic(); 
#line 75
__declspec(dllimport) int __cdecl 
#line 76
omp_in_parallel(); 
#line 80
__declspec(dllimport) void __cdecl 
#line 81
omp_set_nested(int _Nested); 
#line 85
__declspec(dllimport) int __cdecl 
#line 86
omp_get_nested(); 
#line 90
__declspec(dllimport) void __cdecl 
#line 91
omp_init_lock(omp_lock_t * _Lock); 
#line 95
__declspec(dllimport) void __cdecl 
#line 96
omp_destroy_lock(omp_lock_t * _Lock); 
#line 100
__declspec(dllimport) void __cdecl 
#line 101
omp_set_lock(omp_lock_t * _Lock); 
#line 105
__declspec(dllimport) void __cdecl 
#line 106
omp_unset_lock(omp_lock_t * _Lock); 
#line 110
__declspec(dllimport) int __cdecl 
#line 111
omp_test_lock(omp_lock_t * _Lock); 
#line 115
__declspec(dllimport) void __cdecl 
#line 116
omp_init_nest_lock(omp_nest_lock_t * _Lock); 
#line 120
__declspec(dllimport) void __cdecl 
#line 121
omp_destroy_nest_lock(omp_nest_lock_t * _Lock); 
#line 125
__declspec(dllimport) void __cdecl 
#line 126
omp_set_nest_lock(omp_nest_lock_t * _Lock); 
#line 130
__declspec(dllimport) void __cdecl 
#line 131
omp_unset_nest_lock(omp_nest_lock_t * _Lock); 
#line 135
__declspec(dllimport) int __cdecl 
#line 136
omp_test_nest_lock(omp_nest_lock_t * _Lock); 
#line 140
__declspec(dllimport) double __cdecl 
#line 141
omp_get_wtime(); 
#line 145
__declspec(dllimport) double __cdecl 
#line 146
omp_get_wtick(); 
#line 151
}
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdint.h"
typedef signed char int8_t; 
#line 18
typedef short int16_t; 
#line 19
typedef int int32_t; 
#line 20
typedef __int64 int64_t; 
#line 21
typedef unsigned char uint8_t; 
#line 22
typedef unsigned short uint16_t; 
#line 23
typedef unsigned uint32_t; 
#line 24
typedef unsigned __int64 uint64_t; 
#line 26
typedef signed char int_least8_t; 
#line 27
typedef short int_least16_t; 
#line 28
typedef int int_least32_t; 
#line 29
typedef __int64 int_least64_t; 
#line 30
typedef unsigned char uint_least8_t; 
#line 31
typedef unsigned short uint_least16_t; 
#line 32
typedef unsigned uint_least32_t; 
#line 33
typedef unsigned __int64 uint_least64_t; 
#line 35
typedef signed char int_fast8_t; 
#line 36
typedef int int_fast16_t; 
#line 37
typedef int int_fast32_t; 
#line 38
typedef __int64 int_fast64_t; 
#line 39
typedef unsigned char uint_fast8_t; 
#line 40
typedef unsigned uint_fast16_t; 
#line 41
typedef unsigned uint_fast32_t; 
#line 42
typedef unsigned __int64 uint_fast64_t; 
#line 44
typedef __int64 intmax_t; 
#line 45
typedef unsigned __int64 uintmax_t; 
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdint"
namespace std { 
#line 18
using ::int8_t;using ::int16_t;
#line 19
using ::int32_t;using ::int64_t;
#line 20
using ::uint8_t;using ::uint16_t;
#line 21
using ::uint32_t;using ::uint64_t;
#line 23
using ::int_least8_t;using ::int_least16_t;
#line 24
using ::int_least32_t;using ::int_least64_t;
#line 25
using ::uint_least8_t;using ::uint_least16_t;
#line 26
using ::uint_least32_t;using ::uint_least64_t;
#line 28
using ::int_fast8_t;using ::int_fast16_t;
#line 29
using ::int_fast32_t;using ::int_fast64_t;
#line 30
using ::uint_fast8_t;using ::uint_fast16_t;
#line 31
using ::uint_fast32_t;using ::uint_fast64_t;
#line 33
using ::intmax_t;using ::intptr_t;
#line 34
using ::uintmax_t;using ::uintptr_t;
#line 37
namespace tr1 { 
#line 38
using ::int8_t;using ::int16_t;
#line 39
using ::int32_t;using ::int64_t;
#line 40
using ::uint8_t;using ::uint16_t;
#line 41
using ::uint32_t;using ::uint64_t;
#line 43
using ::int_least8_t;using ::int_least16_t;
#line 44
using ::int_least32_t;using ::int_least64_t;
#line 45
using ::uint_least8_t;using ::uint_least16_t;
#line 46
using ::uint_least32_t;using ::uint_least64_t;
#line 48
using ::int_fast8_t;using ::int_fast16_t;
#line 49
using ::int_fast32_t;using ::int_fast64_t;
#line 50
using ::uint_fast8_t;using ::uint_fast16_t;
#line 51
using ::uint_fast32_t;using ::uint_fast64_t;
#line 53
using ::intmax_t;using ::intptr_t;
#line 54
using ::uintmax_t;using ::uintptr_t;
#line 55
}
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdint"
}
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ymath.h"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 16
extern "C" {
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ymath.h"
void __cdecl _Feraise(int); 
#line 41
typedef 
#line 36
union { 
#line 37
unsigned short _Word[8]; 
#line 38
float _Float; 
#line 39
double _Double; 
#line 40
long double _Long_double; 
#line 41
} _Dconst; 
#line 44
__declspec(dllimport) double __cdecl _Cosh(double, double); 
#line 45
__declspec(dllimport) short __cdecl _Dtest(double *); 
#line 46
__declspec(dllimport) double __cdecl _Sinh(double, double); 
#line 48
__declspec(dllimport) short __cdecl _Exp(double *, double, short); 
#line 49
__declspec(dllimport) extern _Dconst _Denorm, _Hugeval, _Inf, 
#line 50
_Nan, _Snan; 
#line 53
__declspec(dllimport) float __cdecl _FCosh(float, float); 
#line 54
__declspec(dllimport) short __cdecl _FDtest(float *); 
#line 55
__declspec(dllimport) float __cdecl _FSinh(float, float); 
#line 57
__declspec(dllimport) short __cdecl _FExp(float *, float, short); 
#line 58
__declspec(dllimport) extern _Dconst _FDenorm, _FInf, _FNan, _FSnan; 
#line 61
__declspec(dllimport) long double __cdecl _LCosh(long double, long double); 
#line 62
__declspec(dllimport) short __cdecl _LDtest(long double *); 
#line 63
__declspec(dllimport) long double __cdecl _LSinh(long double, long double); 
#line 65
__declspec(dllimport) short __cdecl _LExp(long double *, long double, short); 
#line 66
__declspec(dllimport) extern _Dconst _LDenorm, _LInf, _LNan, _LSnan; 
#line 70
}
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ymath.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h"
__declspec(dllimport) unsigned __cdecl _clearfp(); 
#line 228
#pragma warning(push)
#pragma warning(disable: 4141)
#line 232
__declspec(dllimport) unsigned __cdecl _controlfp(unsigned _NewValue, unsigned _Mask); 
#line 237
#pragma warning(pop)
#line 240
__declspec(dllimport) void __cdecl _set_controlfp(unsigned _NewValue, unsigned _Mask); 
#line 246
__declspec(dllimport) errno_t __cdecl _controlfp_s(unsigned * _CurrentState, unsigned _NewValue, unsigned _Mask); 
#line 253
__declspec(dllimport) unsigned __cdecl _statusfp(); 
#line 256
__declspec(dllimport) void __cdecl _fpreset(); 
#line 272
__declspec(dllimport) unsigned __cdecl _control87(unsigned _NewValue, unsigned _Mask); 
#line 289
__declspec(dllimport) int *__cdecl __fpecode(); 
#line 294
__declspec(dllimport) int __cdecl __fpe_flt_rounds(); 
#line 307
__declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); 
#line 308
__declspec(dllimport) double __cdecl _chgsign(double _X); 
#line 309
__declspec(dllimport) double __cdecl _scalb(double _X, long _Y); 
#line 310
__declspec(dllimport) double __cdecl _logb(double _X); 
#line 311
__declspec(dllimport) double __cdecl _nextafter(double _X, double _Y); 
#line 312
__declspec(dllimport) int __cdecl _finite(double _X); 
#line 313
__declspec(dllimport) int __cdecl _isnan(double _X); 
#line 314
__declspec(dllimport) int __cdecl _fpclass(double _X); 
#line 317
__declspec(dllimport) float __cdecl _scalbf(float _X, long _Y); 
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h"
__declspec(dllimport) void __cdecl fpreset(); 
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\float.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 26
__declspec(dllimport) errno_t __cdecl _cgetws_s(__wchar_t * _Buffer, size_t _BufferCount, size_t * _SizeRead); 
#line 32
extern "C++" {template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }}
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__declspec(dllimport) int __cdecl _cputws(const __wchar_t * _Buffer); 
#line 44
__declspec(dllimport) wint_t __cdecl _getwch(); 
#line 45
__declspec(dllimport) wint_t __cdecl _getwche(); 
#line 46
__declspec(dllimport) wint_t __cdecl _putwch(__wchar_t _Character); 
#line 47
__declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _Character); 
#line 49
__declspec(dllimport) wint_t __cdecl _getwch_nolock(); 
#line 50
__declspec(dllimport) wint_t __cdecl _getwche_nolock(); 
#line 51
__declspec(dllimport) wint_t __cdecl _putwch_nolock(__wchar_t _Character); 
#line 52
__declspec(dllimport) wint_t __cdecl _ungetwch_nolock(wint_t _Character); 
#line 62
__declspec(dllimport) int __cdecl __conio_common_vcwprintf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 70
__declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 78
__declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 86
__inline int __cdecl _vcwprintf_l(const __wchar_t *const 
#line 87
_Format, const _locale_t 
#line 88
_Locale, va_list 
#line 89
_ArgList) 
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 95
return __conio_common_vcwprintf(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 96
} 
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf(const __wchar_t *const 
#line 101
_Format, va_list 
#line 102
_ArgList) 
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 108
return _vcwprintf_l(_Format, 0, _ArgList); 
#line 109
} 
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s_l(const __wchar_t *const 
#line 114
_Format, const _locale_t 
#line 115
_Locale, va_list 
#line 116
_ArgList) 
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 122
return __conio_common_vcwprintf_s(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 123
} 
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s(const __wchar_t *const 
#line 128
_Format, va_list 
#line 129
_ArgList) 
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 135
return _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 136
} 
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p_l(const __wchar_t *const 
#line 141
_Format, const _locale_t 
#line 142
_Locale, va_list 
#line 143
_ArgList) 
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 149
return __conio_common_vcwprintf_p(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 150
} 
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p(const __wchar_t *const 
#line 155
_Format, va_list 
#line 156
_ArgList) 
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 162
return _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 163
} 
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_l(const __wchar_t *const 
#line 168
_Format, const _locale_t 
#line 169
_Locale, ...) 
#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 175
int _Result; 
#line 176
va_list _ArgList; 
#line 177
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 178
_Result = _vcwprintf_l(_Format, _Locale, _ArgList); 
#line 179
(void)(_ArgList = ((va_list)0)); 
#line 180
return _Result; 
#line 181
} 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf(const __wchar_t *const 
#line 186
_Format, ...) 
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 192
int _Result; 
#line 193
va_list _ArgList; 
#line 194
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 195
_Result = _vcwprintf_l(_Format, 0, _ArgList); 
#line 196
(void)(_ArgList = ((va_list)0)); 
#line 197
return _Result; 
#line 198
} 
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s_l(const __wchar_t *const 
#line 203
_Format, const _locale_t 
#line 204
_Locale, ...) 
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 210
int _Result; 
#line 211
va_list _ArgList; 
#line 212
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 213
_Result = _vcwprintf_s_l(_Format, _Locale, _ArgList); 
#line 214
(void)(_ArgList = ((va_list)0)); 
#line 215
return _Result; 
#line 216
} 
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s(const __wchar_t *const 
#line 221
_Format, ...) 
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 227
int _Result; 
#line 228
va_list _ArgList; 
#line 229
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 230
_Result = _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 231
(void)(_ArgList = ((va_list)0)); 
#line 232
return _Result; 
#line 233
} 
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p_l(const __wchar_t *const 
#line 238
_Format, const _locale_t 
#line 239
_Locale, ...) 
#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 245
int _Result; 
#line 246
va_list _ArgList; 
#line 247
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 248
_Result = _vcwprintf_p_l(_Format, _Locale, _ArgList); 
#line 249
(void)(_ArgList = ((va_list)0)); 
#line 250
return _Result; 
#line 251
} 
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p(const __wchar_t *const 
#line 256
_Format, ...) 
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 262
int _Result; 
#line 263
va_list _ArgList; 
#line 264
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 265
_Result = _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 266
(void)(_ArgList = ((va_list)0)); 
#line 267
return _Result; 
#line 268
} 
#line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__declspec(dllimport) int __cdecl __conio_common_vcwscanf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 287
__inline int __cdecl _vcwscanf_l(const __wchar_t *const 
#line 288
_Format, const _locale_t 
#line 289
_Locale, va_list 
#line 290
_ArgList) 
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 296
return __conio_common_vcwscanf(*__local_stdio_scanf_options(), _Format, _Locale, _ArgList); 
#line 299
} 
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf(const __wchar_t *const 
#line 304
_Format, va_list 
#line 305
_ArgList) 
#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vcwscanf_l(_Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s_l(const __wchar_t *const 
#line 320
_Format, const _locale_t 
#line 321
_Locale, va_list 
#line 322
_ArgList) 
#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 328
return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Format, _Locale, _ArgList); 
#line 331
} 
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s(const __wchar_t *const 
#line 336
_Format, va_list 
#line 337
_ArgList) 
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 343
return _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 344
} 
#line 348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_l(const __wchar_t *const 
#line 349
_Format, const _locale_t 
#line 350
_Locale, ...) 
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 356
int _Result; 
#line 357
va_list _ArgList; 
#line 358
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 360
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vcwscanf_l(_Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 365
(void)(_ArgList = ((va_list)0)); 
#line 366
return _Result; 
#line 367
} 
#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf(const __wchar_t *const 
#line 372
_Format, ...) 
#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 378
int _Result; 
#line 379
va_list _ArgList; 
#line 380
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 382
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vcwscanf_l(_Format, 0, _ArgList); 
#pragma warning(pop)
#line 387
(void)(_ArgList = ((va_list)0)); 
#line 388
return _Result; 
#line 389
} 
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s_l(const __wchar_t *const 
#line 394
_Format, const _locale_t 
#line 395
_Locale, ...) 
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 401
int _Result; 
#line 402
va_list _ArgList; 
#line 403
(void)(__vcrt_va_start_verify_argument_type< __crt_locale_pointers *const> (), ((void)__va_start(&_ArgList, _Locale))); 
#line 404
_Result = _vcwscanf_s_l(_Format, _Locale, _ArgList); 
#line 405
(void)(_ArgList = ((va_list)0)); 
#line 406
return _Result; 
#line 407
} 
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s(const __wchar_t *const 
#line 412
_Format, ...) 
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
{ 
#line 418
int _Result; 
#line 419
va_list _ArgList; 
#line 420
(void)(__vcrt_va_start_verify_argument_type< const __wchar_t *const> (), ((void)__va_start(&_ArgList, _Format))); 
#line 421
_Result = _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 422
(void)(_ArgList = ((va_list)0)); 
#line 423
return _Result; 
#line 424
} 
#line 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wconio.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"
__declspec(dllimport) const unsigned short *__cdecl __pctype_func(); 
#line 32
__declspec(dllimport) const wctype_t *__cdecl __pwctype_func(); 
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"
__declspec(dllimport) int __cdecl iswalnum(wint_t _C); 
#line 64
__declspec(dllimport) int __cdecl iswalpha(wint_t _C); 
#line 65
__declspec(dllimport) int __cdecl iswascii(wint_t _C); 
#line 66
__declspec(dllimport) int __cdecl iswblank(wint_t _C); 
#line 67
__declspec(dllimport) int __cdecl iswcntrl(wint_t _C); 
#line 70
__declspec(dllimport) int __cdecl iswdigit(wint_t _C); 
#line 72
__declspec(dllimport) int __cdecl iswgraph(wint_t _C); 
#line 73
__declspec(dllimport) int __cdecl iswlower(wint_t _C); 
#line 74
__declspec(dllimport) int __cdecl iswprint(wint_t _C); 
#line 75
__declspec(dllimport) int __cdecl iswpunct(wint_t _C); 
#line 76
__declspec(dllimport) int __cdecl iswspace(wint_t _C); 
#line 77
__declspec(dllimport) int __cdecl iswupper(wint_t _C); 
#line 78
__declspec(dllimport) int __cdecl iswxdigit(wint_t _C); 
#line 79
__declspec(dllimport) int __cdecl __iswcsymf(wint_t _C); 
#line 80
__declspec(dllimport) int __cdecl __iswcsym(wint_t _C); 
#line 82
__declspec(dllimport) int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale); 
#line 83
__declspec(dllimport) int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale); 
#line 84
__declspec(dllimport) int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale); 
#line 85
__declspec(dllimport) int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale); 
#line 86
__declspec(dllimport) int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale); 
#line 87
__declspec(dllimport) int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale); 
#line 88
__declspec(dllimport) int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale); 
#line 89
__declspec(dllimport) int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale); 
#line 90
__declspec(dllimport) int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale); 
#line 91
__declspec(dllimport) int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale); 
#line 92
__declspec(dllimport) int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale); 
#line 93
__declspec(dllimport) int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale); 
#line 94
__declspec(dllimport) int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale); 
#line 95
__declspec(dllimport) int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale); 
#line 98
__declspec(dllimport) wint_t __cdecl towupper(wint_t _C); 
#line 99
__declspec(dllimport) wint_t __cdecl towlower(wint_t _C); 
#line 100
__declspec(dllimport) int __cdecl iswctype(wint_t _C, wctype_t _Type); 
#line 102
__declspec(dllimport) wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale); 
#line 103
__declspec(dllimport) wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale); 
#line 104
__declspec(dllimport) int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale); 
#line 108
__declspec(dllimport) int __cdecl isleadbyte(int _C); 
#line 109
__declspec(dllimport) int __cdecl _isleadbyte_l(int _C, _locale_t _Locale); 
#line 111
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t _C, wctype_t _Type); 
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wctype.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wdirect.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 22
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetcwd(__wchar_t * _DstBuf, int _SizeInWords); 
#line 29
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetdcwd(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); 
#line 41
__declspec(dllimport) int __cdecl _wchdir(const __wchar_t * _Path); 
#line 46
__declspec(dllimport) int __cdecl _wmkdir(const __wchar_t * _Path); 
#line 51
__declspec(dllimport) int __cdecl _wrmdir(const __wchar_t * _Path); 
#line 57
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 17
#pragma warning(push)
#pragma warning(disable:4820)
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h"
typedef unsigned long _fsize_t; 
#line 36
struct _wfinddata32_t { 
#line 38
unsigned attrib; 
#line 39
__time32_t time_create; 
#line 40
__time32_t time_access; 
#line 41
__time32_t time_write; 
#line 42
_fsize_t size; 
#line 43
__wchar_t name[260]; 
#line 44
}; 
#line 46
struct _wfinddata32i64_t { 
#line 48
unsigned attrib; 
#line 49
__time32_t time_create; 
#line 50
__time32_t time_access; 
#line 51
__time32_t time_write; 
#line 52
__int64 size; 
#line 53
__wchar_t name[260]; 
#line 54
}; 
#line 56
struct _wfinddata64i32_t { 
#line 58
unsigned attrib; 
#line 59
__time64_t time_create; 
#line 60
__time64_t time_access; 
#line 61
__time64_t time_write; 
#line 62
_fsize_t size; 
#line 63
__wchar_t name[260]; 
#line 64
}; 
#line 66
struct _wfinddata64_t { 
#line 68
unsigned attrib; 
#line 69
__time64_t time_create; 
#line 70
__time64_t time_access; 
#line 71
__time64_t time_write; 
#line 72
__int64 size; 
#line 73
__wchar_t name[260]; 
#line 74
}; 
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h"
__declspec(dllimport) int __cdecl _waccess(const __wchar_t * _FileName, int _AccessMode); 
#line 102
__declspec(dllimport) errno_t __cdecl _waccess_s(const __wchar_t * _FileName, int _AccessMode); 
#line 108
__declspec(dllimport) int __cdecl _wchmod(const __wchar_t * _FileName, int _Mode); 
#line 114
__declspec(dllimport) int __cdecl _wcreat(const __wchar_t * _FileName, int _PermissionMode); 
#line 121
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(const __wchar_t * _FileName, _wfinddata32_t * _FindData); 
#line 128
__declspec(dllimport) int __cdecl _wfindnext32(intptr_t _FindHandle, _wfinddata32_t * _FindData); 
#line 133
__declspec(dllimport) int __cdecl _wunlink(const __wchar_t * _FileName); 
#line 138
__declspec(dllimport) int __cdecl _wrename(const __wchar_t * _OldFileName, const __wchar_t * _NewFileName); 
#line 143
__declspec(dllimport) errno_t __cdecl _wmktemp_s(__wchar_t * _TemplateName, size_t _SizeInWords); 
#line 148
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }}
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h"
__declspec(dllimport) __wchar_t *__cdecl _wmktemp(__wchar_t * _TemplateName); 
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h"
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(const __wchar_t * _FileName, _wfinddata32i64_t * _FindData); 
#line 168
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(const __wchar_t * _FileName, _wfinddata64i32_t * _FindData); 
#line 175
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(const __wchar_t * _FileName, _wfinddata64_t * _FindData); 
#line 182
__declspec(dllimport) int __cdecl _wfindnext32i64(intptr_t _FindHandle, _wfinddata32i64_t * _FindData); 
#line 189
__declspec(dllimport) int __cdecl _wfindnext64i32(intptr_t _FindHandle, _wfinddata64i32_t * _FindData); 
#line 196
__declspec(dllimport) int __cdecl _wfindnext64(intptr_t _FindHandle, _wfinddata64_t * _FindData); 
#line 202
__declspec(dllimport) errno_t __cdecl _wsopen_s(int * _FileHandle, const __wchar_t * _FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag); 
#line 210
__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(const __wchar_t * _FileName, int _OFlag, int _ShFlag, int _PMode, int * _PFileHandle, int _BSecure); 
#line 225
extern "C++" inline int __cdecl _wopen(const __wchar_t *
#line 226
_FileName, int 
#line 227
_OFlag, int 
#line 228
_PMode = 0) 
#line 230
{ 
#line 231
int _FileHandle; 
#line 233
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, 64, _PMode, &_FileHandle, 0); 
#line 234
return (_Result) ? -1 : _FileHandle; 
#line 235
} 
#line 238
extern "C++" inline int __cdecl _wsopen(const __wchar_t *
#line 239
_FileName, int 
#line 240
_OFlag, int 
#line 241
_ShFlag, int 
#line 242
_PMode = 0) 
#line 244
{ 
#line 245
int _FileHandle; 
#line 247
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0); 
#line 248
return (_Result) ? -1 : _FileHandle; 
#line 249
} 
#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wio.h"
}
#line 270
#pragma warning(pop)
#line 273
__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 20
__declspec(dllimport) intptr_t __cdecl _wexecl(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 25
__declspec(dllimport) intptr_t __cdecl _wexecle(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 30
__declspec(dllimport) intptr_t __cdecl _wexeclp(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 35
__declspec(dllimport) intptr_t __cdecl _wexeclpe(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 40
__declspec(dllimport) intptr_t __cdecl _wexecv(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 45
__declspec(dllimport) intptr_t __cdecl _wexecve(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 51
__declspec(dllimport) intptr_t __cdecl _wexecvp(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 56
__declspec(dllimport) intptr_t __cdecl _wexecvpe(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 62
__declspec(dllimport) intptr_t __cdecl _wspawnl(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 68
__declspec(dllimport) intptr_t __cdecl _wspawnle(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 74
__declspec(dllimport) intptr_t __cdecl _wspawnlp(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 80
__declspec(dllimport) intptr_t __cdecl _wspawnlpe(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 86
__declspec(dllimport) intptr_t __cdecl _wspawnv(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 92
__declspec(dllimport) intptr_t __cdecl _wspawnve(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 99
__declspec(dllimport) intptr_t __cdecl _wspawnvp(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 105
__declspec(dllimport) intptr_t __cdecl _wspawnvpe(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 112
__declspec(dllimport) int __cdecl _wsystem(const __wchar_t * _Command); 
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_wprocess.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h"
typedef unsigned short _ino_t; 
#line 18
typedef _ino_t ino_t; 
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h"
typedef unsigned _dev_t; 
#line 30
typedef _dev_t dev_t; 
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/types.h"
typedef long _off_t; 
#line 42
typedef _off_t off_t; 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 16
#pragma warning(push)
#pragma warning(disable: 4820)
#line 25
struct _stat32 { 
#line 27
_dev_t st_dev; 
#line 28
_ino_t st_ino; 
#line 29
unsigned short st_mode; 
#line 30
short st_nlink; 
#line 31
short st_uid; 
#line 32
short st_gid; 
#line 33
_dev_t st_rdev; 
#line 34
_off_t st_size; 
#line 35
__time32_t st_atime; 
#line 36
__time32_t st_mtime; 
#line 37
__time32_t st_ctime; 
#line 38
}; 
#line 40
struct _stat32i64 { 
#line 42
_dev_t st_dev; 
#line 43
_ino_t st_ino; 
#line 44
unsigned short st_mode; 
#line 45
short st_nlink; 
#line 46
short st_uid; 
#line 47
short st_gid; 
#line 48
_dev_t st_rdev; 
#line 49
__int64 st_size; 
#line 50
__time32_t st_atime; 
#line 51
__time32_t st_mtime; 
#line 52
__time32_t st_ctime; 
#line 53
}; 
#line 55
struct _stat64i32 { 
#line 57
_dev_t st_dev; 
#line 58
_ino_t st_ino; 
#line 59
unsigned short st_mode; 
#line 60
short st_nlink; 
#line 61
short st_uid; 
#line 62
short st_gid; 
#line 63
_dev_t st_rdev; 
#line 64
_off_t st_size; 
#line 65
__time64_t st_atime; 
#line 66
__time64_t st_mtime; 
#line 67
__time64_t st_ctime; 
#line 68
}; 
#line 70
struct _stat64 { 
#line 72
_dev_t st_dev; 
#line 73
_ino_t st_ino; 
#line 74
unsigned short st_mode; 
#line 75
short st_nlink; 
#line 76
short st_uid; 
#line 77
short st_gid; 
#line 78
_dev_t st_rdev; 
#line 79
__int64 st_size; 
#line 80
__time64_t st_atime; 
#line 81
__time64_t st_mtime; 
#line 82
__time64_t st_ctime; 
#line 83
}; 
#line 88
struct stat { 
#line 90
_dev_t st_dev; 
#line 91
_ino_t st_ino; 
#line 92
unsigned short st_mode; 
#line 93
short st_nlink; 
#line 94
short st_uid; 
#line 95
short st_gid; 
#line 96
_dev_t st_rdev; 
#line 97
_off_t st_size; 
#line 98
time_t st_atime; 
#line 99
time_t st_mtime; 
#line 100
time_t st_ctime; 
#line 101
}; 
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h"
__declspec(dllimport) int __cdecl _fstat32(int _FileHandle, struct _stat32 * _Stat); 
#line 160
__declspec(dllimport) int __cdecl _fstat32i64(int _FileHandle, struct _stat32i64 * _Stat); 
#line 165
__declspec(dllimport) int __cdecl _fstat64i32(int _FileHandle, struct _stat64i32 * _Stat); 
#line 170
__declspec(dllimport) int __cdecl _fstat64(int _FileHandle, struct _stat64 * _Stat); 
#line 175
__declspec(dllimport) int __cdecl _stat32(const char * _FileName, struct _stat32 * _Stat); 
#line 180
__declspec(dllimport) int __cdecl _stat32i64(const char * _FileName, struct _stat32i64 * _Stat); 
#line 185
__declspec(dllimport) int __cdecl _stat64i32(const char * _FileName, struct _stat64i32 * _Stat); 
#line 190
__declspec(dllimport) int __cdecl _stat64(const char * _FileName, struct _stat64 * _Stat); 
#line 195
__declspec(dllimport) int __cdecl _wstat32(const __wchar_t * _FileName, struct _stat32 * _Stat); 
#line 200
__declspec(dllimport) int __cdecl _wstat32i64(const __wchar_t * _FileName, struct _stat32i64 * _Stat); 
#line 205
__declspec(dllimport) int __cdecl _wstat64i32(const __wchar_t * _FileName, struct _stat64i32 * _Stat); 
#line 210
__declspec(dllimport) int __cdecl _wstat64(const __wchar_t * _FileName, struct _stat64 * _Stat); 
#line 234
static __inline int __cdecl fstat(const int _FileHandle, struct stat *const _Stat) 
#line 235
{ 
#line 236
typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0]; 
#line 237
return _fstat64i32(_FileHandle, (struct _stat64i32 *)_Stat); 
#line 238
} 
#line 239
static __inline int __cdecl stat(const char *const _FileName, struct stat *const _Stat) 
#line 240
{ 
#line 241
typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0]; 
#line 242
return _stat64i32(_FileName, (struct _stat64i32 *)_Stat); 
#line 243
} 
#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\sys/stat.h"
}
#line 249
#pragma warning(pop)
#line 252
__pragma( pack ( pop )) 
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 37
typedef __wchar_t _Wint_t; 
#line 44
__declspec(dllimport) __wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 50
__declspec(dllimport) _locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 57
__declspec(dllimport) wint_t __cdecl btowc(int _Ch); 
#line 61
__declspec(dllimport) size_t __cdecl mbrlen(const char * _Ch, size_t _SizeInBytes, mbstate_t * _State); 
#line 67
__declspec(dllimport) size_t __cdecl mbrtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SizeInBytes, mbstate_t * _State); 
#line 75
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s(size_t * _Retval, __wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State); 
#line 84
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], char const * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }}
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__declspec(dllimport) size_t __cdecl mbsrtowcs(__wchar_t * _Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State); 
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__declspec(dllimport) errno_t __cdecl wcrtomb_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, __wchar_t _Ch, mbstate_t * _State); 
#line 111
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }}
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__declspec(dllimport) size_t __cdecl wcrtomb(char * _Dest, __wchar_t _Source, mbstate_t * _State); 
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__declspec(dllimport) errno_t __cdecl wcsrtombs_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, const __wchar_t ** _Src, size_t _Size, mbstate_t * _State); 
#line 137
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t const * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }}
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__declspec(dllimport) size_t __cdecl wcsrtombs(char * _Dest, const __wchar_t ** _PSource, size_t _Count, mbstate_t * _State); 
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__declspec(dllimport) int __cdecl wctob(wint_t _WCh); 
#line 162
errno_t __cdecl wmemcpy_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 170
errno_t __cdecl wmemmove_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
__inline int __cdecl fwide(FILE *
#line 180
_F, int 
#line 181
_M) 
#line 183
{ 
#line 184
(void)_F; 
#line 185
return _M; 
#line 186
} 
#line 188
__inline int __cdecl mbsinit(const mbstate_t *
#line 189
_P) 
#line 191
{ 
#line 192
return (_P == (0)) || ((_P->_Wchar) == (0)); 
#line 193
} 
#line 195
__inline const __wchar_t *__cdecl wmemchr(const __wchar_t *
#line 196
_S, __wchar_t 
#line 197
_C, size_t 
#line 198
_N) 
#line 200
{ 
#line 201
for (; (0) < _N; (++_S), (--_N)) { 
#line 202
if ((*_S) == _C) { 
#line 203
return (const __wchar_t *)_S; }  }  
#line 205
return 0; 
#line 206
} 
#line 208
__inline int __cdecl wmemcmp(const __wchar_t *
#line 209
_S1, const __wchar_t *
#line 210
_S2, size_t 
#line 211
_N) 
#line 213
{ 
#line 214
for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
#line 215
if ((*_S1) != (*_S2)) { 
#line 216
return ((*_S1) < (*_S2)) ? -1 : 1; }  }  
#line 218
return 0; 
#line 219
} 
#line 224
__inline __wchar_t *__cdecl wmemcpy(__wchar_t *
#line 225
_S1, const __wchar_t *
#line 226
_S2, size_t 
#line 227
_N) 
#line 229
{ 
#pragma warning(push)
#pragma warning(disable : 4995 4996 6386)
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning(pop)
} 
#line 237
__inline __wchar_t *__cdecl wmemmove(__wchar_t *
#line 238
_S1, const __wchar_t *
#line 239
_S2, size_t 
#line 240
_N) 
#line 242
{ 
#pragma warning(push)
#pragma warning(disable : 4996 6386)
return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning(pop)
} 
#line 251
__inline __wchar_t *__cdecl wmemset(__wchar_t *
#line 252
_S, __wchar_t 
#line 253
_C, size_t 
#line 254
_N) 
#line 256
{ 
#line 257
__wchar_t *_Su = _S; 
#line 258
for (; (0) < _N; (++_Su), (--_N)) 
#line 259
{ 
#line 260
(*_Su) = _C; 
#line 261
}  
#line 262
return _S; 
#line 263
} 
#line 267
extern "C++" inline __wchar_t *__cdecl wmemchr(__wchar_t *
#line 268
_S, __wchar_t 
#line 269
_C, size_t 
#line 270
_N) 
#line 272
{ 
#line 273
const __wchar_t *const _SC = _S; 
#line 274
return const_cast< __wchar_t *>(wmemchr(_SC, _C, _N)); 
#line 275
} 
#line 283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\wchar.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cwchar"
extern "C" { typedef mbstate_t _Mbstatet; }
#line 19
namespace std { 
#line 20
using ::_Mbstatet;
#line 22
using ::mbstate_t;using ::tm;using ::wint_t;
#line 24
using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
#line 25
using ::fputws;using ::fwide;using ::fwprintf;
#line 26
using ::fwscanf;using ::getwc;using ::getwchar;
#line 27
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
#line 28
using ::mbsinit;using ::putwc;using ::putwchar;
#line 29
using ::swprintf;using ::swscanf;using ::ungetwc;
#line 30
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
#line 31
using ::wcrtomb;using ::wprintf;using ::wscanf;
#line 32
using ::wcsrtombs;using ::wcstol;using ::wcscat;
#line 33
using ::wcschr;using ::wcscmp;using ::wcscoll;
#line 34
using ::wcscpy;using ::wcscspn;using ::wcslen;
#line 35
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
#line 36
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;
#line 37
using ::wcstod;using ::wcstoul;using ::wcsstr;
#line 38
using ::wcstok;using ::wcsxfrm;using ::wctob;
#line 39
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
#line 40
using ::wmemmove;using ::wmemset;using ::wcsftime;
#line 42
using ::vfwscanf;using ::vswscanf;using ::vwscanf;
#line 43
using ::wcstof;using ::wcstold;
#line 44
using ::wcstoll;using ::wcstoull;
#line 45
}
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstddef"
namespace std { 
#line 18
using ::ptrdiff_t;
#line 19
}
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstddef"
namespace std { 
#line 24
typedef double max_align_t; 
#line 25
}
#line 27
using std::max_align_t;
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\initializer_list"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
template < class _Elem >
 class initializer_list
 {
public :
 typedef _Elem value_type;
 typedef const _Elem & reference;
 typedef const _Elem & const_reference;
 typedef size_t size_type;

 typedef const _Elem * iterator;
 typedef const _Elem * const_iterator;

 constexpr initializer_list ( ) noexcept
  : _First ( 0 ), _Last ( 0 )
  {
  }

 constexpr initializer_list ( const _Elem * _First_arg,
  const _Elem * _Last_arg ) noexcept
  : _First ( _First_arg ), _Last ( _Last_arg )
  {
  }

 constexpr const _Elem * begin ( ) const noexcept
  {
  return ( _First );
  }

 constexpr const _Elem * end ( ) const noexcept
  {
  return ( _Last );
  }

 constexpr size_t size ( ) const noexcept
  {
  return ( ( size_t ) ( _Last - _First ) );
  }

private :
 const _Elem * _First;
 const _Elem * _Last;
 };
#line 59
template < class _Elem > inline
 constexpr const _Elem * begin ( initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . begin ( ) );
 }
#line 66
template < class _Elem > inline
 constexpr const _Elem * end ( initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . end ( ) );
 }
#line 71
}
#line 73
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
#pragma warning(push,3)
#line 74 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\initializer_list"
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
#pragma pack ( push, 8 )
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
namespace std { 
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
template< bool , class 
#line 129
_Ty1, class 
#line 130
_Ty2> 
#line 131
struct _If { 
#line 133
typedef _Ty2 type; 
#line 134
}; 
#line 136
template< class _Ty1, class 
#line 137
_Ty2> 
#line 138
struct _If< true, _Ty1, _Ty2>  { 
#line 140
typedef _Ty1 type; 
#line 141
}; 
#line 143
template< class _Ty> 
#line 144
struct _Always_false { 
#line 146
static constexpr bool value = false; 
#line 147
}; 
#line 153
template< class _Arg, class 
#line 154
_Result> 
#line 155
struct unary_function { 
#line 157
typedef _Arg argument_type; 
#line 158
typedef _Result result_type; 
#line 159
}; 
#line 162
template< class _Arg1, class 
#line 163
_Arg2, class 
#line 164
_Result> 
#line 165
struct binary_function { 
#line 167
typedef _Arg1 first_argument_type; 
#line 168
typedef _Arg2 second_argument_type; 
#line 169
typedef _Result result_type; 
#line 170
}; 
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
template < class _Ty = void >
 struct plus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left + _Right );
  }
 };
#line 188
template < class _Ty = void >
 struct minus
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left - _Right );
  }
 };
#line 202
template < class _Ty = void >
 struct multiplies
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef _Ty result_type;

 constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left * _Right );
  }
 };
#line 216
template < class _Ty = void >
 struct equal_to
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left == _Right );
  }
 };
#line 230
template < class _Ty = void >
 struct less
 {
 typedef _Ty first_argument_type;
 typedef _Ty second_argument_type;
 typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left < _Right );
  }
 };
#line 245
template<> struct plus< void>  { 
#line 247
typedef int is_transparent; 
#line 249
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   + static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   + static_cast < _Ty2 && > ( _Right ) );
  }
#line 258
}; 
#line 262
template<> struct minus< void>  { 
#line 264
typedef int is_transparent; 
#line 266
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   - static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   - static_cast < _Ty2 && > ( _Right ) );
  }
#line 275
}; 
#line 279
template<> struct multiplies< void>  { 
#line 281
typedef int is_transparent; 
#line 283
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   * static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   * static_cast < _Ty2 && > ( _Right ) );
  }
#line 292
}; 
#line 296
template<> struct equal_to<>  { 
#line 298
typedef int is_transparent; 
#line 300
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   == static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   == static_cast < _Ty2 && > ( _Right ) );
  }
#line 309
}; 
#line 313
template<> struct less<>  { 
#line 315
typedef int is_transparent; 
#line 317
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   < static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   < static_cast < _Ty2 && > ( _Right ) );
  }
#line 326
}; 
#line 329
}
#line 333
namespace std { 
#line 335
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count) 
#line 336
{ 
#line 338
static_assert((sizeof(size_t) == (8)), "This code is for 64-bit size_t.");
#line 339
const size_t _FNV_offset_basis = 14695981039346656037Ui64; 
#line 340
const size_t _FNV_prime = 1099511628211Ui64; 
#line 348 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
size_t _Val = _FNV_offset_basis; 
#line 349
for (size_t _Next = (0); _Next < _Count; ++_Next) 
#line 350
{ 
#line 351
_Val ^= ((size_t)(_First[_Next])); 
#line 352
_Val *= _FNV_prime; 
#line 353
}  
#line 354
return _Val; 
#line 355
} 
#line 358
template < class _Kty >
 struct _Bitwise_hash
 {
 typedef _Kty argument_type;
 typedef size_t result_type;

 size_t operator ( ) ( const _Kty & _Keyval ) const
  {
  return ( _Hash_seq ( ( const unsigned char * ) & _Keyval, sizeof ( _Kty ) ) );
  }
 };
#line 371
template< class _Kty> 
#line 372
struct hash : public _Bitwise_hash< _Kty>  { 
#line 375
static constexpr bool _Value = __is_enum(_Kty); 
#line 376
static_assert(_Value, "The C++ Standard doesn\'t provide a hash for this type.");
#line 378
}; 
#line 380
template<> struct hash< bool>  : public _Bitwise_hash< bool>  { 
#line 383
}; 
#line 386
template<> struct hash< char>  : public _Bitwise_hash< char>  { 
#line 389
}; 
#line 392
template<> struct hash< signed char>  : public _Bitwise_hash< signed char>  { 
#line 395
}; 
#line 398
template<> struct hash< unsigned char>  : public _Bitwise_hash< unsigned char>  { 
#line 401
}; 
#line 404
template<> struct hash< char16_t>  : public _Bitwise_hash< char16_t>  { 
#line 407
}; 
#line 410
template<> struct hash< char32_t>  : public _Bitwise_hash< char32_t>  { 
#line 413
}; 
#line 417
template<> struct hash< __wchar_t>  : public _Bitwise_hash< __wchar_t>  { 
#line 420
}; 
#line 424 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
template<> struct hash< short>  : public _Bitwise_hash< short>  { 
#line 427
}; 
#line 430
template<> struct hash< unsigned short>  : public _Bitwise_hash< unsigned short>  { 
#line 433
}; 
#line 436
template<> struct hash< int>  : public _Bitwise_hash< int>  { 
#line 439
}; 
#line 442
template<> struct hash< unsigned>  : public _Bitwise_hash< unsigned>  { 
#line 445
}; 
#line 448
template<> struct hash< long>  : public _Bitwise_hash< long>  { 
#line 451
}; 
#line 454
template<> struct hash< unsigned long>  : public _Bitwise_hash< unsigned long>  { 
#line 457
}; 
#line 460
template<> struct hash< __int64>  : public _Bitwise_hash< __int64>  { 
#line 463
}; 
#line 466
template<> struct hash< unsigned __int64>  : public _Bitwise_hash< unsigned __int64>  { 
#line 469
}; 
#line 472
template<> struct hash< float>  : public _Bitwise_hash< float>  { 
#line 475
typedef float _Kty; 
#line 476
typedef std::_Bitwise_hash< float>  _Mybase; 
#line 478
size_t operator()(const _Kty &_Keyval) const 
#line 479
{ 
#line 480
return this->_Mybase::operator()((_Keyval == (0)) ? 0 : _Keyval); 
#line 482
} 
#line 483
}; 
#line 486
template<> struct hash< double>  : public _Bitwise_hash< double>  { 
#line 489
typedef double _Kty; 
#line 490
typedef std::_Bitwise_hash< double>  _Mybase; 
#line 492
size_t operator()(const _Kty &_Keyval) const 
#line 493
{ 
#line 494
return this->_Mybase::operator()((_Keyval == (0)) ? 0 : _Keyval); 
#line 496
} 
#line 497
}; 
#line 500
template<> struct hash< long double>  : public _Bitwise_hash< long double>  { 
#line 503
typedef long double _Kty; 
#line 504
typedef std::_Bitwise_hash< long double>  _Mybase; 
#line 506
size_t operator()(const _Kty &_Keyval) const 
#line 507
{ 
#line 508
return this->_Mybase::operator()((_Keyval == (0)) ? 0 : _Keyval); 
#line 510
} 
#line 511
}; 
#line 513
template< class _Ty> 
#line 514
struct hash< _Ty *>  : public _Bitwise_hash< _Ty *>  { 
#line 517
}; 
#line 518
}
#line 522 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
namespace std { 
#line 523
namespace tr1 { 
#line 524
using std::hash;
#line 525
}
#line 526
}
#line 633 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
namespace std { 
#line 635
template< class ..._Types> 
#line 636
struct _Arg_types { 
#line 638
}; 
#line 640
template< class _Ty1> 
#line 641
struct _Arg_types< _Ty1>  { 
#line 643
typedef _Ty1 argument_type; 
#line 644
}; 
#line 646
template< class _Ty1, class 
#line 647
_Ty2> 
#line 648
struct _Arg_types< _Ty1, _Ty2>  { 
#line 650
typedef _Ty1 first_argument_type; 
#line 651
typedef _Ty2 second_argument_type; 
#line 652
}; 
#line 655
template< class _Ty> 
#line 656
struct _Is_function { 
#line 658
typedef false_type _Bool_type; 
#line 659
static constexpr bool _Weird = false; 
#line 660
}; 
#line 673
template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...)>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...)>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) volatile>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) volatile>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const volatile>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const volatile>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) volatile &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) volatile &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; 
#line 686
template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...)>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) volatile>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const volatile>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) &>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const &>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) volatile &>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const volatile &>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) &&>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const &&>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) volatile &&>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const volatile &&>  { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; 
#line 689
template< class _Ty> 
#line 690
struct is_function : public _Is_function< _Ty> ::_Bool_type { 
#line 693
}; 
#line 696
template< class _Ty> constexpr bool 
#line 697
is_function_v = (is_function< _Ty> ::value); 
#line 722 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
template < class _Ty > inline
 constexpr _Ty * addressof ( _Ty & _Val ) noexcept
 {
 return ( __builtin_addressof ( _Val ) );
 }
#line 731 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
template < class _Ptrty > inline
 auto _Unfancy ( _Ptrty _Ptr )
 {
 return ( :: std :: addressof ( * _Ptr ) );
 }
#line 737
template < class _Ty > inline
 _Ty * _Unfancy ( _Ty * _Ptr )
 {
 return ( _Ptr );
 }
#line 743
}
#line 745
#pragma warning(pop)
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
#pragma warning(push,3)
#line 746 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstddef"
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 57
typedef 
#line 53
enum { 
#line 54
denorm_indeterminate = (-1), 
#line 55
denorm_absent = 0, 
#line 56
denorm_present
#line 57
} float_denorm_style; 
#line 67
typedef 
#line 61
enum { 
#line 62
round_indeterminate = (-1), 
#line 63
round_toward_zero = 0, 
#line 64
round_to_nearest, 
#line 65
round_toward_infinity, 
#line 66
round_toward_neg_infinity
#line 67
} float_round_style; 
#line 70
struct _Num_base { 
#line 72
static constexpr float_denorm_style has_denorm = ((float_denorm_style)denorm_absent); 
#line 73
static constexpr bool has_denorm_loss = ((bool)false); 
#line 74
static constexpr bool has_infinity = ((bool)false); 
#line 75
static constexpr bool has_quiet_NaN = ((bool)false); 
#line 76
static constexpr bool has_signaling_NaN = ((bool)false); 
#line 77
static constexpr bool is_bounded = ((bool)false); 
#line 78
static constexpr bool is_exact = ((bool)false); 
#line 79
static constexpr bool is_iec559 = ((bool)false); 
#line 80
static constexpr bool is_integer = ((bool)false); 
#line 81
static constexpr bool is_modulo = ((bool)false); 
#line 82
static constexpr bool is_signed = ((bool)false); 
#line 83
static constexpr bool is_specialized = ((bool)false); 
#line 84
static constexpr bool tinyness_before = ((bool)false); 
#line 85
static constexpr bool traps = ((bool)false); 
#line 86
static constexpr float_round_style round_style = ((float_round_style)round_toward_zero); 
#line 87
static constexpr int digits = ((int)0); 
#line 88
static constexpr int digits10 = ((int)0); 
#line 90
static constexpr int max_digits10 = ((int)0); 
#line 92
static constexpr int max_exponent = ((int)0); 
#line 93
static constexpr int max_exponent10 = ((int)0); 
#line 94
static constexpr int min_exponent = ((int)0); 
#line 95
static constexpr int min_exponent10 = ((int)0); 
#line 96
static constexpr int radix = ((int)0); 
#line 97
}; 
#line 100
template < class _Ty >
 class numeric_limits
  : public _Num_base
 {
public :
 static constexpr _Ty ( min ) ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty ( max ) ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty lowest ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty epsilon ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty round_error ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty denorm_min ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty infinity ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty quiet_NaN ( ) noexcept
  {
  return ( _Ty ( ) );
  }

 static constexpr _Ty signaling_NaN ( ) noexcept
  {
  return ( _Ty ( ) );
  }
 };
#line 151
template< class _Ty> 
#line 152
class numeric_limits< const _Ty>  : public numeric_limits< _Ty>  { 
#line 155
}; 
#line 157
template< class _Ty> 
#line 158
class numeric_limits< volatile _Ty>  : public numeric_limits< _Ty>  { 
#line 161
}; 
#line 163
template< class _Ty> 
#line 164
class numeric_limits< const volatile _Ty>  : public numeric_limits< _Ty>  { 
#line 167
}; 
#line 170
struct _Num_int_base : public _Num_base { 
#line 173
static constexpr bool is_bounded = ((bool)true); 
#line 174
static constexpr bool is_exact = ((bool)true); 
#line 175
static constexpr bool is_integer = ((bool)true); 
#line 176
static constexpr bool is_modulo = ((bool)true); 
#line 177
static constexpr bool is_specialized = ((bool)true); 
#line 178
static constexpr int radix = ((int)2); 
#line 179
}; 
#line 182
struct _Num_float_base : public _Num_base { 
#line 185
static constexpr float_denorm_style has_denorm = ((float_denorm_style)denorm_present); 
#line 186
static constexpr bool has_denorm_loss = ((bool)true); 
#line 187
static constexpr bool has_infinity = ((bool)true); 
#line 188
static constexpr bool has_quiet_NaN = ((bool)true); 
#line 189
static constexpr bool has_signaling_NaN = ((bool)true); 
#line 190
static constexpr bool is_bounded = ((bool)true); 
#line 191
static constexpr bool is_exact = ((bool)false); 
#line 192
static constexpr bool is_iec559 = ((bool)true); 
#line 193
static constexpr bool is_integer = ((bool)false); 
#line 194
static constexpr bool is_modulo = ((bool)false); 
#line 195
static constexpr bool is_signed = ((bool)true); 
#line 196
static constexpr bool is_specialized = ((bool)true); 
#line 197
static constexpr bool tinyness_before = ((bool)true); 
#line 198
static constexpr bool traps = ((bool)false); 
#line 199
static constexpr float_round_style round_style = ((float_round_style)round_to_nearest); 
#line 200
static constexpr int radix = ((int)2); 
#line 201
}; 
#line 204
template<> class numeric_limits< char>  : public _Num_int_base { 
#line 208
public: typedef char _Ty; 
#line 210
static constexpr _Ty min() noexcept 
#line 211
{ 
#line 212
return -128; 
#line 213
} 
#line 215
static constexpr _Ty max() noexcept 
#line 216
{ 
#line 217
return 127; 
#line 218
} 
#line 220
static constexpr _Ty lowest() noexcept 
#line 221
{ 
#line 222
return min(); 
#line 223
} 
#line 225
static constexpr _Ty epsilon() noexcept 
#line 226
{ 
#line 227
return 0; 
#line 228
} 
#line 230
static constexpr _Ty round_error() noexcept 
#line 231
{ 
#line 232
return 0; 
#line 233
} 
#line 235
static constexpr _Ty denorm_min() noexcept 
#line 236
{ 
#line 237
return 0; 
#line 238
} 
#line 240
static constexpr _Ty infinity() noexcept 
#line 241
{ 
#line 242
return 0; 
#line 243
} 
#line 245
static constexpr _Ty quiet_NaN() noexcept 
#line 246
{ 
#line 247
return 0; 
#line 248
} 
#line 250
static constexpr _Ty signaling_NaN() noexcept 
#line 251
{ 
#line 252
return 0; 
#line 253
} 
#line 255
static constexpr bool is_signed = ((bool)((-128) != 0)); 
#line 256
static constexpr int digits = ((int)(8 - (((-128) != 0) ? 1 : 0))); 
#line 257
static constexpr int digits10 = ((int)(((8 - (((-128) != 0) ? 1 : 0)) * 301L) / (1000))); 
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 262
template<> class numeric_limits< __wchar_t>  : public _Num_int_base { 
#line 266
public: typedef __wchar_t _Ty; 
#line 268
static constexpr _Ty min() noexcept 
#line 269
{ 
#line 270
return (_Ty)0; 
#line 271
} 
#line 273
static constexpr _Ty max() noexcept 
#line 274
{ 
#line 275
return (_Ty)65535; 
#line 276
} 
#line 278
static constexpr _Ty lowest() noexcept 
#line 279
{ 
#line 280
return min(); 
#line 281
} 
#line 283
static constexpr _Ty epsilon() noexcept 
#line 284
{ 
#line 285
return 0; 
#line 286
} 
#line 288
static constexpr _Ty round_error() noexcept 
#line 289
{ 
#line 290
return 0; 
#line 291
} 
#line 293
static constexpr _Ty denorm_min() noexcept 
#line 294
{ 
#line 295
return 0; 
#line 296
} 
#line 298
static constexpr _Ty infinity() noexcept 
#line 299
{ 
#line 300
return 0; 
#line 301
} 
#line 303
static constexpr _Ty quiet_NaN() noexcept 
#line 304
{ 
#line 305
return 0; 
#line 306
} 
#line 308
static constexpr _Ty signaling_NaN() noexcept 
#line 309
{ 
#line 310
return 0; 
#line 311
} 
#line 313
static constexpr bool is_signed = ((bool)(0 != 0)); 
#line 314
static constexpr int digits = ((int)(((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0))); 
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
static constexpr int digits10 = ((int)(((((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0)) * (301L)) / (1000))); 
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 321
template<> class numeric_limits< bool>  : public _Num_int_base { 
#line 325
public: typedef bool _Ty; 
#line 327
static constexpr _Ty min() noexcept 
#line 328
{ 
#line 329
return false; 
#line 330
} 
#line 332
static constexpr _Ty max() noexcept 
#line 333
{ 
#line 334
return true; 
#line 335
} 
#line 337
static constexpr _Ty lowest() noexcept 
#line 338
{ 
#line 339
return min(); 
#line 340
} 
#line 342
static constexpr _Ty epsilon() noexcept 
#line 343
{ 
#line 344
return 0; 
#line 345
} 
#line 347
static constexpr _Ty round_error() noexcept 
#line 348
{ 
#line 349
return 0; 
#line 350
} 
#line 352
static constexpr _Ty denorm_min() noexcept 
#line 353
{ 
#line 354
return 0; 
#line 355
} 
#line 357
static constexpr _Ty infinity() noexcept 
#line 358
{ 
#line 359
return 0; 
#line 360
} 
#line 362
static constexpr _Ty quiet_NaN() noexcept 
#line 363
{ 
#line 364
return 0; 
#line 365
} 
#line 367
static constexpr _Ty signaling_NaN() noexcept 
#line 368
{ 
#line 369
return 0; 
#line 370
} 
#line 372
static constexpr bool is_modulo = ((bool)false); 
#line 373
static constexpr bool is_signed = ((bool)false); 
#line 374
static constexpr int digits = ((int)1); 
#line 375
static constexpr int digits10 = ((int)0); 
#line 376
}; 
#line 379
template<> class numeric_limits< signed char>  : public _Num_int_base { 
#line 383
public: typedef signed char _Ty; 
#line 385
static constexpr _Ty min() noexcept 
#line 386
{ 
#line 387
return -128; 
#line 388
} 
#line 390
static constexpr _Ty max() noexcept 
#line 391
{ 
#line 392
return 127; 
#line 393
} 
#line 395
static constexpr _Ty lowest() noexcept 
#line 396
{ 
#line 397
return min(); 
#line 398
} 
#line 400
static constexpr _Ty epsilon() noexcept 
#line 401
{ 
#line 402
return 0; 
#line 403
} 
#line 405
static constexpr _Ty round_error() noexcept 
#line 406
{ 
#line 407
return 0; 
#line 408
} 
#line 410
static constexpr _Ty denorm_min() noexcept 
#line 411
{ 
#line 412
return 0; 
#line 413
} 
#line 415
static constexpr _Ty infinity() noexcept 
#line 416
{ 
#line 417
return 0; 
#line 418
} 
#line 420
static constexpr _Ty quiet_NaN() noexcept 
#line 421
{ 
#line 422
return 0; 
#line 423
} 
#line 425
static constexpr _Ty signaling_NaN() noexcept 
#line 426
{ 
#line 427
return 0; 
#line 428
} 
#line 430
static constexpr bool is_signed = ((bool)true); 
#line 431
static constexpr int digits = ((int)(8 - 1)); 
#line 432
static constexpr int digits10 = ((int)(((8 - 1) * 301L) / (1000))); 
#line 433
}; 
#line 436
template<> class numeric_limits< unsigned char>  : public _Num_int_base { 
#line 440
public: typedef unsigned char _Ty; 
#line 442
static constexpr _Ty min() noexcept 
#line 443
{ 
#line 444
return 0; 
#line 445
} 
#line 447
static constexpr _Ty max() noexcept 
#line 448
{ 
#line 449
return 255; 
#line 450
} 
#line 452
static constexpr _Ty lowest() noexcept 
#line 453
{ 
#line 454
return min(); 
#line 455
} 
#line 457
static constexpr _Ty epsilon() noexcept 
#line 458
{ 
#line 459
return 0; 
#line 460
} 
#line 462
static constexpr _Ty round_error() noexcept 
#line 463
{ 
#line 464
return 0; 
#line 465
} 
#line 467
static constexpr _Ty denorm_min() noexcept 
#line 468
{ 
#line 469
return 0; 
#line 470
} 
#line 472
static constexpr _Ty infinity() noexcept 
#line 473
{ 
#line 474
return 0; 
#line 475
} 
#line 477
static constexpr _Ty quiet_NaN() noexcept 
#line 478
{ 
#line 479
return 0; 
#line 480
} 
#line 482
static constexpr _Ty signaling_NaN() noexcept 
#line 483
{ 
#line 484
return 0; 
#line 485
} 
#line 487
static constexpr bool is_signed = ((bool)false); 
#line 488
static constexpr int digits = ((int)8); 
#line 489
static constexpr int digits10 = ((int)(((8) * 301L) / (1000))); 
#line 490
}; 
#line 493
template<> class numeric_limits< short>  : public _Num_int_base { 
#line 497
public: typedef short _Ty; 
#line 499
static constexpr _Ty min() noexcept 
#line 500
{ 
#line 501
return -32768; 
#line 502
} 
#line 504
static constexpr _Ty max() noexcept 
#line 505
{ 
#line 506
return 32767; 
#line 507
} 
#line 509
static constexpr _Ty lowest() noexcept 
#line 510
{ 
#line 511
return min(); 
#line 512
} 
#line 514
static constexpr _Ty epsilon() noexcept 
#line 515
{ 
#line 516
return 0; 
#line 517
} 
#line 519
static constexpr _Ty round_error() noexcept 
#line 520
{ 
#line 521
return 0; 
#line 522
} 
#line 524
static constexpr _Ty denorm_min() noexcept 
#line 525
{ 
#line 526
return 0; 
#line 527
} 
#line 529
static constexpr _Ty infinity() noexcept 
#line 530
{ 
#line 531
return 0; 
#line 532
} 
#line 534
static constexpr _Ty quiet_NaN() noexcept 
#line 535
{ 
#line 536
return 0; 
#line 537
} 
#line 539
static constexpr _Ty signaling_NaN() noexcept 
#line 540
{ 
#line 541
return 0; 
#line 542
} 
#line 544
static constexpr bool is_signed = ((bool)true); 
#line 545
static constexpr int digits = ((int)(((8) * sizeof(short)) - (1))); 
#line 546
static constexpr int digits10 = ((int)(((((8) * sizeof(short)) - (1)) * (301L)) / (1000))); 
#line 548 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 552
template<> class numeric_limits< unsigned short>  : public _Num_int_base { 
#line 556
public: typedef unsigned short _Ty; 
#line 558
static constexpr _Ty min() noexcept 
#line 559
{ 
#line 560
return 0; 
#line 561
} 
#line 563
static constexpr _Ty max() noexcept 
#line 564
{ 
#line 565
return 65535; 
#line 566
} 
#line 568
static constexpr _Ty lowest() noexcept 
#line 569
{ 
#line 570
return min(); 
#line 571
} 
#line 573
static constexpr _Ty epsilon() noexcept 
#line 574
{ 
#line 575
return 0; 
#line 576
} 
#line 578
static constexpr _Ty round_error() noexcept 
#line 579
{ 
#line 580
return 0; 
#line 581
} 
#line 583
static constexpr _Ty denorm_min() noexcept 
#line 584
{ 
#line 585
return 0; 
#line 586
} 
#line 588
static constexpr _Ty infinity() noexcept 
#line 589
{ 
#line 590
return 0; 
#line 591
} 
#line 593
static constexpr _Ty quiet_NaN() noexcept 
#line 594
{ 
#line 595
return 0; 
#line 596
} 
#line 598
static constexpr _Ty signaling_NaN() noexcept 
#line 599
{ 
#line 600
return 0; 
#line 601
} 
#line 603
static constexpr bool is_signed = ((bool)false); 
#line 604
static constexpr int digits = ((int)((8) * sizeof(unsigned short))); 
#line 605
static constexpr int digits10 = ((int)((((8) * sizeof(unsigned short)) * (301L)) / (1000))); 
#line 607 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
template<> class numeric_limits< char16_t>  : public _Num_int_base { 
#line 615
public: typedef char16_t _Ty; 
#line 617
static constexpr _Ty min() noexcept 
#line 618
{ 
#line 619
return 0; 
#line 620
} 
#line 622
static constexpr _Ty max() noexcept 
#line 623
{ 
#line 624
return 65535; 
#line 625
} 
#line 627
static constexpr _Ty lowest() noexcept 
#line 628
{ 
#line 629
return min(); 
#line 630
} 
#line 632
static constexpr _Ty epsilon() noexcept 
#line 633
{ 
#line 634
return 0; 
#line 635
} 
#line 637
static constexpr _Ty round_error() noexcept 
#line 638
{ 
#line 639
return 0; 
#line 640
} 
#line 642
static constexpr _Ty denorm_min() noexcept 
#line 643
{ 
#line 644
return 0; 
#line 645
} 
#line 647
static constexpr _Ty infinity() noexcept 
#line 648
{ 
#line 649
return 0; 
#line 650
} 
#line 652
static constexpr _Ty quiet_NaN() noexcept 
#line 653
{ 
#line 654
return 0; 
#line 655
} 
#line 657
static constexpr _Ty signaling_NaN() noexcept 
#line 658
{ 
#line 659
return 0; 
#line 660
} 
#line 662
static constexpr bool is_signed = ((bool)false); 
#line 663
static constexpr int digits = ((int)((8) * sizeof(char16_t))); 
#line 664
static constexpr int digits10 = ((int)((((8) * sizeof(char16_t)) * (301L)) / (1000))); 
#line 666 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 669
template<> class numeric_limits< int>  : public _Num_int_base { 
#line 673
public: typedef int _Ty; 
#line 675
static constexpr _Ty min() noexcept 
#line 676
{ 
#line 677
return (-2147483647) - 1; 
#line 678
} 
#line 680
static constexpr _Ty max() noexcept 
#line 681
{ 
#line 682
return 2147483647; 
#line 683
} 
#line 685
static constexpr _Ty lowest() noexcept 
#line 686
{ 
#line 687
return min(); 
#line 688
} 
#line 690
static constexpr _Ty epsilon() noexcept 
#line 691
{ 
#line 692
return 0; 
#line 693
} 
#line 695
static constexpr _Ty round_error() noexcept 
#line 696
{ 
#line 697
return 0; 
#line 698
} 
#line 700
static constexpr _Ty denorm_min() noexcept 
#line 701
{ 
#line 702
return 0; 
#line 703
} 
#line 705
static constexpr _Ty infinity() noexcept 
#line 706
{ 
#line 707
return 0; 
#line 708
} 
#line 710
static constexpr _Ty quiet_NaN() noexcept 
#line 711
{ 
#line 712
return 0; 
#line 713
} 
#line 715
static constexpr _Ty signaling_NaN() noexcept 
#line 716
{ 
#line 717
return 0; 
#line 718
} 
#line 720
static constexpr bool is_signed = ((bool)true); 
#line 721
static constexpr int digits = ((int)(((8) * sizeof(int)) - (1))); 
#line 722
static constexpr int digits10 = ((int)(((((8) * sizeof(int)) - (1)) * (301L)) / (1000))); 
#line 724 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 727
template<> class numeric_limits< unsigned>  : public _Num_int_base { 
#line 731
public: typedef unsigned _Ty; 
#line 733
static constexpr _Ty min() noexcept 
#line 734
{ 
#line 735
return 0; 
#line 736
} 
#line 738
static constexpr _Ty max() noexcept 
#line 739
{ 
#line 740
return 4294967295U; 
#line 741
} 
#line 743
static constexpr _Ty lowest() noexcept 
#line 744
{ 
#line 745
return min(); 
#line 746
} 
#line 748
static constexpr _Ty epsilon() noexcept 
#line 749
{ 
#line 750
return 0; 
#line 751
} 
#line 753
static constexpr _Ty round_error() noexcept 
#line 754
{ 
#line 755
return 0; 
#line 756
} 
#line 758
static constexpr _Ty denorm_min() noexcept 
#line 759
{ 
#line 760
return 0; 
#line 761
} 
#line 763
static constexpr _Ty infinity() noexcept 
#line 764
{ 
#line 765
return 0; 
#line 766
} 
#line 768
static constexpr _Ty quiet_NaN() noexcept 
#line 769
{ 
#line 770
return 0; 
#line 771
} 
#line 773
static constexpr _Ty signaling_NaN() noexcept 
#line 774
{ 
#line 775
return 0; 
#line 776
} 
#line 778
static constexpr bool is_signed = ((bool)false); 
#line 779
static constexpr int digits = ((int)((8) * sizeof(unsigned))); 
#line 780
static constexpr int digits10 = ((int)((((8) * sizeof(unsigned)) * (301L)) / (1000))); 
#line 782 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 785
template<> class numeric_limits< long>  : public _Num_int_base { 
#line 789
public: typedef long _Ty; 
#line 791
static constexpr _Ty min() noexcept 
#line 792
{ 
#line 793
return (-2147483647L) - (1); 
#line 794
} 
#line 796
static constexpr _Ty max() noexcept 
#line 797
{ 
#line 798
return 2147483647L; 
#line 799
} 
#line 801
static constexpr _Ty lowest() noexcept 
#line 802
{ 
#line 803
return min(); 
#line 804
} 
#line 806
static constexpr _Ty epsilon() noexcept 
#line 807
{ 
#line 808
return 0; 
#line 809
} 
#line 811
static constexpr _Ty round_error() noexcept 
#line 812
{ 
#line 813
return 0; 
#line 814
} 
#line 816
static constexpr _Ty denorm_min() noexcept 
#line 817
{ 
#line 818
return 0; 
#line 819
} 
#line 821
static constexpr _Ty infinity() noexcept 
#line 822
{ 
#line 823
return 0; 
#line 824
} 
#line 826
static constexpr _Ty quiet_NaN() noexcept 
#line 827
{ 
#line 828
return 0; 
#line 829
} 
#line 831
static constexpr _Ty signaling_NaN() noexcept 
#line 832
{ 
#line 833
return 0; 
#line 834
} 
#line 836
static constexpr bool is_signed = ((bool)true); 
#line 837
static constexpr int digits = ((int)(((8) * sizeof(long)) - (1))); 
#line 838
static constexpr int digits10 = ((int)(((((8) * sizeof(long)) - (1)) * (301L)) / (1000))); 
#line 840 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 843
template<> class numeric_limits< unsigned long>  : public _Num_int_base { 
#line 847
public: typedef unsigned long _Ty; 
#line 849
static constexpr _Ty min() noexcept 
#line 850
{ 
#line 851
return 0; 
#line 852
} 
#line 854
static constexpr _Ty max() noexcept 
#line 855
{ 
#line 856
return 4294967295UL; 
#line 857
} 
#line 859
static constexpr _Ty lowest() noexcept 
#line 860
{ 
#line 861
return min(); 
#line 862
} 
#line 864
static constexpr _Ty epsilon() noexcept 
#line 865
{ 
#line 866
return 0; 
#line 867
} 
#line 869
static constexpr _Ty round_error() noexcept 
#line 870
{ 
#line 871
return 0; 
#line 872
} 
#line 874
static constexpr _Ty denorm_min() noexcept 
#line 875
{ 
#line 876
return 0; 
#line 877
} 
#line 879
static constexpr _Ty infinity() noexcept 
#line 880
{ 
#line 881
return 0; 
#line 882
} 
#line 884
static constexpr _Ty quiet_NaN() noexcept 
#line 885
{ 
#line 886
return 0; 
#line 887
} 
#line 889
static constexpr _Ty signaling_NaN() noexcept 
#line 890
{ 
#line 891
return 0; 
#line 892
} 
#line 894
static constexpr bool is_signed = ((bool)false); 
#line 895
static constexpr int digits = ((int)((8) * sizeof(unsigned long))); 
#line 896
static constexpr int digits10 = ((int)((((8) * sizeof(unsigned long)) * (301L)) / (1000))); 
#line 898 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 901
template<> class numeric_limits< char32_t>  : public _Num_int_base { 
#line 905
public: typedef char32_t _Ty; 
#line 907
static constexpr _Ty min() noexcept 
#line 908
{ 
#line 909
return 0; 
#line 910
} 
#line 912
static constexpr _Ty max() noexcept 
#line 913
{ 
#line 914
return 4294967295U; 
#line 915
} 
#line 917
static constexpr _Ty lowest() noexcept 
#line 918
{ 
#line 919
return min(); 
#line 920
} 
#line 922
static constexpr _Ty epsilon() noexcept 
#line 923
{ 
#line 924
return 0; 
#line 925
} 
#line 927
static constexpr _Ty round_error() noexcept 
#line 928
{ 
#line 929
return 0; 
#line 930
} 
#line 932
static constexpr _Ty denorm_min() noexcept 
#line 933
{ 
#line 934
return 0; 
#line 935
} 
#line 937
static constexpr _Ty infinity() noexcept 
#line 938
{ 
#line 939
return 0; 
#line 940
} 
#line 942
static constexpr _Ty quiet_NaN() noexcept 
#line 943
{ 
#line 944
return 0; 
#line 945
} 
#line 947
static constexpr _Ty signaling_NaN() noexcept 
#line 948
{ 
#line 949
return 0; 
#line 950
} 
#line 952
static constexpr bool is_signed = ((bool)false); 
#line 953
static constexpr int digits = ((int)((8) * sizeof(char32_t))); 
#line 954
static constexpr int digits10 = ((int)((((8) * sizeof(char32_t)) * (301L)) / (1000))); 
#line 956 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 959
template<> class numeric_limits< __int64>  : public _Num_int_base { 
#line 963
public: typedef __int64 _Ty; 
#line 965
static constexpr _Ty min() noexcept 
#line 966
{ 
#line 967
return (-9223372036854775807i64) - (1); 
#line 968
} 
#line 970
static constexpr _Ty max() noexcept 
#line 971
{ 
#line 972
return 9223372036854775807i64; 
#line 973
} 
#line 975
static constexpr _Ty lowest() noexcept 
#line 976
{ 
#line 977
return min(); 
#line 978
} 
#line 980
static constexpr _Ty epsilon() noexcept 
#line 981
{ 
#line 982
return 0; 
#line 983
} 
#line 985
static constexpr _Ty round_error() noexcept 
#line 986
{ 
#line 987
return 0; 
#line 988
} 
#line 990
static constexpr _Ty denorm_min() noexcept 
#line 991
{ 
#line 992
return 0; 
#line 993
} 
#line 995
static constexpr _Ty infinity() noexcept 
#line 996
{ 
#line 997
return 0; 
#line 998
} 
#line 1000
static constexpr _Ty quiet_NaN() noexcept 
#line 1001
{ 
#line 1002
return 0; 
#line 1003
} 
#line 1005
static constexpr _Ty signaling_NaN() noexcept 
#line 1006
{ 
#line 1007
return 0; 
#line 1008
} 
#line 1010
static constexpr bool is_signed = ((bool)true); 
#line 1011
static constexpr int digits = ((int)(((8) * sizeof(__int64)) - (1))); 
#line 1012
static constexpr int digits10 = ((int)(((((8) * sizeof(__int64)) - (1)) * (301L)) / (1000))); 
#line 1014 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 1017
template<> class numeric_limits< unsigned __int64>  : public _Num_int_base { 
#line 1021
public: typedef unsigned __int64 _Ty; 
#line 1023
static constexpr _Ty min() noexcept 
#line 1024
{ 
#line 1025
return 0; 
#line 1026
} 
#line 1028
static constexpr _Ty max() noexcept 
#line 1029
{ 
#line 1030
return 18446744073709551615Ui64; 
#line 1031
} 
#line 1033
static constexpr _Ty lowest() noexcept 
#line 1034
{ 
#line 1035
return min(); 
#line 1036
} 
#line 1038
static constexpr _Ty epsilon() noexcept 
#line 1039
{ 
#line 1040
return 0; 
#line 1041
} 
#line 1043
static constexpr _Ty round_error() noexcept 
#line 1044
{ 
#line 1045
return 0; 
#line 1046
} 
#line 1048
static constexpr _Ty denorm_min() noexcept 
#line 1049
{ 
#line 1050
return 0; 
#line 1051
} 
#line 1053
static constexpr _Ty infinity() noexcept 
#line 1054
{ 
#line 1055
return 0; 
#line 1056
} 
#line 1058
static constexpr _Ty quiet_NaN() noexcept 
#line 1059
{ 
#line 1060
return 0; 
#line 1061
} 
#line 1063
static constexpr _Ty signaling_NaN() noexcept 
#line 1064
{ 
#line 1065
return 0; 
#line 1066
} 
#line 1068
static constexpr bool is_signed = ((bool)false); 
#line 1069
static constexpr int digits = ((int)((8) * sizeof(unsigned __int64))); 
#line 1070
static constexpr int digits10 = ((int)((((8) * sizeof(unsigned __int64)) * (301L)) / (1000))); 
#line 1072 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}; 
#line 1075
template<> class numeric_limits< float>  : public _Num_float_base { 
#line 1079
public: typedef float _Ty; 
#line 1081
static constexpr _Ty min() noexcept 
#line 1082
{ 
#line 1083
return (1.175494351e-38F); 
#line 1084
} 
#line 1086
static constexpr _Ty max() noexcept 
#line 1087
{ 
#line 1088
return (3.402823466e+38F); 
#line 1089
} 
#line 1091
static constexpr _Ty lowest() noexcept 
#line 1092
{ 
#line 1093
return -max(); 
#line 1094
} 
#line 1096
static constexpr _Ty epsilon() noexcept 
#line 1097
{ 
#line 1098
return (1.192092896e-07F); 
#line 1099
} 
#line 1101
static constexpr _Ty round_error() noexcept 
#line 1102
{ 
#line 1103
return (0.5F); 
#line 1104
} 
#line 1106
static constexpr _Ty denorm_min() noexcept 
#line 1107
{ 
#line 1108
return (1.401298464e-45F); 
#line 1109
} 
#line 1111
static constexpr _Ty infinity() noexcept 
#line 1112
{ 
#line 1113
return __builtin_huge_valf(); 
#line 1114
} 
#line 1116
static constexpr _Ty quiet_NaN() noexcept 
#line 1117
{ 
#line 1118
return __builtin_nanf("0"); 
#line 1119
} 
#line 1121
static constexpr _Ty signaling_NaN() noexcept 
#line 1122
{ 
#line 1123
return __builtin_nansf("1"); 
#line 1124
} 
#line 1126
static constexpr int digits = ((int)24); 
#line 1127
static constexpr int digits10 = ((int)6); 
#line 1129
static constexpr int max_digits10 = ((int)((2) + (((24) * 301L) / (1000)))); 
#line 1131
static constexpr int max_exponent = ((int)((int)128)); 
#line 1132
static constexpr int max_exponent10 = ((int)((int)38)); 
#line 1133
static constexpr int min_exponent = ((int)((int)(-125))); 
#line 1134
static constexpr int min_exponent10 = ((int)((int)(-37))); 
#line 1135
}; 
#line 1138
template<> class numeric_limits< double>  : public _Num_float_base { 
#line 1142
public: typedef double _Ty; 
#line 1144
static constexpr _Ty min() noexcept 
#line 1145
{ 
#line 1146
return (2.225073858507201383e-308); 
#line 1147
} 
#line 1149
static constexpr _Ty max() noexcept 
#line 1150
{ 
#line 1151
return (1.797693134862315708e+308); 
#line 1152
} 
#line 1154
static constexpr _Ty lowest() noexcept 
#line 1155
{ 
#line 1156
return -max(); 
#line 1157
} 
#line 1159
static constexpr _Ty epsilon() noexcept 
#line 1160
{ 
#line 1161
return (2.220446049250313081e-16); 
#line 1162
} 
#line 1164
static constexpr _Ty round_error() noexcept 
#line 1165
{ 
#line 1166
return (0.5); 
#line 1167
} 
#line 1169
static constexpr _Ty denorm_min() noexcept 
#line 1170
{ 
#line 1171
return (4.940656458412465442e-324); 
#line 1172
} 
#line 1174
static constexpr _Ty infinity() noexcept 
#line 1175
{ 
#line 1176
return __builtin_huge_val(); 
#line 1177
} 
#line 1179
static constexpr _Ty quiet_NaN() noexcept 
#line 1180
{ 
#line 1181
return __builtin_nan("0"); 
#line 1182
} 
#line 1184
static constexpr _Ty signaling_NaN() noexcept 
#line 1185
{ 
#line 1186
return __builtin_nans("1"); 
#line 1187
} 
#line 1189
static constexpr int digits = ((int)53); 
#line 1190
static constexpr int digits10 = ((int)15); 
#line 1192
static constexpr int max_digits10 = ((int)((2) + (((53) * 301L) / (1000)))); 
#line 1194
static constexpr int max_exponent = ((int)((int)1024)); 
#line 1195
static constexpr int max_exponent10 = ((int)((int)308)); 
#line 1196
static constexpr int min_exponent = ((int)((int)(-1021))); 
#line 1197
static constexpr int min_exponent10 = ((int)((int)(-307))); 
#line 1198
}; 
#line 1201
template<> class numeric_limits< long double>  : public _Num_float_base { 
#line 1205
public: typedef long double _Ty; 
#line 1207
static constexpr _Ty min() noexcept 
#line 1208
{ 
#line 1209
return (2.225073858507201383e-308); 
#line 1210
} 
#line 1212
static constexpr _Ty max() noexcept 
#line 1213
{ 
#line 1214
return (1.797693134862315708e+308); 
#line 1215
} 
#line 1217
static constexpr _Ty lowest() noexcept 
#line 1218
{ 
#line 1219
return -max(); 
#line 1220
} 
#line 1222
static constexpr _Ty epsilon() noexcept 
#line 1223
{ 
#line 1224
return (2.220446049250313081e-16); 
#line 1225
} 
#line 1227
static constexpr _Ty round_error() noexcept 
#line 1228
{ 
#line 1229
return (0.5L); 
#line 1230
} 
#line 1232
static constexpr _Ty denorm_min() noexcept 
#line 1233
{ 
#line 1234
return (4.940656458412465442e-324); 
#line 1235
} 
#line 1237
static constexpr _Ty infinity() noexcept 
#line 1238
{ 
#line 1239
return __builtin_huge_val(); 
#line 1240
} 
#line 1242
static constexpr _Ty quiet_NaN() noexcept 
#line 1243
{ 
#line 1244
return __builtin_nan("0"); 
#line 1245
} 
#line 1247
static constexpr _Ty signaling_NaN() noexcept 
#line 1248
{ 
#line 1249
return __builtin_nans("1"); 
#line 1250
} 
#line 1252
static constexpr int digits = ((int)53); 
#line 1253
static constexpr int digits10 = ((int)15); 
#line 1255
static constexpr int max_digits10 = ((int)((2) + (((53) * 301L) / (1000)))); 
#line 1257
static constexpr int max_exponent = ((int)((int)1024)); 
#line 1258
static constexpr int max_exponent10 = ((int)((int)308)); 
#line 1259
static constexpr int min_exponent = ((int)((int)(-1021))); 
#line 1260
static constexpr int min_exponent10 = ((int)((int)(-307))); 
#line 1261
}; 
#line 1481 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
}
#line 1483
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
#pragma warning(push,3)
#line 12
#pragma warning(disable: 4180 4296)
#line 1484 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\limits"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 15
template< class _Ty> 
#line 16
struct _Is_memfunptr { 
#line 18
typedef false_type _Bool_type; 
#line 19
}; 
#line 33
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { typedef ::std::true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; 
#line 47
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...)>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &&>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &&>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &&>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &&>  { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; 
#line 51
template< class _Ty> 
#line 52
struct is_void : public false_type { 
#line 55
}; 
#line 64
template<> struct is_void< void>  : public true_type { }; template<> struct is_void< const void>  : public true_type { }; template<> struct is_void< volatile void>  : public true_type { }; template<> struct is_void< const volatile void>  : public true_type { }; 
#line 69
template< class _Ty> 
#line 70
struct add_const { 
#line 72
typedef const _Ty type; 
#line 73
}; 
#line 76
template< class _Ty> 
#line 77
struct add_volatile { 
#line 79
typedef volatile _Ty type; 
#line 80
}; 
#line 83
template< class _Ty> 
#line 84
struct add_cv { 
#line 86
typedef const volatile _Ty type; 
#line 87
}; 
#line 90
template< class _Ty, bool 
#line 91
 = _Is_function< _Ty> ::_Weird || is_void< _Ty> ::value> 
#line 92
struct _Add_reference { 
#line 94
typedef _Ty _Lvalue; 
#line 95
typedef _Ty _Rvalue; 
#line 96
}; 
#line 98
template< class _Ty> 
#line 99
struct _Add_reference< _Ty, false>  { 
#line 101
typedef _Ty &_Lvalue; 
#line 102
typedef _Ty &&_Rvalue; 
#line 103
}; 
#line 106
template< class _Ty> 
#line 107
struct add_lvalue_reference { 
#line 109
typedef typename _Add_reference< _Ty> ::_Lvalue type; 
#line 110
}; 
#line 113
template< class _Ty> 
#line 114
struct add_rvalue_reference { 
#line 116
typedef typename _Add_reference< _Ty> ::_Rvalue type; 
#line 117
}; 
#line 120
template< class _Ty> typename add_rvalue_reference< _Ty> ::type declval() noexcept; 
#line 125
template< class _Ty> 
#line 126
struct remove_extent { 
#line 128
typedef _Ty type; 
#line 129
}; 
#line 131
template< class _Ty, size_t _Ix> 
#line 132
struct remove_extent< _Ty [_Ix]>  { 
#line 134
typedef _Ty type; 
#line 135
}; 
#line 137
template< class _Ty> 
#line 138
struct remove_extent< _Ty []>  { 
#line 140
typedef _Ty type; 
#line 141
}; 
#line 144
template< class _Ty> 
#line 145
struct remove_all_extents { 
#line 147
typedef _Ty type; 
#line 148
}; 
#line 150
template< class _Ty, size_t _Ix> 
#line 151
struct remove_all_extents< _Ty [_Ix]>  { 
#line 153
typedef typename std::remove_all_extents< _Ty> ::type type; 
#line 154
}; 
#line 156
template< class _Ty> 
#line 157
struct remove_all_extents< _Ty []>  { 
#line 159
typedef typename std::remove_all_extents< _Ty> ::type type; 
#line 160
}; 
#line 163
template< class _Ty> 
#line 164
struct remove_pointer { 
#line 166
typedef _Ty type; 
#line 167
}; 
#line 176
template< class _Ty> struct remove_pointer< _Ty *>  { typedef _Ty type; }; template< class _Ty> struct remove_pointer< _Ty *const>  { typedef _Ty type; }; template< class _Ty> struct remove_pointer< _Ty *volatile>  { typedef _Ty type; }; template< class _Ty> struct remove_pointer< _Ty *const volatile>  { typedef _Ty type; }; 
#line 180
template< class _Ty, bool 
#line 181
 = _Is_function< _Ty> ::_Weird> 
#line 182
struct _Add_pointer { 
#line 184
typedef _Ty type; 
#line 185
}; 
#line 187
template< class _Ty> 
#line 188
struct _Add_pointer< _Ty, false>  { 
#line 190
typedef typename remove_reference< _Ty> ::type *type; 
#line 191
}; 
#line 193
template< class _Ty> 
#line 194
struct add_pointer { 
#line 196
typedef typename _Add_pointer< _Ty> ::type type; 
#line 197
}; 
#line 201
template< class _Ty> 
#line 202
struct is_array : public false_type { 
#line 205
}; 
#line 207
template< class _Ty, size_t _Nx> 
#line 208
struct is_array< _Ty [_Nx]>  : public true_type { 
#line 211
}; 
#line 213
template< class _Ty> 
#line 214
struct is_array< _Ty []>  : public true_type { 
#line 217
}; 
#line 220
template< class _Ty> 
#line 221
struct is_lvalue_reference : public false_type { 
#line 224
}; 
#line 226
template< class _Ty> 
#line 227
struct is_lvalue_reference< _Ty &>  : public true_type { 
#line 230
}; 
#line 233
template< class _Ty> 
#line 234
struct is_rvalue_reference : public false_type { 
#line 237
}; 
#line 239
template< class _Ty> 
#line 240
struct is_rvalue_reference< _Ty &&>  : public true_type { 
#line 243
}; 
#line 246
template< class _Ty> 
#line 247
struct is_reference : public _Cat_base< is_lvalue_reference< _Ty> ::value || is_rvalue_reference< _Ty> ::value>  { 
#line 251
}; 
#line 255
template< class _Ty, bool 
#line 256
_Pmf = _Is_memfunptr< _Ty> ::_Bool_type::value> 
#line 257
struct _Is_member_object_pointer : public false_type { 
#line 260
}; 
#line 262
template< class _Ty1, class 
#line 263
_Ty2> 
#line 264
struct _Is_member_object_pointer< _Ty1 _Ty2::*, false>  : public true_type { 
#line 267
typedef _Ty2 _Class_type; 
#line 268
}; 
#line 270
template< class _Ty> 
#line 271
struct is_member_object_pointer : public _Is_member_object_pointer< typename remove_cv< _Ty> ::type> ::type { 
#line 274
}; 
#line 277
template< class _Ty> 
#line 278
struct is_member_function_pointer : public _Is_memfunptr< typename remove_cv< _Ty> ::type> ::_Bool_type { 
#line 281
}; 
#line 284
template< class _Ty> 
#line 285
struct _Is_pointer : public false_type { 
#line 288
}; 
#line 290
template< class _Ty> 
#line 291
struct _Is_pointer< _Ty *>  : public _Cat_base< (!is_member_object_pointer< _Ty *> ::value) && (!is_member_function_pointer< _Ty *> ::value)>  { 
#line 295
}; 
#line 297
template< class _Ty> 
#line 298
struct is_pointer : public _Is_pointer< typename remove_cv< _Ty> ::type>  { 
#line 301
}; 
#line 305
template< class _Ty> 
#line 306
struct is_null_pointer : public _Cat_base< is_same< typename remove_cv< _Ty> ::type, std::nullptr_t> ::value>  { 
#line 309
}; 
#line 312
template< class _Ty> 
#line 313
struct is_union : public _Cat_base< __is_union(_Ty)>  { 
#line 316
}; 
#line 319
template< class _Ty> 
#line 320
struct is_class : public _Cat_base< __is_class(_Ty)>  { 
#line 323
}; 
#line 326
template< class _Ty> 
#line 327
struct is_fundamental : public _Cat_base< (is_arithmetic< _Ty> ::value || is_void< _Ty> ::value) || is_null_pointer< _Ty> ::value>  { 
#line 332
}; 
#line 335
template< class _Ty> 
#line 336
struct is_object : public _Cat_base< ((!is_function< _Ty> ::value) && (!is_reference< _Ty> ::value)) && (!is_void< _Ty> ::value)>  { 
#line 341
}; 
#line 345
template< class _From, class 
#line 346
_To> 
#line 347
struct is_convertible : public _Cat_base< __is_convertible_to(_From, _To)>  { 
#line 350
}; 
#line 353
template< class _Ty> 
#line 354
struct is_enum : public _Cat_base< __is_enum(_Ty)>  { 
#line 357
}; 
#line 360
template< class _Ty> 
#line 361
struct is_compound : public _Cat_base< !is_fundamental< _Ty> ::value>  { 
#line 364
}; 
#line 367
template< class _Ty> 
#line 368
struct is_member_pointer : public _Cat_base< is_member_object_pointer< _Ty> ::value || is_member_function_pointer< _Ty> ::value>  { 
#line 372
}; 
#line 375
template< class _Ty> 
#line 376
struct is_scalar : public _Cat_base< (((is_arithmetic< _Ty> ::value || is_enum< _Ty> ::value) || is_pointer< _Ty> ::value) || is_member_pointer< _Ty> ::value) || is_null_pointer< _Ty> ::value>  { 
#line 383
}; 
#line 386
template< class _Ty> 
#line 387
struct is_const : public false_type { 
#line 390
}; 
#line 392
template< class _Ty> 
#line 393
struct is_const< const _Ty>  : public true_type { 
#line 396
}; 
#line 399
template< class _Ty> 
#line 400
struct is_volatile : public false_type { 
#line 403
}; 
#line 405
template< class _Ty> 
#line 406
struct is_volatile< volatile _Ty>  : public true_type { 
#line 409
}; 
#line 412
template< class _Ty> 
#line 413
struct is_pod : public _Cat_base< __is_pod(_Ty)>  { 
#line 416
}; 
#line 419
template< class _Ty> 
#line 420
struct is_empty : public _Cat_base< __is_empty(_Ty)>  { 
#line 423
}; 
#line 426
template< class _Ty> 
#line 427
struct is_polymorphic : public _Cat_base< __is_polymorphic(_Ty)>  { 
#line 430
}; 
#line 433
template< class _Ty> 
#line 434
struct is_abstract : public _Cat_base< __is_abstract(_Ty)>  { 
#line 437
}; 
#line 440
template< class _Ty> 
#line 441
struct is_final : public _Cat_base< __is_final(_Ty)>  { 
#line 444
}; 
#line 447
template< class _Ty> 
#line 448
struct is_standard_layout : public _Cat_base< __is_standard_layout(_Ty)>  { 
#line 451
}; 
#line 454
template< class _Ty> 
#line 455
struct is_literal_type : public _Cat_base< __is_literal_type(_Ty)>  { 
#line 458
}; 
#line 461
template< class _Ty> 
#line 462
struct is_trivial : public _Cat_base< __is_trivial(_Ty)>  { 
#line 465
}; 
#line 468
template< class _Ty> 
#line 469
struct is_trivially_copyable : public _Cat_base< __is_trivially_copyable(_Ty)>  { 
#line 472
}; 
#line 475
template< class _Ty> 
#line 476
struct has_virtual_destructor : public _Cat_base< __has_virtual_destructor(_Ty)>  { 
#line 479
}; 
#line 484
template< class _Ty, class ...
#line 485
_Args> 
#line 486
struct is_constructible : public _Cat_base< __is_constructible(_Ty, _Args...)>  { 
#line 489
}; 
#line 492
template< class _Ty> 
#line 493
struct is_copy_constructible : public is_constructible< _Ty, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 501
}; 
#line 504
template< class _Ty> 
#line 505
struct is_default_constructible : public is_constructible< _Ty> ::type { 
#line 508
}; 
#line 511
template< class _Ty> 
#line 512
struct is_move_constructible : public is_constructible< _Ty, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 518
}; 
#line 521
template< class _To, class 
#line 522
_From> 
#line 523
struct is_assignable : public integral_constant< bool, __is_assignable(_To, _From)>  { 
#line 526
}; 
#line 529
template< class _Ty> 
#line 530
struct is_copy_assignable : public is_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 538
}; 
#line 541
template< class _Ty> 
#line 542
struct is_move_assignable : public is_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 548
}; 
#line 551
template< class _Ty> 
#line 552
struct is_destructible : public _Cat_base< __is_destructible(_Ty)>  { 
#line 555
}; 
#line 560
template< class _Ty, class ...
#line 561
_Args> 
#line 562
struct is_trivially_constructible : public _Cat_base< __is_trivially_constructible(_Ty, _Args...)>  { 
#line 565
}; 
#line 568
template< class _Ty> 
#line 569
struct is_trivially_copy_constructible : public is_trivially_constructible< _Ty, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 577
}; 
#line 580
template< class _Ty> 
#line 581
struct is_trivially_default_constructible : public is_trivially_constructible< _Ty> ::type { 
#line 584
}; 
#line 587
template< class _Ty> 
#line 588
struct is_trivially_move_constructible : public is_trivially_constructible< _Ty, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 594
}; 
#line 597
template< class _To, class 
#line 598
_From> 
#line 599
struct is_trivially_assignable : public _Cat_base< __is_trivially_assignable(_To, _From)>  { 
#line 602
}; 
#line 605
template< class _Ty> 
#line 606
struct is_trivially_copy_assignable : public is_trivially_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 614
}; 
#line 617
template< class _Ty> 
#line 618
struct is_trivially_move_assignable : public is_trivially_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 624
}; 
#line 627
template< class _Ty> 
#line 628
struct is_trivially_destructible : public _Cat_base< __has_trivial_destructor(_Ty)>  { 
#line 631
}; 
#line 636
template< class _Ty, class ...
#line 637
_Args> 
#line 638
struct is_nothrow_constructible : public _Cat_base< __is_nothrow_constructible(_Ty, _Args...)>  { 
#line 641
}; 
#line 644
template< class _Ty> 
#line 645
struct is_nothrow_copy_constructible : public is_nothrow_constructible< _Ty, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 653
}; 
#line 656
template< class _Ty> 
#line 657
struct is_nothrow_default_constructible : public is_nothrow_constructible< _Ty> ::type { 
#line 660
}; 
#line 663
template< class _Ty> 
#line 664
struct is_nothrow_move_constructible : public is_nothrow_constructible< _Ty, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 670
}; 
#line 673
template< class _To, class 
#line 674
_From> 
#line 675
struct is_nothrow_assignable : public _Cat_base< __is_nothrow_assignable(_To, _From)>  { 
#line 678
}; 
#line 681
template< class _Ty> 
#line 682
struct is_nothrow_copy_assignable : public is_nothrow_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 690
}; 
#line 693
template< class _Ty> 
#line 694
struct is_nothrow_move_assignable : public is_nothrow_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 700
}; 
#line 703
template< class _Ty> 
#line 704
struct is_nothrow_destructible : public _Cat_base< __is_nothrow_destructible(_Ty)>  { 
#line 707
}; 
#line 710
template< class _Ty, bool 
#line 711
 = is_integral< _Ty> ::value> 
#line 712
struct _Sign_base { 
#line 714
typedef typename remove_cv< _Ty> ::type _Uty; 
#line 715
typedef _Cat_base< (((typename remove_cv< _Ty> ::type)(-1)) < ((typename remove_cv< _Ty> ::type)0))>  _Signed; 
#line 716
typedef _Cat_base< (((typename remove_cv< _Ty> ::type)0) < ((typename remove_cv< _Ty> ::type)(-1)))>  _Unsigned; 
#line 717
}; 
#line 719
template< class _Ty> 
#line 720
struct _Sign_base< _Ty, false>  { 
#line 723
typedef is_floating_point< _Ty>  _Signed; 
#line 724
typedef false_type _Unsigned; 
#line 725
}; 
#line 727
template< class _Ty> 
#line 728
struct is_signed : public _Sign_base< _Ty> ::_Signed { 
#line 731
}; 
#line 734
template< class _Ty> 
#line 735
struct is_unsigned : public _Sign_base< _Ty> ::_Unsigned { 
#line 738
}; 
#line 741
template< class _Ty> 
#line 742
struct _Change_sign { 
#line 744
static_assert(((is_integral< _Ty> ::value || is_enum< _Ty> ::value) && (!is_same< _Ty, bool> ::value)), "make_signed<T>/make_unsigned<T> require that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool ty" "pe.");
#line 767
typedef typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type _Signed; 
#line 776
typedef typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, signed char> ::value, unsigned char, typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, short> ::value, unsigned short, typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, int> ::value, unsigned, typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, long> ::value, unsigned long, unsigned __int64> ::type> ::type> ::type> ::type _Unsigned; 
#line 777
}; 
#line 779
template< class _Ty> 
#line 780
struct _Change_sign< const _Ty>  { 
#line 782
typedef const typename std::_Change_sign< _Ty> ::_Signed _Signed; 
#line 783
typedef const typename std::_Change_sign< _Ty> ::_Unsigned _Unsigned; 
#line 784
}; 
#line 786
template< class _Ty> 
#line 787
struct _Change_sign< volatile _Ty>  { 
#line 789
typedef volatile typename std::_Change_sign< _Ty> ::_Signed _Signed; 
#line 790
typedef volatile typename std::_Change_sign< _Ty> ::_Unsigned _Unsigned; 
#line 791
}; 
#line 793
template< class _Ty> 
#line 794
struct _Change_sign< const volatile _Ty>  { 
#line 796
typedef const volatile typename std::_Change_sign< _Ty> ::_Signed _Signed; 
#line 797
typedef const volatile typename std::_Change_sign< _Ty> ::_Unsigned _Unsigned; 
#line 798
}; 
#line 801
template< class _Ty> 
#line 802
struct make_signed { 
#line 804
typedef typename _Change_sign< _Ty> ::_Signed type; 
#line 805
}; 
#line 808
template< class _Ty> 
#line 809
struct make_unsigned { 
#line 811
typedef typename _Change_sign< _Ty> ::_Unsigned type; 
#line 812
}; 
#line 816
template< class _Ty> 
#line 817
struct alignment_of : public integral_constant< unsigned __int64, __alignof(_Ty)>  { 
#line 820
}; 
#line 827
template< class _Ty, size_t 
#line 828
_Len> 
#line 829
union _Align_type { 
#line 831
_Ty _Val; 
#line 832
char _Pad[_Len]; 
#line 833
}; 
#line 835
template< size_t _Len, size_t 
#line 836
_Align, class 
#line 837
_Ty, bool 
#line 838
_Ok> struct _Aligned; 
#line 841
template< size_t _Len, size_t 
#line 842
_Align, class 
#line 843
_Ty> 
#line 844
struct _Aligned< _Len, _Align, _Ty, true>  { 
#line 846
typedef _Align_type< _Ty, _Len>  type; 
#line 847
}; 
#line 849
template< size_t _Len, size_t 
#line 850
_Align> 
#line 851
struct _Aligned< _Len, _Align, double, false>  { 
#line 853
typedef _Align_type< double, _Len>  type; 
#line 854
}; 
#line 856
template< size_t _Len, size_t 
#line 857
_Align> 
#line 858
struct _Aligned< _Len, _Align, int, false>  { 
#line 860
typedef typename std::_Aligned< _Len, _Align, double, _Align <= integral_constant< unsigned __int64, 8Ui64> ::value> ::type type; 
#line 861
}; 
#line 863
template< size_t _Len, size_t 
#line 864
_Align> 
#line 865
struct _Aligned< _Len, _Align, short, false>  { 
#line 867
typedef typename std::_Aligned< _Len, _Align, int, _Align <= integral_constant< unsigned __int64, 4Ui64> ::value> ::type type; 
#line 868
}; 
#line 870
template< size_t _Len, size_t 
#line 871
_Align> 
#line 872
struct _Aligned< _Len, _Align, char, false>  { 
#line 874
typedef typename std::_Aligned< _Len, _Align, short, _Align <= integral_constant< unsigned __int64, 2Ui64> ::value> ::type type; 
#line 875
}; 
#line 877
template< size_t _Len, size_t 
#line 878
_Align = 8Ui64> 
#line 879
struct aligned_storage { 
#line 881
typedef typename _Aligned< _Len, _Align, char, _Align <= integral_constant< unsigned __int64, 1Ui64> ::value> ::type type; 
#line 882
}; 
#line 888
template< size_t ..._Vals> struct _Maximum; 
#line 892
template<> struct _Maximum< >  { 
#line 894
static constexpr size_t value = (0); 
#line 895
}; 
#line 897
template< size_t _Val> 
#line 898
struct _Maximum< _Val>  { 
#line 900
static constexpr size_t value = _Val; 
#line 901
}; 
#line 903
template< size_t _First, size_t 
#line 904
_Second, size_t ...
#line 905
_Rest> 
#line 906
struct _Maximum< _First, _Second, _Rest...>  : public _Maximum< (((_First) < _Second) ? _Second : _First), _Rest...>  { 
#line 909
}; 
#line 911
template< size_t _Len, class ...
#line 912
_Types> 
#line 913
struct aligned_union { 
#line 915
static constexpr size_t _Max_len = (_Maximum< _Len, sizeof(_Types)...> ::value); 
#line 917
static constexpr size_t alignment_value = (_Maximum< (alignment_of< _Types> ::value)...> ::value); 
#line 919
typedef typename aligned_storage< _Max_len, alignment_value> ::type type; 
#line 920
}; 
#line 923
template< class _Ty> 
#line 924
struct underlying_type { 
#line 926
typedef __underlying_type(_Ty) type; 
#line 927
}; 
#line 930
template< class _Ty> 
#line 931
struct rank : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 934
}; 
#line 936
template< class _Ty, size_t _Ix> 
#line 937
struct rank< _Ty [_Ix]>  : public integral_constant< unsigned __int64, rank< _Ty> ::value + 1>  { 
#line 940
}; 
#line 942
template< class _Ty> 
#line 943
struct rank< _Ty []>  : public integral_constant< unsigned __int64, rank< _Ty> ::value + 1>  { 
#line 946
}; 
#line 949
template< class _Ty, unsigned _Nx> 
#line 950
struct _Extent : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 953
}; 
#line 955
template< class _Ty, size_t _Ix> 
#line 956
struct _Extent< _Ty [_Ix], 0>  : public integral_constant< unsigned __int64, _Ix>  { 
#line 959
}; 
#line 961
template< class _Ty, unsigned _Nx, size_t _Ix> 
#line 962
struct _Extent< _Ty [_Ix], _Nx>  : public _Extent< _Ty, _Nx - (1)>  { 
#line 965
}; 
#line 967
template< class _Ty, unsigned _Nx> 
#line 968
struct _Extent< _Ty [], _Nx>  : public _Extent< _Ty, _Nx - (1)>  { 
#line 971
}; 
#line 973
template< class _Ty, unsigned _Nx = 0U> 
#line 974
struct extent : public _Extent< _Ty, _Nx>  { 
#line 977
}; 
#line 980
template< class _Base, class 
#line 981
_Der> 
#line 982
struct is_base_of : public _Cat_base< __is_base_of(_Base, _Der)>  { 
#line 985
}; 
#line 988
template< class _Ty> 
#line 989
struct decay { 
#line 991
typedef typename remove_reference< _Ty> ::type _Ty1; 
#line 997
typedef typename _If< is_array< typename remove_reference< _Ty> ::type> ::value, typename remove_extent< typename remove_reference< _Ty> ::type> ::type *, typename _If< is_function< typename remove_reference< _Ty> ::type> ::value, typename add_pointer< typename remove_reference< _Ty> ::type> ::type, typename remove_cv< typename remove_reference< _Ty> ::type> ::type> ::type> ::type type; 
#line 998
}; 
#line 1001
template< class ...> struct _Conjunction; 
#line 1004
template< bool , class 
#line 1005
_Lhs, class ...
#line 1006
_Traits> 
#line 1007
struct _Choose_conjunction { 
#line 1009
typedef _Lhs type; 
#line 1010
}; 
#line 1012
template< class _Lhs, class ...
#line 1013
_Traits> 
#line 1014
struct _Choose_conjunction< true, _Lhs, _Traits...>  { 
#line 1016
typedef typename _Conjunction< _Traits...> ::type type; 
#line 1017
}; 
#line 1020
template<> struct _Conjunction< >  { 
#line 1022
typedef true_type type; 
#line 1023
}; 
#line 1025
template< class _Trait> 
#line 1026
struct _Conjunction< _Trait>  { 
#line 1028
typedef _Trait type; 
#line 1029
}; 
#line 1031
template< class _Lhs, class ...
#line 1032
_Traits> 
#line 1033
struct _Conjunction< _Lhs, _Traits...>  { 
#line 1035
typedef typename _Choose_conjunction< _Lhs::value, _Lhs, _Traits...> ::type type; 
#line 1036
}; 
#line 1038
template< class ..._Traits> 
#line 1039
struct conjunction : public _Conjunction< _Traits...> ::type { 
#line 1044
}; 
#line 1047
template< class ...> struct _Disjunction; 
#line 1050
template< bool , class 
#line 1051
_Lhs, class ...
#line 1052
_Traits> 
#line 1053
struct _Choose_disjunction { 
#line 1055
typedef _Lhs type; 
#line 1056
}; 
#line 1058
template< class _Lhs, class ...
#line 1059
_Traits> 
#line 1060
struct _Choose_disjunction< false, _Lhs, _Traits...>  { 
#line 1062
typedef typename _Disjunction< _Traits...> ::type type; 
#line 1063
}; 
#line 1066
template<> struct _Disjunction< >  { 
#line 1068
typedef false_type type; 
#line 1069
}; 
#line 1071
template< class _Trait> 
#line 1072
struct _Disjunction< _Trait>  { 
#line 1074
typedef _Trait type; 
#line 1075
}; 
#line 1077
template< class _Lhs, class ...
#line 1078
_Traits> 
#line 1079
struct _Disjunction< _Lhs, _Traits...>  { 
#line 1081
typedef typename _Choose_disjunction< _Lhs::value, _Lhs, _Traits...> ::type type; 
#line 1082
}; 
#line 1084
template< class ..._Traits> 
#line 1085
struct disjunction : public _Disjunction< _Traits...> ::type { 
#line 1090
}; 
#line 1093
template< class _Trait> 
#line 1094
struct negation : public bool_constant< !_Trait::value>  { 
#line 1097
}; 
#line 1100
namespace tr1 { 
#line 1101
using std::add_const;
#line 1102
using std::add_cv;
#line 1103
using std::add_pointer;
#line 1104
using std::add_volatile;
#line 1105
using std::aligned_storage;
#line 1106
using std::alignment_of;
#line 1107
using std::conditional;
#line 1108
using std::decay;
#line 1109
using std::enable_if;
#line 1110
using std::extent;
#line 1111
using std::false_type;
#line 1112
using std::has_virtual_destructor;
#line 1113
using std::integral_constant;
#line 1114
using std::is_abstract;
#line 1115
using std::is_arithmetic;
#line 1116
using std::is_array;
#line 1117
using std::is_base_of;
#line 1118
using std::is_class;
#line 1119
using std::is_compound;
#line 1120
using std::is_const;
#line 1121
using std::is_convertible;
#line 1122
using std::is_empty;
#line 1123
using std::is_enum;
#line 1124
using std::is_floating_point;
#line 1125
using std::is_function;
#line 1126
using std::is_fundamental;
#line 1127
using std::is_integral;
#line 1128
using std::is_member_function_pointer;
#line 1129
using std::is_member_object_pointer;
#line 1130
using std::is_member_pointer;
#line 1131
using std::is_object;
#line 1132
using std::is_pod;
#line 1133
using std::is_pointer;
#line 1134
using std::is_polymorphic;
#line 1135
using std::is_reference;
#line 1136
using std::is_same;
#line 1137
using std::is_scalar;
#line 1138
using std::is_signed;
#line 1139
using std::is_union;
#line 1140
using std::is_unsigned;
#line 1141
using std::is_void;
#line 1142
using std::is_volatile;
#line 1143
using std::make_signed;
#line 1144
using std::make_unsigned;
#line 1145
using std::rank;
#line 1146
using std::remove_all_extents;
#line 1147
using std::remove_const;
#line 1148
using std::remove_cv;
#line 1149
using std::remove_extent;
#line 1150
using std::remove_pointer;
#line 1151
using std::remove_reference;
#line 1152
using std::remove_volatile;
#line 1153
using std::true_type;
#line 1154
}
#line 1158 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< class ..._Ty> struct common_type; 
#line 1161
template< class _Ty> 
#line 1162
struct common_type< _Ty>  { 
#line 1164
typedef typename decay< _Ty> ::type type; 
#line 1165
}; 
#line 1167
template< class _Ty0, class 
#line 1168
_Ty1> 
#line 1169
struct common_type< _Ty0, _Ty1>  { 
#line 1175
typedef typename decay< decltype(((_Always_false< _Ty0> ::value) ? std::declval< _Ty0> () : std::declval< _Ty1> ()))> ::type type; 
#line 1176
}; 
#line 1178
template< class _Ty0, class 
#line 1179
_Ty1, class ...
#line 1180
_Ty> 
#line 1181
struct common_type< _Ty0, _Ty1, _Ty...>  { 
#line 1185
typedef typename std::common_type< typename std::common_type< _Ty0, _Ty1> ::type, _Ty...> ::type type; 
#line 1186
}; 
#line 1189
template < class _Ty,
 _Ty ... _Vals >
 struct integer_sequence
 {
 static_assert ( is_integral < _Ty > :: value,
  "integer_sequence<T, I...> requires T to be an integral type." );

 typedef integer_sequence < _Ty, _Vals ... > type;
 typedef _Ty value_type;

 static constexpr size_t size ( ) noexcept
  {
  return ( sizeof ... ( _Vals ) );
  }
 };
#line 1243
template< class _Ty, _Ty 
#line 1244
_Size> using make_integer_sequence = __make_integer_seq< integer_sequence, _Ty, _Size> ; 
#line 1248 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< size_t ..._Vals> using index_sequence = integer_sequence< unsigned __int64, _Vals...> ; 
#line 1251
template< size_t _Size> using make_index_sequence = make_integer_sequence< unsigned __int64, _Size> ; 
#line 1254
template< class ..._Types> using index_sequence_for = make_index_sequence< sizeof...(_Types)> ; 
#line 1259
template < class _Ty >
 struct identity
 {
 typedef _Ty type;

 const _Ty & operator ( ) ( const _Ty & _Left ) const
  {
  return ( _Left );
  }
 };
#line 1272 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< class _Ty> constexpr _Ty &&
#line 1273
forward(typename remove_reference< _Ty> ::type &
#line 1274
_Arg) noexcept 
#line 1275
{ 
#line 1276
return static_cast< _Ty &&>(_Arg); 
#line 1277
} 
#line 1279
template< class _Ty> constexpr _Ty &&
#line 1280
forward(typename remove_reference< _Ty> ::type &&
#line 1281
_Arg) noexcept 
#line 1282
{ 
#line 1283
static_assert((!is_lvalue_reference< _Ty> ::value), "bad forward call");
#line 1284
return static_cast< _Ty &&>(_Arg); 
#line 1285
} 
#line 1288
template< class _Ty> constexpr typename remove_reference< _Ty> ::type &&
#line 1290
move(_Ty &&_Arg) noexcept 
#line 1291
{ 
#line 1292
return static_cast< typename remove_reference< _Ty> ::type &&>(_Arg); 
#line 1293
} 
#line 1296
template < class _Ty > inline
 constexpr typename _If < ! is_nothrow_move_constructible < _Ty > :: value
  && is_copy_constructible < _Ty > :: value,
   const _Ty &, _Ty && > :: type
 move_if_noexcept ( _Ty & _Arg ) noexcept
 {
 return ( :: std :: move ( _Arg ) );
 }
#line 1306
template< class ...> 
#line 1307
struct _Param_tester { 
#line 1309
typedef void type; 
#line 1310
}; 
#line 1313
template< class ..._Types> using void_t = typename _Param_tester< _Types...> ::type; 
#line 1317
struct _Invoker_pmf_object { 
#line 1319
template < class _Decayed,
  class _Ty1,
  class ... _Types2 >
  static auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 )
  -> decltype ( ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmf ) (
   :: std :: forward < _Types2 > ( _Args2 ) ... ) )
  {
  return ( ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmf ) (
   :: std :: forward < _Types2 > ( _Args2 ) ... ) );
  }
#line 1329
}; 
#line 1331
struct _Invoker_pmf_pointer { 
#line 1333
template < class _Decayed,
  class _Ty1,
  class ... _Types2 >
  static auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 )
  -> decltype ( ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmf ) (
   :: std :: forward < _Types2 > ( _Args2 ) ... ) )
  {
  return ( ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmf ) (
   :: std :: forward < _Types2 > ( _Args2 ) ... ) );
  }
#line 1343
}; 
#line 1345
struct _Invoker_pmd_object { 
#line 1347
template < class _Decayed,
  class _Ty1 >
  static auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 )
  -> decltype ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmd )
  {
  return ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmd );
  }
#line 1354
}; 
#line 1356
struct _Invoker_pmd_pointer { 
#line 1358
template < class _Decayed,
  class _Ty1 >
  static auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 )
  -> decltype ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmd )
  {
  return ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmd );
  }
#line 1365
}; 
#line 1367
struct _Invoker_functor { 
#line 1369
template < class _Callable,
  class ... _Types >
  static auto _Call ( _Callable && _Obj, _Types && ... _Args )
  -> decltype ( :: std :: forward < _Callable > ( _Obj ) (
   :: std :: forward < _Types > ( _Args ) ... ) )
  {
  return ( :: std :: forward < _Callable > ( _Obj ) (
   :: std :: forward < _Types > ( _Args ) ... ) );
  }
#line 1378
}; 
#line 1380
template< class _Callable, class 
#line 1381
_Ty1, class 
#line 1382
_Decayed = typename decay< _Callable> ::type, bool 
#line 1383
_Is_pmf = is_member_function_pointer< _Decayed> ::value, bool 
#line 1384
_Is_pmd = is_member_object_pointer< _Decayed> ::value> struct _Invoker1; 
#line 1387
template< class _Callable, class 
#line 1388
_Ty1, class 
#line 1389
_Decayed> 
#line 1390
struct _Invoker1< _Callable, _Ty1, _Decayed, true, false>  : public _If< is_base_of< typename _Is_memfunptr< _Decayed> ::_Class_type, typename decay< _Ty1> ::type> ::value, _Invoker_pmf_object, _Invoker_pmf_pointer> ::type { 
#line 1397
}; 
#line 1399
template< class _Callable, class 
#line 1400
_Ty1, class 
#line 1401
_Decayed> 
#line 1402
struct _Invoker1< _Callable, _Ty1, _Decayed, false, true>  : public _If< is_base_of< typename _Is_member_object_pointer< _Decayed> ::_Class_type, typename decay< _Ty1> ::type> ::value, _Invoker_pmd_object, _Invoker_pmd_pointer> ::type { 
#line 1409
}; 
#line 1411
template< class _Callable, class 
#line 1412
_Ty1, class 
#line 1413
_Decayed> 
#line 1414
struct _Invoker1< _Callable, _Ty1, _Decayed, false, false>  : public _Invoker_functor { 
#line 1417
}; 
#line 1419
template< class _Callable, class ...
#line 1420
_Types> struct _Invoker; 
#line 1423
template< class _Callable> 
#line 1424
struct _Invoker< _Callable>  : public _Invoker_functor { 
#line 1427
}; 
#line 1429
template< class _Callable, class 
#line 1430
_Ty1, class ...
#line 1431
_Types2> 
#line 1432
struct _Invoker< _Callable, _Ty1, _Types2...>  : public _Invoker1< _Callable, _Ty1>  { 
#line 1435
}; 
#line 1437
template < class _Callable,
 class ... _Types > inline
 auto invoke ( _Callable && _Obj, _Types && ... _Args )
 -> decltype ( _Invoker < _Callable, _Types ... > :: _Call (
  :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) )
 {
 return ( _Invoker < _Callable, _Types ... > :: _Call (
  :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) );
 }
#line 1447
template< class _Rx, bool 
#line 1448
 = is_void< _Rx> ::value> 
#line 1449
struct _Forced { 
#line 1451
}; 
#line 1453
struct _Unforced { 
#line 1455
}; 
#line 1457
template < class _Cv_void,
 class ... _Valtys > inline
 void _Invoke_ret ( _Forced < _Cv_void, true >, _Valtys && ... _Vals )
 {
 :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... );
 }
#line 1464
template < class _Rx,
 class ... _Valtys > inline
 _Rx _Invoke_ret ( _Forced < _Rx, false >, _Valtys && ... _Vals )
 {
 return ( :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... ) );
 }
#line 1471
template < class ... _Valtys > inline
 auto _Invoke_ret ( _Forced < _Unforced, false >, _Valtys && ... _Vals )
 -> decltype ( :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... ) )
 {
 return ( :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... ) );
 }
#line 1479
struct _Unique_tag_result_of { 
#line 1481
}; 
#line 1483
template< class _Void, class ...
#line 1484
_Types> 
#line 1485
struct _Result_of { 
#line 1487
}; 
#line 1489
template< class ..._Types> 
#line 1490
struct _Result_of< void_t< _Unique_tag_result_of, decltype((std::invoke(std::declval< _Types> ()...)))> , _Types...>  { 
#line 1496
typedef decltype((std::invoke(std::declval< _Types> ()...))) type; 
#line 1497
}; 
#line 1499
template< class _Fty> 
#line 1500
struct result_of { 
#line 1502
static_assert((_Always_false< _Fty> ::value), "result_of<CallableType> is invalid; use result_of<CallableType(zero or more argument types)> instead.");
#line 1505
}; 
#line 1515
template< class _Fty, class ..._Args> struct result_of< _Fty __cdecl (_Args ...)>  : public _Result_of< void, _Fty, _Args...>  { }; template< class _Fty, class ..._Args> struct result_of< _Fty __vectorcall (_Args ...)>  : public _Result_of< void, _Fty, _Args...>  { }; 
#line 1519
template< class _Ty, class 
#line 1520
 = void> 
#line 1521
struct _Weak_result_type { 
#line 1523
}; 
#line 1525
template< class _Ty> 
#line 1526
struct _Weak_result_type< _Ty, void_t< typename _Ty::result_type> >  { 
#line 1529
typedef typename _Ty::result_type result_type; 
#line 1530
}; 
#line 1532
template< class _Ty, class 
#line 1533
 = void> 
#line 1534
struct _Weak_argument_type : public _Weak_result_type< _Ty>  { 
#line 1537
}; 
#line 1539
template< class _Ty> 
#line 1540
struct _Weak_argument_type< _Ty, void_t< typename _Ty::argument_type> >  : public _Weak_result_type< _Ty>  { 
#line 1544
typedef typename _Ty::argument_type argument_type; 
#line 1545
}; 
#line 1547
template< class _Ty, class 
#line 1548
 = void> 
#line 1549
struct _Weak_binary_args : public _Weak_argument_type< _Ty>  { 
#line 1552
}; 
#line 1554
template< class _Ty> 
#line 1555
struct _Weak_binary_args< _Ty, void_t< typename _Ty::first_argument_type, typename _Ty::second_argument_type> >  : public _Weak_argument_type< _Ty>  { 
#line 1560
typedef typename _Ty::first_argument_type first_argument_type; 
#line 1561
typedef typename _Ty::second_argument_type second_argument_type; 
#line 1562
}; 
#line 1564
template< class _Ty> 
#line 1565
struct _Weak_types { 
#line 1567
typedef _Is_function< typename remove_pointer< _Ty> ::type>  _Is_f_or_pf; 
#line 1568
typedef _Is_memfunptr< typename remove_cv< _Ty> ::type>  _Is_pmf; 
#line 1571
typedef typename _If< _Is_function< typename remove_pointer< _Ty> ::type> ::_Bool_type::value, _Is_function< typename remove_pointer< _Ty> ::type> , typename _If< _Is_memfunptr< typename remove_cv< _Ty> ::type> ::_Bool_type::value, _Is_memfunptr< typename remove_cv< _Ty> ::type> , _Weak_binary_args< _Ty> > ::type> ::type type; 
#line 1572
}; 
#line 1575
template < class _Ty >
 class reference_wrapper
  : public _Weak_types < _Ty > :: type
 {
public :
 static_assert ( is_object < _Ty > :: value || is_function < _Ty > :: value,
  "reference_wrapper<T> requires T to be an object type or a function type."
                       );

 typedef _Ty type;

 reference_wrapper ( _Ty & _Val ) noexcept
  : _Ptr ( :: std :: addressof ( _Val ) )
  {
  }

 operator _Ty & ( ) const noexcept
  {
  return ( * _Ptr );
  }

 _Ty & get ( ) const noexcept
  {
  return ( * _Ptr );
  }

 template < class ... _Types >
  auto operator ( ) ( _Types && ... _Args ) const
  -> decltype ( :: std :: invoke ( get ( ), :: std :: forward < _Types > ( _Args ) ... ) )
  {
  return ( :: std :: invoke ( get ( ), :: std :: forward < _Types > ( _Args ) ... ) );
  }

 reference_wrapper ( _Ty && ) = delete;

private :
 _Ty * _Ptr;
 };
#line 1615
template < class _Ty > inline
 reference_wrapper < _Ty >
  ref ( _Ty & _Val ) noexcept
 {
 return ( reference_wrapper < _Ty > ( _Val ) );
 }
#line 1622
template < class _Ty >
 void ref ( const _Ty && ) = delete;
#line 1625
template < class _Ty > inline
 reference_wrapper < _Ty >
  ref ( reference_wrapper < _Ty > _Val ) noexcept
 {
 return ( :: std :: ref ( _Val . get ( ) ) );
 }
#line 1632
template < class _Ty > inline
 reference_wrapper < const _Ty >
  cref ( const _Ty & _Val ) noexcept
 {
 return ( reference_wrapper < const _Ty > ( _Val ) );
 }
#line 1639
template < class _Ty >
 void cref ( const _Ty && ) = delete;
#line 1642
template < class _Ty > inline
 reference_wrapper < const _Ty >
  cref ( reference_wrapper < _Ty > _Val ) noexcept
 {
 return ( :: std :: cref ( _Val . get ( ) ) );
 }
#line 1650
template< class _Ty> 
#line 1651
struct _Unrefwrap_helper { 
#line 1653
typedef _Ty type; 
#line 1654
static constexpr bool _Is_refwrap = false; 
#line 1655
}; 
#line 1657
template< class _Ty> 
#line 1658
struct _Unrefwrap_helper< reference_wrapper< _Ty> >  { 
#line 1660
typedef _Ty &type; 
#line 1661
static constexpr bool _Is_refwrap = true; 
#line 1662
}; 
#line 1664
template< class _Ty> 
#line 1665
struct _Unrefwrap { 
#line 1667
typedef typename decay< _Ty> ::type _Ty1; 
#line 1668
typedef typename _Unrefwrap_helper< typename decay< _Ty> ::type> ::type type; 
#line 1669
static constexpr bool _Is_refwrap = (_Unrefwrap_helper< typename decay< _Ty> ::type> ::_Is_refwrap); 
#line 1670
}; 
#line 1673
namespace tr1 { 
#line 1674
using std::cref;
#line 1675
using std::ref;
#line 1676
using std::reference_wrapper;
#line 1677
using std::result_of;
#line 1678
}
#line 1682 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< class _Ty> struct _Is_swappable; 
#line 1686
template< class _Ty> struct _Is_nothrow_swappable; 
#line 1695 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template < class _Ty,
 class = void > inline

 void swap ( _Ty &, _Ty & )
  noexcept ( is_nothrow_move_constructible < _Ty > :: value && is_nothrow_move_assignable < _Ty > :: value );
#line 1702 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template < class _Ty,
 size_t _Size,
 class = typename enable_if < _Is_swappable < _Ty > :: value > :: type > inline
 void swap ( _Ty ( & ) [ _Size ], _Ty ( & ) [ _Size ] )
  noexcept ( _Is_nothrow_swappable < _Ty > :: value );
#line 1709
template< class _Ty1, class 
#line 1710
_Ty2, class 
#line 1711
 = void> 
#line 1712
struct _Swappable_with_helper : public false_type { 
#line 1715
}; 
#line 1717
struct _Swappable_with_helper_unique_type { }; 
#line 1718
template< class _Ty1, class 
#line 1719
_Ty2> 
#line 1720
struct _Swappable_with_helper< _Ty1, _Ty2, void_t< _Swappable_with_helper_unique_type, decltype((swap(std::declval< _Ty1> (), std::declval< _Ty2> ())))> >  : public true_type { 
#line 1725
}; 
#line 1728
template< class _Ty1, class 
#line 1729
_Ty2> 
#line 1730
struct _Is_swappable_with : public conjunction< _Swappable_with_helper< _Ty1, _Ty2> , _Swappable_with_helper< _Ty2, _Ty1> > ::type { 
#line 1736
}; 
#line 1739
template< class _Ty> 
#line 1740
struct _Is_swappable : public _Is_swappable_with< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< _Ty> ::type> ::type { 
#line 1745
}; 
#line 1748
template< class _Ty1, class 
#line 1749
_Ty2> 
#line 1750
struct _Swap_cannot_throw { 
#line 1755
static constexpr bool value = (noexcept(swap(std::declval< _Ty1> (), std::declval< _Ty2> ())) && noexcept(swap(std::declval< _Ty2> (), std::declval< _Ty1> ()))); 
#line 1761 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
using type = bool_constant< value> ; 
#line 1762
}; 
#line 1765
template< class _Ty1, class 
#line 1766
_Ty2> 
#line 1767
struct _Is_nothrow_swappable_with : public conjunction< _Is_swappable_with< _Ty1, _Ty2> , _Swap_cannot_throw< _Ty1, _Ty2> > ::type { 
#line 1773
}; 
#line 1776
template< class _Ty> 
#line 1777
struct _Is_nothrow_swappable : public _Is_nothrow_swappable_with< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< _Ty> ::type> ::type { 
#line 1782
}; 
#line 1819 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< class _Ty> using remove_const_t = typename remove_const< _Ty> ::type; 
#line 1822
template< class _Ty> using remove_volatile_t = typename remove_volatile< _Ty> ::type; 
#line 1825
template< class _Ty> using remove_cv_t = typename remove_cv< _Ty> ::type; 
#line 1828
template< class _Ty> using add_const_t = typename add_const< _Ty> ::type; 
#line 1831
template< class _Ty> using add_volatile_t = typename add_volatile< _Ty> ::type; 
#line 1834
template< class _Ty> using add_cv_t = typename add_cv< _Ty> ::type; 
#line 1837
template< class _Ty> using remove_reference_t = typename remove_reference< _Ty> ::type; 
#line 1840
template< class _Ty> using add_lvalue_reference_t = typename add_lvalue_reference< _Ty> ::type; 
#line 1843
template< class _Ty> using add_rvalue_reference_t = typename add_rvalue_reference< _Ty> ::type; 
#line 1846
template< class _Ty> using make_signed_t = typename make_signed< _Ty> ::type; 
#line 1849
template< class _Ty> using make_unsigned_t = typename make_unsigned< _Ty> ::type; 
#line 1852
template< class _Ty> using remove_extent_t = typename remove_extent< _Ty> ::type; 
#line 1855
template< class _Ty> using remove_all_extents_t = typename remove_all_extents< _Ty> ::type; 
#line 1858
template< class _Ty> using remove_pointer_t = typename remove_pointer< _Ty> ::type; 
#line 1861
template< class _Ty> using add_pointer_t = typename add_pointer< _Ty> ::type; 
#line 1864
template< size_t _Len, size_t 
#line 1865
_Align = 8Ui64> using aligned_storage_t = typename aligned_storage< _Len, _Align> ::type; 
#line 1868
template< size_t _Len, class ...
#line 1869
_Types> using aligned_union_t = typename aligned_union< _Len, _Types...> ::type; 
#line 1872
template< class _Ty> using decay_t = typename decay< _Ty> ::type; 
#line 1875
template< bool _Test, class 
#line 1876
_Ty = void> using enable_if_t = typename enable_if< _Test, _Ty> ::type; 
#line 1879
template< bool _Test, class 
#line 1880
_Ty1, class 
#line 1881
_Ty2> using conditional_t = typename conditional< _Test, _Ty1, _Ty2> ::type; 
#line 1884
template< class ..._Ty> using common_type_t = typename common_type< _Ty...> ::type; 
#line 1887
template< class _Ty> using underlying_type_t = typename underlying_type< _Ty> ::type; 
#line 1890
template< class _Ty> using result_of_t = typename result_of< _Ty> ::type; 
#line 1895
template< class _Ty> constexpr bool 
#line 1896
is_void_v = (is_void< _Ty> ::value); 
#line 1897
template< class _Ty> constexpr bool 
#line 1898
is_null_pointer_v = (is_null_pointer< _Ty> ::value); 
#line 1899
template< class _Ty> constexpr bool 
#line 1900
is_array_v = (is_array< _Ty> ::value); 
#line 1901
template< class _Ty> constexpr bool 
#line 1902
is_pointer_v = (is_pointer< _Ty> ::value); 
#line 1903
template< class _Ty> constexpr bool 
#line 1904
is_lvalue_reference_v = (is_lvalue_reference< _Ty> ::value); 
#line 1905
template< class _Ty> constexpr bool 
#line 1906
is_rvalue_reference_v = (is_rvalue_reference< _Ty> ::value); 
#line 1907
template< class _Ty> constexpr bool 
#line 1908
is_member_object_pointer_v = (is_member_object_pointer< _Ty> ::value); 
#line 1909
template< class _Ty> constexpr bool 
#line 1910
is_member_function_pointer_v = (is_member_function_pointer< _Ty> ::value); 
#line 1911
template< class _Ty> constexpr bool 
#line 1912
is_enum_v = (is_enum< _Ty> ::value); 
#line 1913
template< class _Ty> constexpr bool 
#line 1914
is_union_v = (is_union< _Ty> ::value); 
#line 1915
template< class _Ty> constexpr bool 
#line 1916
is_class_v = (is_class< _Ty> ::value); 
#line 1917
template< class _Ty> constexpr bool 
#line 1918
is_reference_v = (is_reference< _Ty> ::value); 
#line 1919
template< class _Ty> constexpr bool 
#line 1920
is_fundamental_v = (is_fundamental< _Ty> ::value); 
#line 1921
template< class _Ty> constexpr bool 
#line 1922
is_object_v = (is_object< _Ty> ::value); 
#line 1923
template< class _Ty> constexpr bool 
#line 1924
is_scalar_v = (is_scalar< _Ty> ::value); 
#line 1925
template< class _Ty> constexpr bool 
#line 1926
is_compound_v = (is_compound< _Ty> ::value); 
#line 1927
template< class _Ty> constexpr bool 
#line 1928
is_member_pointer_v = (is_member_pointer< _Ty> ::value); 
#line 1929
template< class _Ty> constexpr bool 
#line 1930
is_const_v = (is_const< _Ty> ::value); 
#line 1931
template< class _Ty> constexpr bool 
#line 1932
is_volatile_v = (is_volatile< _Ty> ::value); 
#line 1933
template< class _Ty> constexpr bool 
#line 1934
is_trivial_v = (is_trivial< _Ty> ::value); 
#line 1935
template< class _Ty> constexpr bool 
#line 1936
is_trivially_copyable_v = (is_trivially_copyable< _Ty> ::value); 
#line 1937
template< class _Ty> constexpr bool 
#line 1938
is_standard_layout_v = (is_standard_layout< _Ty> ::value); 
#line 1939
template< class _Ty> constexpr bool 
#line 1940
is_pod_v = (is_pod< _Ty> ::value); 
#line 1941
template< class _Ty> constexpr bool 
#line 1942
is_literal_type_v = (is_literal_type< _Ty> ::value); 
#line 1943
template< class _Ty> constexpr bool 
#line 1944
is_empty_v = (is_empty< _Ty> ::value); 
#line 1945
template< class _Ty> constexpr bool 
#line 1946
is_polymorphic_v = (is_polymorphic< _Ty> ::value); 
#line 1947
template< class _Ty> constexpr bool 
#line 1948
is_abstract_v = (is_abstract< _Ty> ::value); 
#line 1949
template< class _Ty> constexpr bool 
#line 1950
is_final_v = (is_final< _Ty> ::value); 
#line 1951
template< class _Ty> constexpr bool 
#line 1952
is_signed_v = (is_signed< _Ty> ::value); 
#line 1953
template< class _Ty> constexpr bool 
#line 1954
is_unsigned_v = (is_unsigned< _Ty> ::value); 
#line 1955
template< class _Ty, class ...
#line 1956
_Args> constexpr bool 
#line 1957
is_constructible_v = (is_constructible< _Ty, _Args...> ::value); 
#line 1958
template< class _Ty> constexpr bool 
#line 1959
is_default_constructible_v = (is_default_constructible< _Ty> ::value); 
#line 1960
template< class _Ty> constexpr bool 
#line 1961
is_copy_constructible_v = (is_copy_constructible< _Ty> ::value); 
#line 1962
template< class _Ty> constexpr bool 
#line 1963
is_move_constructible_v = (is_move_constructible< _Ty> ::value); 
#line 1964
template< class _Ty, class 
#line 1965
_Uty> constexpr bool 
#line 1966
is_assignable_v = (is_assignable< _Ty, _Uty> ::value); 
#line 1967
template< class _Ty> constexpr bool 
#line 1968
is_copy_assignable_v = (is_copy_assignable< _Ty> ::value); 
#line 1969
template< class _Ty> constexpr bool 
#line 1970
is_move_assignable_v = (is_move_assignable< _Ty> ::value); 
#line 1978 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< class _Ty> constexpr bool 
#line 1979
is_destructible_v = (is_destructible< _Ty> ::value); 
#line 1980
template< class _Ty, class ...
#line 1981
_Args> constexpr bool 
#line 1982
is_trivially_constructible_v = (is_trivially_constructible< _Ty, _Args...> ::value); 
#line 1983
template< class _Ty> constexpr bool 
#line 1984
is_trivially_default_constructible_v = (is_trivially_default_constructible< _Ty> ::value); 
#line 1985
template< class _Ty> constexpr bool 
#line 1986
is_trivially_copy_constructible_v = (is_trivially_copy_constructible< _Ty> ::value); 
#line 1987
template< class _Ty> constexpr bool 
#line 1988
is_trivially_move_constructible_v = (is_trivially_move_constructible< _Ty> ::value); 
#line 1989
template< class _Ty, class 
#line 1990
_Uty> constexpr bool 
#line 1991
is_trivially_assignable_v = (is_trivially_assignable< _Ty, _Uty> ::value); 
#line 1992
template< class _Ty> constexpr bool 
#line 1993
is_trivially_copy_assignable_v = (is_trivially_copy_assignable< _Ty> ::value); 
#line 1994
template< class _Ty> constexpr bool 
#line 1995
is_trivially_move_assignable_v = (is_trivially_move_assignable< _Ty> ::value); 
#line 1996
template< class _Ty> constexpr bool 
#line 1997
is_trivially_destructible_v = (is_trivially_destructible< _Ty> ::value); 
#line 1998
template< class _Ty, class ...
#line 1999
_Args> constexpr bool 
#line 2000
is_nothrow_constructible_v = (is_nothrow_constructible< _Ty, _Args...> ::value); 
#line 2001
template< class _Ty> constexpr bool 
#line 2002
is_nothrow_default_constructible_v = (is_nothrow_default_constructible< _Ty> ::value); 
#line 2003
template< class _Ty> constexpr bool 
#line 2004
is_nothrow_copy_constructible_v = (is_nothrow_copy_constructible< _Ty> ::value); 
#line 2005
template< class _Ty> constexpr bool 
#line 2006
is_nothrow_move_constructible_v = (is_nothrow_move_constructible< _Ty> ::value); 
#line 2007
template< class _Ty, class 
#line 2008
_Uty> constexpr bool 
#line 2009
is_nothrow_assignable_v = (is_nothrow_assignable< _Ty, _Uty> ::value); 
#line 2010
template< class _Ty> constexpr bool 
#line 2011
is_nothrow_copy_assignable_v = (is_nothrow_copy_assignable< _Ty> ::value); 
#line 2012
template< class _Ty> constexpr bool 
#line 2013
is_nothrow_move_assignable_v = (is_nothrow_move_assignable< _Ty> ::value); 
#line 2021 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
template< class _Ty> constexpr bool 
#line 2022
is_nothrow_destructible_v = (is_nothrow_destructible< _Ty> ::value); 
#line 2023
template< class _Ty> constexpr bool 
#line 2024
has_virtual_destructor_v = (has_virtual_destructor< _Ty> ::value); 
#line 2025
template< class _Ty> constexpr size_t 
#line 2026
alignment_of_v = (alignment_of< _Ty> ::value); 
#line 2027
template< class _Ty> constexpr size_t 
#line 2028
rank_v = (rank< _Ty> ::value); 
#line 2029
template< class _Ty, unsigned 
#line 2030
_Ix = 0U> constexpr size_t 
#line 2031
extent_v = (extent< _Ty, _Ix> ::value); 
#line 2032
template< class _Base, class 
#line 2033
_Derived> constexpr bool 
#line 2034
is_base_of_v = (is_base_of< _Base, _Derived> ::value); 
#line 2035
template< class _From, class 
#line 2036
_To> constexpr bool 
#line 2037
is_convertible_v = (is_convertible< _From, _To> ::value); 
#line 2038
template< class ..._Traits> constexpr bool 
#line 2039
conjunction_v = (conjunction< _Traits...> ::value); 
#line 2040
template< class ..._Traits> constexpr bool 
#line 2041
disjunction_v = (disjunction< _Traits...> ::value); 
#line 2042
template< class _Trait> constexpr bool 
#line 2043
negation_v = (negation< _Trait> ::value); 
#line 2046 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
}
#line 2049
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception"
#pragma warning(push,3)
#line 2050 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\type_traits"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception"
__declspec(dllimport) bool __cdecl uncaught_exception() noexcept; 
#line 34
__declspec(dllimport) int __cdecl uncaught_exceptions() noexcept; 
#line 36
}
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
typedef 
#line 39
struct _heapinfo { 
#line 41
int *_pentry; 
#line 42
size_t _size; 
#line 43
int _useflag; 
#line 44
} _HEAPINFO; 
#line 54
void *__cdecl _alloca(size_t _Size); 
#line 60
__declspec(dllimport) intptr_t __cdecl _get_heap_handle(); 
#line 63
__declspec(dllimport) int __cdecl _heapmin(); 
#line 66
__declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * _EntryInfo); 
#line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
__declspec(dllimport) int __cdecl _heapchk(); 
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
__declspec(dllimport) int __cdecl _resetstkoflw(); 
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
typedef char __static_assert_t[(sizeof(unsigned) <= (16)) != 0]; 
#line 88
#pragma warning(push)
#pragma warning(disable:6540)
#line 91
__inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
#line 92
{ 
#line 93
if (_Ptr) 
#line 94
{ 
#line 95
(*((unsigned *)_Ptr)) = _Marker; 
#line 96
_Ptr = (((char *)_Ptr) + 16); 
#line 97
}  
#line 98
return _Ptr; 
#line 99
} 
#line 101
__inline size_t _MallocaComputeSize(size_t _Size) 
#line 102
{ 
#line 103
size_t _MarkedSize = _Size + (16); 
#line 104
return (_MarkedSize > _Size) ? _MarkedSize : (0); 
#line 105
} 
#line 107
#pragma warning(pop)
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 6014)
__inline void __cdecl _freea(void *_Memory) 
#line 148
{ 
#line 149
unsigned _Marker; 
#line 150
if (_Memory) 
#line 151
{ 
#line 152
_Memory = (((char *)_Memory) - 16); 
#line 153
_Marker = (*((unsigned *)_Memory)); 
#line 154
if (_Marker == (56797)) 
#line 155
{ 
#line 156
free(_Memory); 
#line 157
}  
#line 164
}  
#line 165
} 
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
}
#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
#pragma warning(pop)
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\malloc.h"
__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 18
typedef void (__cdecl *terminate_handler)(void); 
#line 19
typedef void (__cdecl *terminate_function)(void); 
#line 28
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(); 
#line 29
__declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw(); 
#line 33
__declspec(dllimport) terminate_handler __cdecl set_terminate(terminate_handler _NewTerminateHandler) throw(); 
#line 37
__declspec(dllimport) terminate_handler __cdecl _get_terminate(); 
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\corecrt_terminate.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
typedef void (__cdecl *unexpected_handler)(void); 
#line 20
typedef void (__cdecl *unexpected_function)(void); 
#line 27
struct _EXCEPTION_POINTERS; 
#line 31
__declspec(dllimport) __declspec(noreturn) void __cdecl unexpected() throw(...); 
#line 35
__declspec(dllimport) unexpected_handler __cdecl set_unexpected(unexpected_handler _NewUnexpectedHandler) throw(); 
#line 39
__declspec(dllimport) unexpected_handler __cdecl _get_unexpected(); 
#line 41
typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 43
__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(_se_translator_function _NewSETranslator); 
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h"
class type_info; 
#line 51
__declspec(dllimport) int __cdecl _is_exception_typeof(const type_info & _Type, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 56
__declspec(dllimport) bool __cdecl __uncaught_exception(); 
#line 57
__declspec(dllimport) int __cdecl __uncaught_exceptions(); 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\eh.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h"
#pragma pack ( push, 8 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 21
struct __std_exception_data { 
#line 23
const char *_What; 
#line 24
bool _DoFree; 
#line 25
}; 
#line 27
__declspec(dllimport) void __cdecl __std_exception_copy(const __std_exception_data * _From, __std_exception_data * _To); 
#line 32
__declspec(dllimport) void __cdecl __std_exception_destroy(__std_exception_data * _Data); 
#line 36
}__pragma( pack ( pop )) 
#line 40
namespace std { 
#line 42
class exception { 
#line 46
public: exception() throw() : _Data() 
#line 48
{ 
#line 49
} 
#line 51
explicit exception(const char *const _Message) throw() : _Data() 
#line 53
{ 
#line 54
__std_exception_data _InitData = {_Message, true}; 
#line 55
__std_exception_copy(&_InitData, &(_Data)); 
#line 56
} 
#line 58
exception(const char *const _Message, int) throw() : _Data() 
#line 60
{ 
#line 61
((_Data)._What) = _Message; 
#line 62
} 
#line 64
exception(const exception &_Other) throw() : _Data() 
#line 66
{ 
#line 67
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 68
} 
#line 70
exception &operator=(const exception &_Other) throw() 
#line 71
{ 
#line 72
if (this == (&_Other)) 
#line 73
{ 
#line 74
return *this; 
#line 75
}  
#line 77
__std_exception_destroy(&(_Data)); 
#line 78
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 79
return *this; 
#line 80
} 
#line 82
virtual ~exception() throw() 
#line 83
{ 
#line 84
__std_exception_destroy(&(_Data)); 
#line 85
} 
#line 87
virtual const char *what() const 
#line 88
{ 
#line 89
return ((_Data)._What) ? (_Data)._What : ("Unknown exception"); 
#line 90
} 
#line 94
private: __std_exception_data _Data; 
#line 95
}; 
#line 97
class bad_exception : public exception { 
#line 102
public: bad_exception() throw() : exception("bad exception", 1) 
#line 104
{ 
#line 105
} 
#line 106
}; 
#line 108
class bad_alloc : public exception { 
#line 113
public: bad_alloc() throw() : exception("bad allocation", 1) 
#line 115
{ 
#line 116
} 
#line 120
friend class bad_array_new_length; 
#line 122
private: bad_alloc(const char *const _Message) throw() : exception(_Message, 1) 
#line 124
{ 
#line 125
} 
#line 126
}; 
#line 128
class bad_array_new_length : public bad_alloc { 
#line 133
public: bad_array_new_length() throw() : bad_alloc("bad array new length") 
#line 135
{ 
#line 136
} 
#line 137
}; 
#line 139
}
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_exception.h"
#pragma pack ( pop )
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception"
namespace std { 
#line 45
using ::set_terminate;using ::terminate_handler;using ::terminate;using ::set_unexpected;using ::unexpected_handler;using ::unexpected;
#line 47
typedef void (__cdecl *_Prhand)(const exception &); 
#line 50
inline terminate_handler __cdecl get_terminate() noexcept 
#line 51
{ 
#line 52
return _get_terminate(); 
#line 53
} 
#line 55
inline unexpected_handler __cdecl get_unexpected() noexcept 
#line 56
{ 
#line 57
return _get_unexpected(); 
#line 58
} 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception"
}
#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\exception"
__declspec(dllimport) void __cdecl __ExceptionPtrCreate(void *); 
#line 241
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(void *); 
#line 242
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(void *, const void *); 
#line 243
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(void *, const void *); 
#line 244
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(const void *, const void *); 
#line 245
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(const void *); 
#line 246
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(void *, void *); 
#line 247
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(void *); 
#line 248
[[noreturn]] __declspec(dllimport) void __cdecl __ExceptionPtrRethrow(const void *); 
#line 249
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *); 
#line 252
namespace std { 
#line 254
class exception_ptr { 
#line 257
public: exception_ptr() throw() 
#line 258
{ 
#line 259
__ExceptionPtrCreate(this); 
#line 260
} 
#line 262
exception_ptr(nullptr_t) throw() 
#line 263
{ 
#line 264
__ExceptionPtrCreate(this); 
#line 265
} 
#line 267
~exception_ptr() throw() 
#line 268
{ 
#line 269
__ExceptionPtrDestroy(this); 
#line 270
} 
#line 272
exception_ptr(const exception_ptr &_Rhs) throw() 
#line 273
{ 
#line 274
__ExceptionPtrCopy(this, &_Rhs); 
#line 275
} 
#line 277
exception_ptr &operator=(const exception_ptr &_Rhs) throw() 
#line 278
{ 
#line 279
__ExceptionPtrAssign(this, &_Rhs); 
#line 280
return *this; 
#line 281
} 
#line 283
exception_ptr &operator=(nullptr_t) throw() 
#line 284
{ 
#line 285
exception_ptr _Ptr; 
#line 286
__ExceptionPtrAssign(this, &_Ptr); 
#line 287
return *this; 
#line 288
} 
#line 290
explicit operator bool() const throw() 
#line 291
{ 
#line 292
return __ExceptionPtrToBool(this); 
#line 293
} 
#line 295
[[noreturn]] void _RethrowException() const 
#line 296
{ 
#line 297
__ExceptionPtrRethrow(this); 
#line 298
} 
#line 300
static exception_ptr _Current_exception() throw() 
#line 301
{ 
#line 302
exception_ptr _Retval; 
#line 303
__ExceptionPtrCurrentException(&_Retval); 
#line 304
return _Retval; 
#line 305
} 
#line 307
static exception_ptr _Copy_exception(void *_Except, const void *_Ptr) 
#line 308
{ 
#line 309
exception_ptr _Retval = 0; 
#line 310
if (!_Ptr) 
#line 311
{ 
#line 313
return _Retval; 
#line 314
}  
#line 315
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
#line 316
return _Retval; 
#line 317
} 
#line 320
private: void *_Data1; 
#line 321
void *_Data2; 
#line 322
}; 
#line 324
inline void swap(exception_ptr &_Lhs, exception_ptr &_Rhs) throw() 
#line 325
{ 
#line 326
__ExceptionPtrSwap(&_Lhs, &_Rhs); 
#line 327
} 
#line 329
inline bool operator==(const exception_ptr &_Lhs, const exception_ptr &_Rhs) throw() 
#line 330
{ 
#line 331
return __ExceptionPtrCompare(&_Lhs, &_Rhs); 
#line 332
} 
#line 334
inline bool operator==(nullptr_t, const exception_ptr &_Rhs) throw() 
#line 335
{ 
#line 336
return !_Rhs; 
#line 337
} 
#line 339
inline bool operator==(const exception_ptr &_Lhs, nullptr_t) throw() 
#line 340
{ 
#line 341
return !_Lhs; 
#line 342
} 
#line 344
inline bool operator!=(const exception_ptr &_Lhs, const exception_ptr &_Rhs) throw() 
#line 345
{ 
#line 346
return !((_Lhs == _Rhs)); 
#line 347
} 
#line 349
inline bool operator!=(nullptr_t _Lhs, const exception_ptr &_Rhs) throw() 
#line 350
{ 
#line 351
return !((_Lhs == _Rhs)); 
#line 352
} 
#line 354
inline bool operator!=(const exception_ptr &_Lhs, nullptr_t _Rhs) throw() 
#line 355
{ 
#line 356
return !((_Lhs == _Rhs)); 
#line 357
} 
#line 359
inline exception_ptr current_exception() noexcept 
#line 360
{ 
#line 361
return exception_ptr::_Current_exception(); 
#line 362
} 
#line 364
[[noreturn]] inline void rethrow_exception(exception_ptr _Ptr) 
#line 365
{ 
#line 366
_Ptr._RethrowException(); 
#line 367
} 
#line 369
template< class _Ex> void *__GetExceptionInfo(_Ex); 
#line 371
template < class _Ex > exception_ptr make_exception_ptr ( _Ex _Except ) noexcept
 {
 return exception_ptr :: _Copy_exception ( :: std :: addressof ( _Except ), __GetExceptionInfo ( _Except ) );
 }
#line 377
class nested_exception { 
#line 380
public: nested_exception() noexcept : _Exc(::std::current_exception()) 
#line 382
{ 
#line 383
} 
#line 385
nested_exception(const nested_exception &) noexcept = default;
#line 386
nested_exception &operator=(const nested_exception &) noexcept = default;
#line 387
virtual ~nested_exception() noexcept = default;
#line 389
[[noreturn]] void rethrow_nested() const 
#line 390
{ 
#line 391
if ((_Exc)) { 
#line 392
::std::rethrow_exception(_Exc); } else { 
#line 394
::std::terminate(); }  
#line 395
} 
#line 397
exception_ptr nested_ptr() const noexcept 
#line 398
{ 
#line 399
return _Exc; 
#line 400
} 
#line 403
private: exception_ptr _Exc; 
#line 404
}; 
#line 407
template < class _Ty,
 class _Uty >
 struct _With_nested
  : _Uty, nested_exception
 {
 explicit _With_nested ( _Ty && _Arg )
  : _Uty ( :: std :: forward < _Ty > ( _Arg ) ), nested_exception ( )
  {
  }
 };
#line 418
template < class _Ty >
 [ [ noreturn ] ] inline void _Throw_with_nested ( _Ty && _Arg, true_type )
 {
 typedef typename remove_reference < _Ty > :: type _Uty;
 typedef _With_nested < _Ty, _Uty > _Glued;

 throw _Glued ( :: std :: forward < _Ty > ( _Arg ) );
 }
#line 427
template < class _Ty >
 [ [ noreturn ] ] inline void _Throw_with_nested ( _Ty && _Arg, false_type )
 {
 typedef typename decay < _Ty > :: type _Decayed;

 throw _Decayed ( :: std :: forward < _Ty > ( _Arg ) );
 }
#line 435
template < class _Ty >
 [ [ noreturn ] ] inline void throw_with_nested ( _Ty && _Arg )
 {
 typedef typename remove_reference < _Ty > :: type _Uty;

 integral_constant < bool,
  is_class < _Uty > :: value
  && ! is_base_of < nested_exception, _Uty > :: value
  && ! is_final < _Uty > :: value > _Tag;

 _Throw_with_nested ( :: std :: forward < _Ty > ( _Arg ), _Tag );
 }
#line 449
template < class _Ty > inline
 void _Rethrow_if_nested ( const _Ty * _Ptr, true_type )
 {
 const auto _Nested = dynamic_cast < const nested_exception * > ( _Ptr );

 if ( _Nested )
  _Nested -> rethrow_nested ( );
 }
#line 458
template < class _Ty > inline
 void _Rethrow_if_nested ( const _Ty *, false_type )
 {
 }
#line 463
template < class _Ty > inline
 void rethrow_if_nested ( const _Ty & _Arg )
 {
 integral_constant < bool,
  is_polymorphic < _Ty > :: value
  && ( ! is_base_of < nested_exception, _Ty > :: value
   || is_convertible < _Ty *, nested_exception * > :: value ) > _Tag;

 _Rethrow_if_nested ( :: std :: addressof ( _Arg ), _Tag );
 }
#line 473
}
#line 476
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h"
extern "C++" {
#line 17
#pragma warning(push)
#pragma warning(disable: 4985)
#line 15
#pragma pack ( push, 8 )
#line 25
namespace std { 
#line 27
struct nothrow_t { }; 
#line 29
extern const nothrow_t nothrow; 
#line 30
}
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h"
__declspec(allocator) void *__cdecl operator new(size_t _Size); 
#line 39
__declspec(allocator) void *__cdecl operator new(size_t _Size, const std::nothrow_t &) throw(); 
#line 45
__declspec(allocator) void *__cdecl operator new[](size_t _Size); 
#line 50
__declspec(allocator) void *__cdecl operator new[](size_t _Size, const std::nothrow_t &) throw(); 
#line 55
void __cdecl operator delete(void * _Block) throw(); 
#line 59
void __cdecl operator delete(void * _Block, const std::nothrow_t &) throw(); 
#line 64
void __cdecl operator delete[](void * _Block) throw(); 
#line 68
void __cdecl operator delete[](void * _Block, const std::nothrow_t &) throw(); 
#line 73
void __cdecl operator delete(void * _Block, size_t _Size) throw(); 
#line 78
void __cdecl operator delete[](void * _Block, size_t _Size) throw(); 
#line 86
inline void *__cdecl operator new(size_t _Size, void *_Where) throw() 
#line 87
{ 
#line 88
(void)_Size; 
#line 89
return _Where; 
#line 90
} 
#line 92
inline void __cdecl operator delete(void *, void *) throw() 
#line 93
{ 
#line 95
} 
#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h"
inline void *__cdecl operator new[](size_t _Size, void *_Where) throw() 
#line 102
{ 
#line 103
(void)_Size; 
#line 104
return _Where; 
#line 105
} 
#line 107
inline void __cdecl operator delete[](void *, void *) throw() 
#line 108
{ 
#line 109
} 
#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h"
}
#line 114
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\new"
#pragma warning(push,3)
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new.h"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\new"
#pragma pack ( push, 8 )
#line 17
namespace std { 
#line 22
typedef void (__cdecl *new_handler)(void); 
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\new"
__declspec(dllimport) new_handler __cdecl set_new_handler(new_handler) noexcept; 
#line 29
__declspec(dllimport) new_handler __cdecl get_new_handler() noexcept; 
#line 31
}
#line 34
#pragma warning(pop)
#pragma pack ( pop )
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstdio"
extern "C" { typedef FILE FILE; }
#line 35
namespace std { 
#line 36
using ::FILE;
#line 38
using ::fpos_t;
#line 39
using ::clearerr;using ::fclose;using ::feof;
#line 40
using ::ferror;using ::fflush;using ::fgetc;
#line 41
using ::fgetpos;using ::fgets;using ::fopen;
#line 42
using ::fprintf;using ::fputc;using ::fputs;
#line 43
using ::fread;using ::freopen;using ::fscanf;
#line 44
using ::fseek;using ::fsetpos;using ::ftell;
#line 45
using ::fwrite;using ::getc;using ::getchar;
#line 46
using ::perror;
#line 47
using ::putc;using ::putchar;
#line 48
using ::printf;using ::puts;using ::remove;
#line 49
using ::rename;using ::rewind;using ::scanf;
#line 50
using ::setbuf;using ::setvbuf;using ::sprintf;
#line 51
using ::sscanf;using ::tmpfile;using ::tmpnam;
#line 52
using ::ungetc;using ::vfprintf;using ::vprintf;
#line 53
using ::vsprintf;
#line 55
using ::snprintf;using ::vsnprintf;
#line 56
using ::vfscanf;using ::vscanf;using ::vsscanf;
#line 57
}
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\cstring"
namespace std { 
#line 18
using ::memchr;using ::memcmp;
#line 19
using ::memcpy;using ::memmove;using ::memset;
#line 20
using ::strcat;using ::strchr;using ::strcmp;
#line 21
using ::strcoll;using ::strcpy;using ::strcspn;
#line 22
using ::strerror;using ::strlen;using ::strncat;
#line 23
using ::strncmp;using ::strncpy;using ::strpbrk;
#line 24
using ::strrchr;using ::strspn;using ::strstr;
#line 25
using ::strtok;using ::strxfrm;
#line 26
}
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new_debug.h"
extern "C++" {
#line 15
#pragma pack ( push, 8 )
#line 23
__declspec(allocator) void *__cdecl operator new(size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 31
__declspec(allocator) void *__cdecl operator new[](size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 38
void __cdecl operator delete(void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) throw(); 
#line 45
void __cdecl operator delete[](void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) throw(); 
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vcruntime_new_debug.h"
}
#line 56
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 18
typedef void *_HFILE; 
#line 44
typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); 
#line 45
typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); 
#line 51
typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); 
#line 107
typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); 
#line 113
struct _CrtMemBlockHeader; 
#line 122
typedef 
#line 115
struct _CrtMemState { 
#line 117
_CrtMemBlockHeader *pBlockHeader; 
#line 118
size_t lCounts[5]; 
#line 119
size_t lSizes[5]; 
#line 120
size_t lHighWaterCount; 
#line 121
size_t lTotalCount; 
#line 122
} _CrtMemState; 
#line 151
__declspec(dllimport) int *__cdecl __p__crtDbgFlag(); 
#line 152
__declspec(dllimport) long *__cdecl __p__crtBreakAlloc(); 
#line 157
__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(); 
#line 159
__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(_CRT_ALLOC_HOOK _PfnNewHook); 
#line 163
__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(); 
#line 165
__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(_CRT_DUMP_CLIENT _PFnNewDump); 
#line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h"
__declspec(dllimport) int __cdecl _CrtCheckMemory(); 
#line 173
typedef void (__cdecl *_CrtDoForAllClientObjectsCallback)(void *, void *); 
#line 175
__declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(_CrtDoForAllClientObjectsCallback _Callback, void * _Context); 
#line 180
__declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(); 
#line 182
__declspec(dllimport) int __cdecl _CrtIsMemoryBlock(const void * _Block, unsigned _Size, long * _RequestNumber, char ** _FileName, int * _LineNumber); 
#line 191
__declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(const void * _Pointer); 
#line 196
__declspec(dllimport) int __cdecl _CrtIsValidPointer(const void * _Pointer, unsigned _Size, int _ReadWrite); 
#line 202
__declspec(dllimport) void __cdecl _CrtMemCheckpoint(_CrtMemState * _State); 
#line 206
__declspec(dllimport) int __cdecl _CrtMemDifference(_CrtMemState * _State, const _CrtMemState * _OldState, const _CrtMemState * _NewState); 
#line 212
__declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(const _CrtMemState * _State); 
#line 216
__declspec(dllimport) void __cdecl _CrtMemDumpStatistics(const _CrtMemState * _State); 
#line 221
__declspec(dllimport) int __cdecl _CrtReportBlockType(const void * _Block); 
#line 225
__declspec(dllimport) long __cdecl _CrtSetBreakAlloc(long _NewValue); 
#line 229
__declspec(dllimport) int __cdecl _CrtSetDbgFlag(int _NewFlag); 
#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h"
__declspec(dllimport) void __cdecl _aligned_free_dbg(void * _Block); 
#line 332
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_malloc_dbg(size_t _Size, size_t _Alignment, const char * _FileName, int _LineNumber); 
#line 339
__declspec(dllimport) size_t __cdecl _aligned_msize_dbg(void * _Block, size_t _Alignment, size_t _Offset); 
#line 346
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_offset_malloc_dbg(size_t _Size, size_t _Alignment, size_t _Offset, const char * _FileName, int _LineNumber); 
#line 355
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_offset_realloc_dbg(void * _Block, size_t _Size, size_t _Alignment, size_t _Offset, const char * _FileName, int _LineNumber); 
#line 365
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_offset_recalloc_dbg(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset, const char * _FileName, int _LineNumber); 
#line 376
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_realloc_dbg(void * _Block, size_t _Size, size_t _Alignment, const char * _FileName, int _LineNumber); 
#line 385
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_recalloc_dbg(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, const char * _FileName, int _LineNumber); 
#line 395
__declspec(dllimport) __declspec(allocator) void *__cdecl _calloc_dbg(size_t _Count, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 404
__declspec(dllimport) __declspec(allocator) void *__cdecl _expand_dbg(void * _Block, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 412
__declspec(dllimport) void __cdecl _free_dbg(void * _Block, int _BlockUse); 
#line 418
__declspec(dllimport) __declspec(allocator) void *__cdecl _malloc_dbg(size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 425
__declspec(dllimport) size_t __cdecl _msize_dbg(void * _Block, int _BlockUse); 
#line 431
__declspec(dllimport) __declspec(allocator) void *__cdecl _realloc_dbg(void * _Block, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 440
__declspec(dllimport) __declspec(allocator) void *__cdecl _recalloc_dbg(void * _Block, size_t _Count, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 451
__declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(char ** _PBuffer, size_t * _PBufferSizeInBytes, const char * _VarName, int _BlockType, const char * _FileName, int _LineNumber); 
#line 462
__declspec(dllimport) __declspec(allocator) char *__cdecl _fullpath_dbg(char * _FullPath, const char * _Path, size_t _SizeInBytes, int _BlockType, const char * _FileName, int _LineNumber); 
#line 473
__declspec(dllimport) __declspec(allocator) char *__cdecl _getcwd_dbg(char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _FileName, int _LineNumber); 
#line 484
__declspec(dllimport) __declspec(allocator) char *__cdecl _getdcwd_dbg(int _Drive, char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _FileName, int _LineNumber); 
#line 494
__declspec(dllimport) __declspec(allocator) char *__cdecl _strdup_dbg(const char * _String, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 502
__declspec(dllimport) __declspec(allocator) char *__cdecl _tempnam_dbg(const char * _DirName, const char * _FilePrefix, int _BlockType, const char * _FileName, int _LineNumber); 
#line 512
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wcsdup_dbg(const __wchar_t * _String, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 521
__declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(__wchar_t ** _PBuffer, size_t * _PBufferSizeInWords, const __wchar_t * _VarName, int _BlockType, const char * _FileName, int _LineNumber); 
#line 532
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wfullpath_dbg(__wchar_t * _FullPath, const __wchar_t * _Path, size_t _SizeInWords, int _BlockType, const char * _FileName, int _LineNumber); 
#line 543
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetcwd_dbg(__wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _FileName, int _LineNumber); 
#line 553
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetdcwd_dbg(int _Drive, __wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _FileName, int _LineNumber); 
#line 563
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wtempnam_dbg(const __wchar_t * _DirName, const __wchar_t * _FilePrefix, int _BlockType, const char * _FileName, int _LineNumber); 
#line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h"
__declspec(dllimport) int __cdecl _CrtDbgReport(int _ReportType, const char * _FileName, int _Linenumber, const char * _ModuleName, const char * _Format, ...); 
#line 614
__declspec(dllimport) int __cdecl _CrtDbgReportW(int _ReportType, const __wchar_t * _FileName, int _LineNumber, const __wchar_t * _ModuleName, const __wchar_t * _Format, ...); 
#line 623
__declspec(dllimport) int __cdecl _VCrtDbgReportA(int _ReportType, void * _ReturnAddress, const char * _FileName, int _LineNumber, const char * _ModuleName, const char * _Format, va_list _ArgList); 
#line 633
__declspec(dllimport) int __cdecl _VCrtDbgReportW(int _ReportType, void * _ReturnAddress, const __wchar_t * _FileName, int _LineNumber, const __wchar_t * _ModuleName, const __wchar_t * _Format, va_list _ArgList); 
#line 643
__declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(size_t _NewDebugFillThreshold); 
#line 647
__declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(); 
#line 649
__declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(int _ReportType, _HFILE _ReportFile); 
#line 654
__declspec(dllimport) int __cdecl _CrtSetReportMode(int _ReportType, int _ReportMode); 
#line 661
extern long _crtAssertBusy; 
#line 663
__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(); 
#line 668
__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(_CRT_REPORT_HOOK _PFnNewHook); 
#line 672
__declspec(dllimport) int __cdecl _CrtSetReportHook2(int _Mode, _CRT_REPORT_HOOK _PFnNewHook); 
#line 677
__declspec(dllimport) int __cdecl _CrtSetReportHookW2(int _Mode, _CRT_REPORT_HOOKW _PFnNewHook); 
#line 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h"
}
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
#pragma warning(push,3)
#line 808 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.16299.0\\ucrt\\crtdbg.h"
__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 21
typedef _Longlong streamoff; 
#line 22
typedef _Longlong streamsize; 
#line 31
__declspec(dllimport) extern const streamoff _BADOFF; 
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
template < class _Statetype >
 class fpos
 {
 typedef fpos < _Statetype > _Myt;

public :
  fpos ( streamoff _Off = 0 )
  : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( )
  {
  }

  fpos ( _Statetype _State, fpos_t _Fileposition )
  : _Myoff ( 0 ), _Fpos ( _Fileposition ), _Mystate ( _State )
  {
  }

 _Statetype state ( ) const
  {
  return ( _Mystate );
  }

 void state ( _Statetype _State )
  {
  _Mystate = _State;
  }

 fpos_t seekpos ( ) const
  {
  return ( _Fpos );
  }

  operator streamoff ( ) const
  {
  return ( ( streamoff ) ( _Myoff + ( ( long long ) ( _Fpos ) ) ) );
  }

 streamoff operator - ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this - ( streamoff ) _Right );
  }

 _Myt & operator += ( streamoff _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

 _Myt & operator -= ( streamoff _Off )
  {
  _Myoff -= _Off;
  return ( * this );
  }

 _Myt operator + ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt operator - ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this == ( streamoff ) _Right );
  }

 bool operator == ( streamoff _Right ) const
  {
  return ( ( streamoff ) * this == _Right );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

private :
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };
#line 126
typedef fpos< _Mbstatet>  streampos; 
#line 128
typedef streampos wstreampos; 
#line 131
template < class _Elem,
 class _Int_type >
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare (
    const _Elem * _First1,
    const _Elem * _First2, size_t _Count )
  {
  for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 )
   if ( ! eq ( * _First1, * _First2 ) )
    return ( lt ( * _First1, * _First2 ) ? - 1 : + 1 );
  return ( 0 );
  }

 static size_t __cdecl length ( const _Elem * _First )
  {
  size_t _Count;
  for ( _Count = 0; ! eq ( * _First, _Elem ( ) ); ++ _First )
   ++ _Count;
  return ( _Count );
  }

 static _Elem * __cdecl copy (
    _Elem * _First1,
    const _Elem * _First2, size_t _Count )
  {
  _Elem * _Next = _First1;
  for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
   assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl _Copy_s (
    _Elem * _First1, size_t _Dest_size,
    const _Elem * _First2, size_t _Count )
  {
  { if ( ! ( _Count <= _Dest_size ) ) { ( void ) ( ( ! ! ( ( "_Count <= _Dest_size" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69" L"\x6f\x73\x66\x77\x64", 173, 0, L"\x25\x6c\x73", L"\x22\x5f\x43\x6f\x75\x6e\x74\x20\x3c\x3d\x20\x5f\x44\x65\x73\x74\x5f\x73\x69\x7a\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x5f\x43\x6f\x75\x6e\x74\x20\x3c\x3d\x20\x5f\x44\x65\x73\x74\x5f\x73\x69\x7a\x65", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x69" L"\x6f\x73\x66\x77\x64", 173, 0 ); return ( 0 ); } };
  return ( copy ( _First1, _First2, _Count ) );
  }

 static const _Elem * __cdecl find (
    const _Elem * _First,
  size_t _Count, const _Elem & _Ch )
  {
  for (; 0 < _Count; -- _Count, ++ _First )
   if ( eq ( * _First, _Ch ) )
    return ( _First );
  return ( 0 );
  }

 static _Elem * __cdecl move (
    _Elem * _First1,
    const _Elem * _First2, size_t _Count )
  {
  _Elem * _Next = _First1;
  if ( _First2 < _Next && _Next < _First2 + _Count )
   for ( _Next += _Count, _First2 += _Count; 0 < _Count; -- _Count )
    assign ( * -- _Next, * -- _First2 );
  else
   for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
    assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl assign (
    _Elem * _First,
  size_t _Count, _Elem _Ch )
  {
  _Elem * _Next = _First;
  for (; 0 < _Count; -- _Count, ++ _Next )
   assign ( * _Next, _Ch );
  return ( _First );
  }

 static void __cdecl assign ( _Elem & _Left, const _Elem & _Right ) noexcept
  {
  _Left = _Right;
  }

 static constexpr bool __cdecl eq ( const _Elem & _Left,
  const _Elem & _Right ) noexcept
  {
  return ( _Left == _Right );
  }

 static constexpr bool __cdecl lt ( const _Elem & _Left,
  const _Elem & _Right ) noexcept
  {
  return ( _Left < _Right );
  }

 static constexpr _Elem __cdecl to_char_type (
  const int_type & _Meta ) noexcept
  {
  return ( ( _Elem ) _Meta );
  }

 static constexpr int_type __cdecl to_int_type (
  const _Elem & _Ch ) noexcept
  {
  return ( ( int_type ) _Ch );
  }

 static constexpr bool __cdecl eq_int_type ( const int_type & _Left,
  const int_type & _Right ) noexcept
  {
  return ( _Left == _Right );
  }

 static constexpr int_type __cdecl not_eof (
  const int_type & _Meta ) noexcept
  {
  return ( _Meta != eof ( ) ? ( int_type ) _Meta : ( int_type ) ! eof ( ) );
  }

 static constexpr int_type __cdecl eof ( ) noexcept
  {
  return ( ( int_type ) ( - 1 ) );
  }
 };
#line 259
template< class _Elem> 
#line 260
struct char_traits : public _Char_traits< _Elem, long>  { 
#line 263
}; 
#line 267
template<> struct char_traits< char16_t>  : public _Char_traits< char16_t, unsigned short>  { 
#line 270
}; 
#line 272
typedef streampos u16streampos; 
#line 276
template<> struct char_traits< char32_t>  : public _Char_traits< char32_t, unsigned>  { 
#line 279
}; 
#line 281
typedef streampos u32streampos; 
#line 285
template<> struct char_traits< __wchar_t>  { 
#line 287
typedef __wchar_t _Elem; 
#line 288
typedef _Elem char_type; 
#line 289
typedef wint_t int_type; 
#line 290
typedef streampos pos_type; 
#line 291
typedef streamoff off_type; 
#line 292
typedef _Mbstatet state_type; 
#line 294
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 295
_Count) 
#line 296
{ 
#line 297
return (_Count == (0)) ? 0 : ::wmemcmp(_First1, _First2, _Count); 
#line 299
} 
#line 301
static size_t __cdecl length(const _Elem *_First) 
#line 302
{ 
#line 303
return ((*_First) == 0) ? 0 : ::wcslen(_First); 
#line 305
} 
#line 307
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 308
_Count) 
#line 309
{ 
#line 310
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemcpy(_First1, _First2, _Count)); 
#line 312
} 
#line 314
static _Elem *__cdecl _Copy_s(_Elem *
#line 315
_First1, size_t _Size_in_words, const _Elem *
#line 316
_First2, size_t _Count) 
#line 317
{ 
#line 318
if ((0) < _Count) { 
#line 319
::wmemcpy_s(_First1, _Size_in_words, _First2, _Count); }  
#line 320
return _First1; 
#line 321
} 
#line 323
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 324
_Ch) 
#line 325
{ 
#line 326
return (_Count == (0)) ? (const _Elem *)0 : ((const _Elem *)::wmemchr(_First, _Ch, _Count)); 
#line 328
} 
#line 330
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 331
_Count) 
#line 332
{ 
#line 333
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemmove(_First1, _First2, _Count)); 
#line 335
} 
#line 337
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem 
#line 338
_Ch) 
#line 339
{ 
#line 340
return (_Elem *)::wmemset(_First, _Ch, _Count); 
#line 341
} 
#line 343
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) noexcept 
#line 344
{ 
#line 345
_Left = _Right; 
#line 346
} 
#line 348
static constexpr bool __cdecl eq(const _Elem &_Left, const _Elem &
#line 349
_Right) noexcept 
#line 350
{ 
#line 351
return _Left == _Right; 
#line 352
} 
#line 354
static constexpr bool __cdecl lt(const _Elem &_Left, const _Elem &
#line 355
_Right) noexcept 
#line 356
{ 
#line 357
return _Left < _Right; 
#line 358
} 
#line 360
static constexpr _Elem __cdecl to_char_type(const int_type &
#line 361
_Meta) noexcept 
#line 362
{ 
#line 363
return _Meta; 
#line 364
} 
#line 366
static constexpr int_type __cdecl to_int_type(const _Elem &
#line 367
_Ch) noexcept 
#line 368
{ 
#line 369
return _Ch; 
#line 370
} 
#line 372
static constexpr bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 373
_Right) noexcept 
#line 374
{ 
#line 375
return _Left == _Right; 
#line 376
} 
#line 378
static constexpr int_type __cdecl not_eof(const int_type &
#line 379
_Meta) noexcept 
#line 380
{ 
#line 381
return (_Meta != (eof())) ? _Meta : (!(eof())); 
#line 382
} 
#line 384
static constexpr int_type __cdecl eof() noexcept 
#line 385
{ 
#line 386
return (wint_t)65535; 
#line 387
} 
#line 388
}; 
#line 393
template<> struct char_traits< unsigned short>  { 
#line 395
typedef unsigned short _Elem; 
#line 396
typedef _Elem char_type; 
#line 397
typedef wint_t int_type; 
#line 398
typedef streampos pos_type; 
#line 399
typedef streamoff off_type; 
#line 400
typedef _Mbstatet state_type; 
#line 402
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 403
_Count) 
#line 404
{ 
#line 405
return (_Count == (0)) ? 0 : ::wmemcmp((const __wchar_t *)_First1, (const __wchar_t *)_First2, _Count); 
#line 408
} 
#line 410
static size_t __cdecl length(const _Elem *_First) 
#line 411
{ 
#line 412
return ((*_First) == 0) ? 0 : ::wcslen((const __wchar_t *)_First); 
#line 414
} 
#line 416
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 417
_Count) 
#line 418
{ 
#line 419
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemcpy((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 
#line 422
} 
#line 424
static _Elem *__cdecl _Copy_s(_Elem *
#line 425
_First1, size_t _Size_in_words, const _Elem *
#line 426
_First2, size_t _Count) 
#line 427
{ 
#line 428
if ((0) < _Count) { 
#line 429
::wmemcpy_s((__wchar_t *)_First1, _Size_in_words, (const __wchar_t *)_First2, _Count); }  
#line 431 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
return _First1; 
#line 432
} 
#line 434
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 435
_Ch) 
#line 436
{ 
#line 437
return (_Count == (0)) ? (const _Elem *)0 : ((const _Elem *)::wmemchr((const __wchar_t *)_First, _Ch, _Count)); 
#line 440
} 
#line 442
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 443
_Count) 
#line 444
{ 
#line 445
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemmove((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 
#line 448
} 
#line 450
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem 
#line 451
_Ch) 
#line 452
{ 
#line 453
return (_Elem *)::wmemset((__wchar_t *)_First, _Ch, _Count); 
#line 454
} 
#line 456
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) noexcept 
#line 457
{ 
#line 458
_Left = _Right; 
#line 459
} 
#line 461
static constexpr bool __cdecl eq(const _Elem &_Left, const _Elem &
#line 462
_Right) noexcept 
#line 463
{ 
#line 464
return _Left == _Right; 
#line 465
} 
#line 467
static constexpr bool __cdecl lt(const _Elem &_Left, const _Elem &
#line 468
_Right) noexcept 
#line 469
{ 
#line 470
return _Left < _Right; 
#line 471
} 
#line 473
static constexpr _Elem __cdecl to_char_type(const int_type &_Meta) noexcept 
#line 475
{ 
#line 476
return _Meta; 
#line 477
} 
#line 479
static constexpr int_type __cdecl to_int_type(const _Elem &_Ch) noexcept 
#line 481
{ 
#line 482
return _Ch; 
#line 483
} 
#line 485
static constexpr bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 486
_Right) noexcept 
#line 487
{ 
#line 488
return _Left == _Right; 
#line 489
} 
#line 491
static constexpr int_type __cdecl not_eof(const int_type &_Meta) noexcept 
#line 493
{ 
#line 494
return (_Meta != (eof())) ? _Meta : (!(eof())); 
#line 495
} 
#line 497
static constexpr int_type __cdecl eof() noexcept 
#line 498
{ 
#line 499
return (wint_t)65535; 
#line 500
} 
#line 501
}; 
#line 505 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
template<> struct char_traits< char>  { 
#line 507
typedef char _Elem; 
#line 508
typedef _Elem char_type; 
#line 509
typedef int int_type; 
#line 510
typedef streampos pos_type; 
#line 511
typedef streamoff off_type; 
#line 512
typedef _Mbstatet state_type; 
#line 514
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 515
_Count) 
#line 516
{ 
#line 517
return (_Count == (0)) ? 0 : ::memcmp(_First1, _First2, _Count); 
#line 519
} 
#line 521
static size_t __cdecl length(const _Elem *_First) 
#line 522
{ 
#line 523
return ((*_First) == 0) ? 0 : ::strlen(_First); 
#line 525
} 
#line 527
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 528
_Count) 
#line 529
{ 
#line 530
return (_Count == (0)) ? _First1 : ((_Elem *)::memcpy(_First1, _First2, _Count)); 
#line 532
} 
#line 534
static _Elem *__cdecl _Copy_s(_Elem *
#line 535
_First1, size_t _Size_in_bytes, const _Elem *
#line 536
_First2, size_t _Count) 
#line 537
{ 
#line 538
if ((0) < _Count) { 
#line 539
::memcpy_s(_First1, _Size_in_bytes, _First2, _Count); }  
#line 540
return _First1; 
#line 541
} 
#line 543
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 544
_Ch) 
#line 545
{ 
#line 546
return (_Count == (0)) ? (const _Elem *)0 : ((const _Elem *)::memchr(_First, _Ch, _Count)); 
#line 548
} 
#line 550
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 551
_Count) 
#line 552
{ 
#line 553
return (_Count == (0)) ? _First1 : ((_Elem *)::memmove(_First1, _First2, _Count)); 
#line 555
} 
#line 557
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem 
#line 558
_Ch) 
#line 559
{ 
#line 560
return (_Elem *)::memset(_First, _Ch, _Count); 
#line 561
} 
#line 563
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) noexcept 
#line 564
{ 
#line 565
_Left = _Right; 
#line 566
} 
#line 568
static constexpr bool __cdecl eq(const _Elem &_Left, const _Elem &
#line 569
_Right) noexcept 
#line 570
{ 
#line 571
return _Left == _Right; 
#line 572
} 
#line 574
static constexpr bool __cdecl lt(const _Elem &_Left, const _Elem &
#line 575
_Right) noexcept 
#line 576
{ 
#line 577
return ((unsigned char)_Left) < ((unsigned char)_Right); 
#line 578
} 
#line 580
static constexpr _Elem __cdecl to_char_type(const int_type &
#line 581
_Meta) noexcept 
#line 582
{ 
#line 583
return (_Elem)_Meta; 
#line 584
} 
#line 586
static constexpr int_type __cdecl to_int_type(const _Elem &
#line 587
_Ch) noexcept 
#line 588
{ 
#line 589
return (unsigned char)_Ch; 
#line 590
} 
#line 592
static constexpr bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 593
_Right) noexcept 
#line 594
{ 
#line 595
return _Left == _Right; 
#line 596
} 
#line 598
static constexpr int_type __cdecl not_eof(const int_type &
#line 599
_Meta) noexcept 
#line 600
{ 
#line 601
return (_Meta != eof()) ? _Meta : (!(eof())); 
#line 602
} 
#line 604
static constexpr int_type __cdecl eof() noexcept 
#line 605
{ 
#line 606
return -1; 
#line 607
} 
#line 608
}; 
#line 611
template < class _Ty >
 class allocator;
#line 613
class ios_base; 
#line 614
template< class _Elem, class 
#line 615
_Traits = char_traits< _Elem> > class basic_ios; 
#line 617
template< class _Elem, class 
#line 618
_Traits = char_traits< _Elem> > class istreambuf_iterator; 
#line 620
template< class _Elem, class 
#line 621
_Traits = char_traits< _Elem> > class ostreambuf_iterator; 
#line 623
template< class _Elem, class 
#line 624
_Traits = char_traits< _Elem> > class basic_streambuf; 
#line 626
template< class _Elem, class 
#line 627
_Traits = char_traits< _Elem> > class basic_istream; 
#line 629
template< class _Elem, class 
#line 630
_Traits = char_traits< _Elem> > class basic_ostream; 
#line 632
template< class _Elem, class 
#line 633
_Traits = char_traits< _Elem> > class basic_iostream; 
#line 635
template< class _Elem, class 
#line 636
_Traits = char_traits< _Elem> , class 
#line 637
_Alloc = allocator< _Elem> > class basic_stringbuf; 
#line 639
template< class _Elem, class 
#line 640
_Traits = char_traits< _Elem> , class 
#line 641
_Alloc = allocator< _Elem> > class basic_istringstream; 
#line 643
template< class _Elem, class 
#line 644
_Traits = char_traits< _Elem> , class 
#line 645
_Alloc = allocator< _Elem> > class basic_ostringstream; 
#line 647
template< class _Elem, class 
#line 648
_Traits = char_traits< _Elem> , class 
#line 649
_Alloc = allocator< _Elem> > class basic_stringstream; 
#line 651
template< class _Elem, class 
#line 652
_Traits = char_traits< _Elem> > class basic_filebuf; 
#line 654
template< class _Elem, class 
#line 655
_Traits = char_traits< _Elem> > class basic_ifstream; 
#line 657
template< class _Elem, class 
#line 658
_Traits = char_traits< _Elem> > class basic_ofstream; 
#line 660
template< class _Elem, class 
#line 661
_Traits = char_traits< _Elem> > class basic_fstream; 
#line 665
template< class _Elem, class 
#line 666
_InIt> class num_get; 
#line 668
template< class _Elem, class 
#line 669
_OutIt> class num_put; 
#line 671
template< class _Elem> class collate; 
#line 676 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
typedef basic_ios< char, char_traits< char> >  ios; 
#line 677
typedef basic_streambuf< char, char_traits< char> >  streambuf; 
#line 678
typedef basic_istream< char, char_traits< char> >  istream; 
#line 679
typedef basic_ostream< char, char_traits< char> >  ostream; 
#line 680
typedef basic_iostream< char, char_traits< char> >  iostream; 
#line 682
typedef basic_stringbuf< char, char_traits< char> , allocator< char> >  stringbuf; 
#line 684
typedef basic_istringstream< char, char_traits< char> , allocator< char> >  istringstream; 
#line 686
typedef basic_ostringstream< char, char_traits< char> , allocator< char> >  ostringstream; 
#line 688
typedef basic_stringstream< char, char_traits< char> , allocator< char> >  stringstream; 
#line 689
typedef basic_filebuf< char, char_traits< char> >  filebuf; 
#line 690
typedef basic_ifstream< char, char_traits< char> >  ifstream; 
#line 691
typedef basic_ofstream< char, char_traits< char> >  ofstream; 
#line 692
typedef basic_fstream< char, char_traits< char> >  fstream; 
#line 695
typedef basic_ios< __wchar_t, char_traits< __wchar_t> >  wios; 
#line 697
typedef basic_streambuf< __wchar_t, char_traits< __wchar_t> >  wstreambuf; 
#line 698
typedef basic_istream< __wchar_t, char_traits< __wchar_t> >  wistream; 
#line 699
typedef basic_ostream< __wchar_t, char_traits< __wchar_t> >  wostream; 
#line 700
typedef basic_iostream< __wchar_t, char_traits< __wchar_t> >  wiostream; 
#line 702
typedef basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringbuf; 
#line 704
typedef basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wistringstream; 
#line 706
typedef basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wostringstream; 
#line 708
typedef basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringstream; 
#line 709
typedef basic_filebuf< __wchar_t, char_traits< __wchar_t> >  wfilebuf; 
#line 710
typedef basic_ifstream< __wchar_t, char_traits< __wchar_t> >  wifstream; 
#line 711
typedef basic_ofstream< __wchar_t, char_traits< __wchar_t> >  wofstream; 
#line 712
typedef basic_fstream< __wchar_t, char_traits< __wchar_t> >  wfstream; 
#line 738
typedef num_get< char, istreambuf_iterator< char, char_traits< char> > >  numget; 
#line 740
typedef num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumget; 
#line 742
typedef num_put< char, ostreambuf_iterator< char, char_traits< char> > >  numput; 
#line 744
typedef num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumput; 
#line 745
typedef collate< char>  ncollate; 
#line 746
typedef collate< __wchar_t>  wcollate; 
#line 748 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
}
#line 751
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
#pragma warning(push,3)
#line 15
#pragma warning(disable: 4180 4512)
#line 752 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\iosfwd"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
#pragma pack ( push, 8 )
#line 17
namespace std { 
#line 19
template < class _FwdIt1,
 class _FwdIt2 > inline
 void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right )
 {
 swap ( * _Left, * _Right );
 }
#line 27
template < class _Ty,
 size_t _Size,
 class > inline
 void swap ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] )
  noexcept ( _Is_nothrow_swappable < _Ty > :: value )
 {
 if ( & _Left != & _Right )
  {
  _Ty * _First1 = _Left;
  _Ty * _Last1 = _First1 + _Size;
  _Ty * _First2 = _Right;
  for (; _First1 != _Last1; ++ _First1, ++ _First2 )
   :: std :: iter_swap ( _First1, _First2 );
  }
 }
#line 43
template < class _Ty,
 class > inline
 void swap ( _Ty & _Left, _Ty & _Right )
  noexcept ( is_nothrow_move_constructible < _Ty > :: value && is_nothrow_move_assignable < _Ty > :: value )

 {
 _Ty _Tmp = :: std :: move ( _Left );
 _Left = :: std :: move ( _Right );
 _Right = :: std :: move ( _Tmp );
 }
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
template < class _Ty > inline
 void _Swap_adl ( _Ty & _Left, _Ty & _Right )
  noexcept ( _Is_nothrow_swappable < _Ty > :: value )
 {
 swap ( _Left, _Right );
 }
#line 63
struct piecewise_construct_t { 
#line 65
}; 
#line 67
constexpr piecewise_construct_t piecewise_construct{}; 
#line 70
template< class ...> class tuple; 
#line 73
template < class _Ty1,
 class _Ty2 >
 struct pair
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t < is_default_constructible < _Uty1 > :: value
      && is_default_constructible < _Uty2 > :: value > >
  constexpr pair ( )
  : first ( ), second ( )
  {
  }

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t < is_copy_constructible < _Uty1 > :: value
      && is_copy_constructible < _Uty2 > :: value >,
  enable_if_t < is_convertible < const _Uty1 &, _Uty1 > :: value
    && is_convertible < const _Uty2 &, _Uty2 > :: value, int > = 0 >
  constexpr pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : first ( _Val1 ), second ( _Val2 )
  {
  }

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  class = enable_if_t < is_copy_constructible < _Uty1 > :: value
      && is_copy_constructible < _Uty2 > :: value >,
  enable_if_t < ! is_convertible < const _Uty1 &, _Uty1 > :: value
    || ! is_convertible < const _Uty2 &, _Uty2 > :: value, int > = 0 >
  constexpr explicit pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : first ( _Val1 ), second ( _Val2 )
  {
  }

 pair ( const pair & ) = default;
 pair ( pair && ) = default;

 template < class _Other1,
  class _Other2,
  class = enable_if_t < is_constructible < _Ty1, const _Other1 & > :: value
      && is_constructible < _Ty2, const _Other2 & > :: value >,
  enable_if_t < is_convertible < const _Other1 &, _Ty1 > :: value
    && is_convertible < const _Other2 &, _Ty2 > :: value, int > = 0 >
  constexpr pair ( const pair < _Other1, _Other2 > & _Right )
  : first ( _Right . first ), second ( _Right . second )
  {
  }

 template < class _Other1,
  class _Other2,
  class = enable_if_t < is_constructible < _Ty1, const _Other1 & > :: value
      && is_constructible < _Ty2, const _Other2 & > :: value >,
  enable_if_t < ! is_convertible < const _Other1 &, _Ty1 > :: value
    || ! is_convertible < const _Other2 &, _Ty2 > :: value, int > = 0 >
  constexpr explicit pair ( const pair < _Other1, _Other2 > & _Right )
  : first ( _Right . first ), second ( _Right . second )
  {
  }

 template < class _Other1,
  class _Other2 >
  _Myt & operator = ( const pair < _Other1, _Other2 > & _Right )
  {
  first = _Right . first;
  second = _Right . second;
  return ( * this );
  }

 template < class _Tuple1,
  class _Tuple2,
  size_t ... _Indexes1,
  size_t ... _Indexes2 > inline
  pair ( _Tuple1 & _Val1,
   _Tuple2 & _Val2,
   integer_sequence < size_t, _Indexes1 ... >,
   integer_sequence < size_t, _Indexes2 ... > );

 template < class ... _Types1,
  class ... _Types2 > inline
  pair ( piecewise_construct_t,
   tuple < _Types1 ... > _Val1,
   tuple < _Types2 ... > _Val2 );

 template < class _Other1,
  class _Other2,
  class = enable_if_t < is_constructible < _Ty1, _Other1 > :: value
      && is_constructible < _Ty2, _Other2 > :: value >,
  enable_if_t < is_convertible < _Other1, _Ty1 > :: value
    && is_convertible < _Other2, _Ty2 > :: value, int > = 0 >
  constexpr pair ( _Other1 && _Val1, _Other2 && _Val2 )
   noexcept ( ( is_nothrow_constructible < _Ty1, _Other1 > :: value && is_nothrow_constructible < _Ty2, _Other2 > :: value ) )

  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
    second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 template < class _Other1,
  class _Other2,
  class = enable_if_t < is_constructible < _Ty1, _Other1 > :: value
      && is_constructible < _Ty2, _Other2 > :: value >,
  enable_if_t < ! is_convertible < _Other1, _Ty1 > :: value
    || ! is_convertible < _Other2, _Ty2 > :: value, int > = 0 >
  constexpr explicit pair ( _Other1 && _Val1, _Other2 && _Val2 )
   noexcept ( ( is_nothrow_constructible < _Ty1, _Other1 > :: value && is_nothrow_constructible < _Ty2, _Other2 > :: value ) )

  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
    second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 template < class _Other1,
  class _Other2,
  class = enable_if_t < is_constructible < _Ty1, _Other1 > :: value
      && is_constructible < _Ty2, _Other2 > :: value >,
  enable_if_t < is_convertible < _Other1, _Ty1 > :: value
    && is_convertible < _Other2, _Ty2 > :: value, int > = 0 >
  constexpr pair ( pair < _Other1, _Other2 > && _Right )
   noexcept ( ( is_nothrow_constructible < _Ty1, _Other1 > :: value && is_nothrow_constructible < _Ty2, _Other2 > :: value ) )

  : first ( :: std :: forward < _Other1 > ( _Right . first ) ),
   second ( :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

 template < class _Other1,
  class _Other2,
  class = enable_if_t < is_constructible < _Ty1, _Other1 > :: value
      && is_constructible < _Ty2, _Other2 > :: value >,
  enable_if_t < ! is_convertible < _Other1, _Ty1 > :: value
    || ! is_convertible < _Other2, _Ty2 > :: value, int > = 0 >
  constexpr explicit pair ( pair < _Other1, _Other2 > && _Right )
   noexcept ( ( is_nothrow_constructible < _Ty1, _Other1 > :: value && is_nothrow_constructible < _Ty2, _Other2 > :: value ) )

  : first ( :: std :: forward < _Other1 > ( _Right . first ) ),
   second ( :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

 template < class _Other1,
  class _Other2 >
  _Myt & operator = ( pair < _Other1, _Other2 > && _Right )
  {
  first = :: std :: forward < _Other1 > ( _Right . first );
  second = :: std :: forward < _Other2 > ( _Right . second );
  return ( * this );
  }

 _Myt & operator = ( _Myt && _Right )
  noexcept ( ( is_nothrow_move_assignable < _Ty1 > :: value && is_nothrow_move_assignable < _Ty2 > :: value ) )

  {
  first = :: std :: forward < _Ty1 > ( _Right . first );
  second = :: std :: forward < _Ty2 > ( _Right . second );
  return ( * this );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  first = _Right . first;
  second = _Right . second;
  return ( * this );
  }

 _Ty1 first;
 _Ty2 second;

 void swap ( _Myt & _Right )
  noexcept ( _Is_nothrow_swappable < _Ty1 > :: value && _Is_nothrow_swappable < _Ty2 > :: value )

  {
  if ( this != & _Right )
   {
   _Swap_adl ( first, _Right . first );
   _Swap_adl ( second, _Right . second );
   }
  }
 };
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
template < class _Ty1,
 class _Ty2,
 class = enable_if_t < _Is_swappable < _Ty1 > :: value && _Is_swappable < _Ty2 > :: value > > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right )
  noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 268
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool operator == ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first == _Right . first && _Left . second == _Right . second );
 }
#line 276
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool operator != ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 284
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool operator < ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first < _Right . first ||
  ( ! ( _Right . first < _Left . first ) && _Left . second < _Right . second ) );
 }
#line 293
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool operator > ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 301
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool operator <= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 309
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool operator >= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 319
template < class _Ty1,
 class _Ty2 > inline
 constexpr pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ),
  :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }
#line 332
namespace rel_ops { 
#line 334
template < class _Ty > inline
 bool operator != ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 340
template < class _Ty > inline
 bool operator > ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left );
 }
#line 346
template < class _Ty > inline
 bool operator <= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 352
template < class _Ty > inline
 bool operator >= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 357
}
#line 358
}
#line 360
namespace std { 
#line 361
template< class _Ty, size_t 
#line 362
_Size> class array; 
#line 366
template< class _Tuple> struct tuple_size; 
#line 369
template< class _Ty, size_t 
#line 370
_Size> 
#line 371
struct tuple_size< array< _Ty, _Size> >  : public integral_constant< unsigned __int64, _Size>  { 
#line 374
}; 
#line 376
template< class _Ty1, class 
#line 377
_Ty2> 
#line 378
struct tuple_size< pair< _Ty1, _Ty2> >  : public integral_constant< unsigned __int64, 2Ui64>  { 
#line 381
}; 
#line 383
template< class ..._Types> 
#line 384
struct tuple_size< tuple< _Types...> >  : public integral_constant< unsigned __int64, sizeof...(_Types)>  { 
#line 387
}; 
#line 390
template< class _Tuple> 
#line 391
struct tuple_size< const _Tuple>  : public tuple_size< _Tuple>  { 
#line 394
}; 
#line 396
template< class _Tuple> 
#line 397
struct tuple_size< volatile _Tuple>  : public tuple_size< _Tuple>  { 
#line 400
}; 
#line 402
template< class _Tuple> 
#line 403
struct tuple_size< const volatile _Tuple>  : public tuple_size< _Tuple>  { 
#line 406
}; 
#line 409
template< class _Ty> constexpr size_t 
#line 410
tuple_size_v = (tuple_size< _Ty> ::value); 
#line 414 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
template< size_t _Index, class 
#line 415
_Tuple> struct tuple_element; 
#line 418
template< size_t _Idx, class 
#line 419
_Ty, size_t 
#line 420
_Size> 
#line 421
struct tuple_element< _Idx, array< _Ty, _Size> >  { 
#line 423
static_assert((_Idx < _Size), "array index out of bounds");
#line 425
typedef _Ty type; 
#line 426
}; 
#line 428
template< class _Ty1, class 
#line 429
_Ty2> 
#line 430
struct tuple_element< 0, pair< _Ty1, _Ty2> >  { 
#line 432
typedef _Ty1 type; 
#line 433
}; 
#line 435
template< class _Ty1, class 
#line 436
_Ty2> 
#line 437
struct tuple_element< 1, pair< _Ty1, _Ty2> >  { 
#line 439
typedef _Ty2 type; 
#line 440
}; 
#line 442
template< size_t _Index> 
#line 443
struct tuple_element< _Index, tuple< > >  { 
#line 445
static_assert((_Always_false< integral_constant< unsigned __int64, _Index> > ::value), "tuple index out of bounds");
#line 447
}; 
#line 449
template< class _This, class ...
#line 450
_Rest> 
#line 451
struct tuple_element< 0, tuple< _This, _Rest...> >  { 
#line 453
typedef _This type; 
#line 454
typedef tuple< _This, _Rest...>  _Ttype; 
#line 455
}; 
#line 457
template< size_t _Index, class 
#line 458
_This, class ...
#line 459
_Rest> 
#line 460
struct tuple_element< _Index, tuple< _This, _Rest...> >  : public tuple_element< _Index - (1), tuple< _Rest...> >  { 
#line 463
}; 
#line 466
template< size_t _Index, class 
#line 467
_Tuple> 
#line 468
struct tuple_element< _Index, const _Tuple>  : public tuple_element< _Index, _Tuple>  { 
#line 471
typedef ::std::tuple_element< _Index, _Tuple>  _Mybase; 
#line 472
typedef typename add_const< typename ::std::tuple_element< _Index, _Tuple> ::type> ::type type; 
#line 473
}; 
#line 475
template< size_t _Index, class 
#line 476
_Tuple> 
#line 477
struct tuple_element< _Index, volatile _Tuple>  : public tuple_element< _Index, _Tuple>  { 
#line 480
typedef ::std::tuple_element< _Index, _Tuple>  _Mybase; 
#line 481
typedef typename add_volatile< typename ::std::tuple_element< _Index, _Tuple> ::type> ::type type; 
#line 482
}; 
#line 484
template< size_t _Index, class 
#line 485
_Tuple> 
#line 486
struct tuple_element< _Index, const volatile _Tuple>  : public tuple_element< _Index, _Tuple>  { 
#line 489
typedef ::std::tuple_element< _Index, _Tuple>  _Mybase; 
#line 490
typedef typename add_cv< typename ::std::tuple_element< _Index, _Tuple> ::type> ::type type; 
#line 491
}; 
#line 493
template< size_t _Index, class 
#line 494
_Tuple> using tuple_element_t = typename tuple_element< _Index, _Tuple> ::type; 
#line 498
template < class _Ret,
 class _Pair > inline
 constexpr _Ret _Pair_get ( _Pair & _Pr,
  integral_constant < size_t, 0 > ) noexcept
 {
 return ( _Pr . first );
 }
#line 506
template < class _Ret,
 class _Pair > inline
 constexpr _Ret _Pair_get ( _Pair & _Pr,
  integral_constant < size_t, 1 > ) noexcept
 {
 return ( _Pr . second );
 }
#line 514
template < size_t _Idx,
 class _Ty1,
 class _Ty2 > inline
 constexpr typename tuple_element < _Idx, pair < _Ty1, _Ty2 > > :: type &
  get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 typedef typename tuple_element < _Idx, pair < _Ty1, _Ty2 > > :: type & _Rtype;
 return ( _Pair_get < _Rtype > ( _Pr, integral_constant < size_t, _Idx > ( ) ) );
 }
#line 524
template < class _Ty1,
 class _Ty2 > inline
 constexpr _Ty1 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( _Pr ) );
 }
#line 531
template < class _Ty2,
 class _Ty1 > inline
 constexpr _Ty2 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( _Pr ) );
 }
#line 538
template < size_t _Idx,
 class _Ty1,
 class _Ty2 > inline
 constexpr const typename tuple_element < _Idx, pair < _Ty1, _Ty2 > > :: type &
  get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 typedef const typename tuple_element < _Idx, pair < _Ty1, _Ty2 > > :: type &
  _Ctype;
 return ( _Pair_get < _Ctype > ( _Pr, integral_constant < size_t, _Idx > ( ) ) );
 }
#line 549
template < class _Ty1,
 class _Ty2 > inline
 constexpr const _Ty1 & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( _Pr ) );
 }
#line 556
template < class _Ty2,
 class _Ty1 > inline
 constexpr const _Ty2 & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( _Pr ) );
 }
#line 563
template < size_t _Idx,
 class _Ty1,
 class _Ty2 > inline
 constexpr typename tuple_element < _Idx, pair < _Ty1, _Ty2 > > :: type &&
  get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 typedef typename tuple_element < _Idx, pair < _Ty1, _Ty2 > > :: type && _RRtype;
 return ( :: std :: forward < _RRtype > ( :: std :: get < _Idx > ( _Pr ) ) );
 }
#line 573
template < class _Ty1,
 class _Ty2 > inline
 constexpr _Ty1 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( :: std :: move ( _Pr ) ) );
 }
#line 580
template < class _Ty2,
 class _Ty1 > inline
 constexpr _Ty2 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( :: std :: move ( _Pr ) ) );
 }
#line 588
template < class _Ty,
 class _Other = _Ty > inline
 _Ty exchange ( _Ty & _Val, _Other && _New_val )
 {
 _Ty _Old_val = :: std :: move ( _Val );
 _Val = :: std :: forward < _Other > ( _New_val );
 return ( _Old_val );
 }
#line 598
template < class _Ty > inline
 constexpr add_const_t < _Ty > & as_const ( _Ty & _Val ) noexcept
 {
 return ( _Val );
 }
#line 604
template < class _Ty >
 void as_const ( const _Ty && ) = delete;
#line 606
}
#line 609
namespace std { 
#line 610
namespace tr1 { 
#line 611
using std::get;
#line 612
using std::tuple_element;
#line 613
using std::tuple_size;
#line 614
}
#line 615
}
#line 619 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
#pragma warning(push,3)
#line 620 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\utility"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 25
typedef const __wchar_t *_Dbfile_t; 
#line 26
typedef unsigned _Dbline_t; 
#line 28
__declspec(dllimport) void __cdecl _Debug_message(const __wchar_t *, const __wchar_t *, unsigned); 
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
struct _Container_proxy; 
#line 37
struct _Container_base12; 
#line 38
struct _Iterator_base12; 
#line 40
struct _Container_base0 { 
#line 42
void _Orphan_all() 
#line 43
{ 
#line 44
} 
#line 46
void _Swap_all(_Container_base0 &) 
#line 47
{ 
#line 48
} 
#line 49
}; 
#line 51
struct _Iterator_base0 { 
#line 53
void _Adopt(const void *) 
#line 54
{ 
#line 55
} 
#line 57
const _Container_base0 *_Getcont() const 
#line 58
{ 
#line 59
return 0; 
#line 60
} 
#line 61
}; 
#line 64
struct _Container_proxy { 
#line 66
_Container_proxy() : _Mycont((0)), _Myfirstiter((0)) 
#line 68
{ 
#line 69
} 
#line 71
const _Container_base12 *_Mycont; 
#line 72
_Iterator_base12 *_Myfirstiter; 
#line 73
}; 
#line 75
struct _Container_base12 { 
#line 78
_Container_base12() : _Myproxy((0)) 
#line 80
{ 
#line 81
} 
#line 83
_Container_base12(const _Container_base12 &) : _Myproxy((0)) 
#line 85
{ 
#line 86
} 
#line 88
_Container_base12 &operator=(const _Container_base12 &) 
#line 89
{ 
#line 90
return *this; 
#line 91
} 
#line 93
~_Container_base12() noexcept 
#line 94
{ 
#line 95
this->_Orphan_all(); 
#line 96
} 
#line 98
_Iterator_base12 **_Getpfirst() const 
#line 99
{ 
#line 100
return ((_Myproxy) == (0)) ? 0 : (&((_Myproxy)->_Myfirstiter)); 
#line 101
} 
#line 103
inline void _Orphan_all(); 
#line 104
inline void _Swap_all(_Container_base12 &); 
#line 106
_Container_proxy *_Myproxy; 
#line 107
}; 
#line 109
struct _Iterator_base12 { 
#line 112
_Iterator_base12() : _Myproxy((0)), _Mynextiter((0)) 
#line 114
{ 
#line 115
} 
#line 117
_Iterator_base12(const _Iterator_base12 &_Right) : _Myproxy((0)), _Mynextiter((0)) 
#line 119
{ 
#line 120
((*this) = _Right); 
#line 121
} 
#line 123
_Iterator_base12 &operator=(const _Iterator_base12 &_Right) 
#line 124
{ 
#line 125
if ((_Myproxy) == (_Right._Myproxy)) { 
#line 126
; } else { 
#line 127
if ((_Right._Myproxy) != (0)) { 
#line 128
this->_Adopt((_Right._Myproxy)->_Mycont); } else 
#line 130
{ 
#line 132
_Lockit _Lock(3); 
#line 133
this->_Orphan_me(); 
#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
}  }  
#line 137
return *this; 
#line 138
} 
#line 140
~_Iterator_base12() noexcept 
#line 141
{ 
#line 143
_Lockit _Lock(3); 
#line 144
this->_Orphan_me(); 
#line 146 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
} 
#line 148
void _Adopt(const _Container_base12 *_Parent) 
#line 149
{ 
#line 150
if (_Parent == (0)) 
#line 151
{ 
#line 153
_Lockit _Lock(3); 
#line 154
this->_Orphan_me(); 
#line 156 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
} else 
#line 158
{ 
#line 159
_Container_proxy *_Parent_proxy = _Parent->_Myproxy; 
#line 162
if ((_Myproxy) != _Parent_proxy) 
#line 163
{ 
#line 164
_Lockit _Lock(3); 
#line 165
this->_Orphan_me(); 
#line 166
(_Mynextiter) = (_Parent_proxy->_Myfirstiter); 
#line 167
(_Parent_proxy->_Myfirstiter) = this; 
#line 168
(_Myproxy) = _Parent_proxy; 
#line 169
}  
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
}  
#line 175
} 
#line 177
void _Clrcont() 
#line 178
{ 
#line 179
(_Myproxy) = (0); 
#line 180
} 
#line 182
const _Container_base12 *_Getcont() const 
#line 183
{ 
#line 184
return ((_Myproxy) == (0)) ? 0 : ((_Myproxy)->_Mycont); 
#line 185
} 
#line 187
_Iterator_base12 **_Getpnext() 
#line 188
{ 
#line 189
return &(_Mynextiter); 
#line 190
} 
#line 192
void _Orphan_me() 
#line 193
{ 
#line 195
if ((_Myproxy) != (0)) 
#line 196
{ 
#line 197
_Iterator_base12 **_Pnext = &((_Myproxy)->_Myfirstiter); 
#line 198
while (((*_Pnext) != (0)) && ((*_Pnext) != this)) { 
#line 199
_Pnext = (&((*_Pnext)->_Mynextiter)); }  
#line 201
if ((*_Pnext) == (0)) { 
#line 202
_Debug_message(L"\x49\x54\x45\x52\x41\x54\x4f\x52\x20\x4c\x49\x53\x54\x20\x43\x4f\x52\x52\x55\x50\x54\x45\x44\x21", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 202); }  
#line 203
(*_Pnext) = (_Mynextiter); 
#line 204
(_Myproxy) = (0); 
#line 205
}  
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
} 
#line 209
_Container_proxy *_Myproxy; 
#line 210
_Iterator_base12 *_Mynextiter; 
#line 211
}; 
#line 214
inline void _Container_base12::_Orphan_all() 
#line 215
{ 
#line 217
if ((_Myproxy) != (0)) 
#line 218
{ 
#line 219
_Lockit _Lock(3); 
#line 221
for (_Iterator_base12 **_Pnext = &((_Myproxy)->_Myfirstiter); (*_Pnext) != (0); (*_Pnext) = ((*_Pnext)->_Mynextiter)) { 
#line 223
((*_Pnext)->_Myproxy) = (0); }  
#line 224
((_Myproxy)->_Myfirstiter) = (0); 
#line 225
}  
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
} 
#line 229
inline void _Container_base12::_Swap_all(_Container_base12 &_Right) 
#line 230
{ 
#line 232
_Lockit _Lock(3); 
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
_Container_proxy *_Temp = _Myproxy; 
#line 236
(_Myproxy) = (_Right._Myproxy); 
#line 237
(_Right._Myproxy) = _Temp; 
#line 239
if ((_Myproxy) != (0)) { 
#line 240
((_Myproxy)->_Mycont) = ((_Container_base12 *)this); }  
#line 241
if ((_Right._Myproxy) != (0)) { 
#line 242
((_Right._Myproxy)->_Mycont) = ((_Container_base12 *)(&_Right)); }  
#line 243
} 
#line 250 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
typedef _Container_base12 _Container_base; 
#line 251
typedef _Iterator_base12 _Iterator_base; 
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
struct _Zero_then_variadic_args_t { 
#line 257
}; 
#line 259
struct _One_then_variadic_args_t { 
#line 261
}; 
#line 263
template < class _Ty1,
 class _Ty2,
 bool = is_empty < _Ty1 > :: value && ! is_final < _Ty1 > :: value >
 class _Compressed_pair final
  : private _Ty1

 {
private :
 _Ty2 _Myval2;

 typedef _Ty1 _Mybase;

public :
 template < class ... _Other2 >
  constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t,
   _Other2 && ... _Val2 )
  : _Ty1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }

 template < class _Other1,
  class ... _Other2 >
  _Compressed_pair ( _One_then_variadic_args_t,
   _Other1 && _Val1, _Other2 && ... _Val2 )
  : _Ty1 ( :: std :: forward < _Other1 > ( _Val1 ) ),
   _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }


 _Ty1 & _Get_first ( ) noexcept
  {
  return ( * this );
  }

 const _Ty1 & _Get_first ( ) const noexcept
  {
  return ( * this );
  }

 volatile _Ty1 & _Get_first ( ) volatile noexcept
  {
  return ( * this );
  }

 const volatile _Ty1 & _Get_first ( ) const volatile noexcept
  {
  return ( * this );
  }

 _Ty2 & _Get_second ( ) noexcept
  {
  return ( _Myval2 );
  }

 const _Ty2 & _Get_second ( ) const noexcept
  {
  return ( _Myval2 );
  }

 volatile _Ty2 & _Get_second ( ) volatile noexcept
  {
  return ( _Myval2 );
  }

 const volatile _Ty2 & _Get_second ( ) const volatile noexcept
  {
  return ( _Myval2 );
  }
 };
#line 334
template < class _Ty1,
 class _Ty2 >
 class _Compressed_pair < _Ty1, _Ty2, false > final

 {
private :
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public :
 template < class ... _Other2 >
  constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t,
   _Other2 && ... _Val2 )
  : _Myval1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }

 template < class _Other1,
  class ... _Other2 >
  _Compressed_pair ( _One_then_variadic_args_t,
   _Other1 && _Val1, _Other2 && ... _Val2 )
  : _Myval1 ( :: std :: forward < _Other1 > ( _Val1 ) ),
   _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }


 _Ty1 & _Get_first ( ) noexcept
  {
  return ( _Myval1 );
  }

 const _Ty1 & _Get_first ( ) const noexcept
  {
  return ( _Myval1 );
  }

 volatile _Ty1 & _Get_first ( ) volatile noexcept
  {
  return ( _Myval1 );
  }

 const volatile _Ty1 & _Get_first ( ) const volatile noexcept
  {
  return ( _Myval1 );
  }

 _Ty2 & _Get_second ( ) noexcept
  {
  return ( _Myval2 );
  }

 const _Ty2 & _Get_second ( ) const noexcept
  {
  return ( _Myval2 );
  }

 volatile _Ty2 & _Get_second ( ) volatile noexcept
  {
  return ( _Myval2 );
  }

 const volatile _Ty2 & _Get_second ( ) const volatile noexcept
  {
  return ( _Myval2 );
  }
 };
#line 403
template< class _Ty, class 
#line 404
 = void> 
#line 405
struct _Is_checked_helper : public false_type { 
#line 408
}; 
#line 410
template< class _Ty> 
#line 411
struct _Is_checked_helper< _Ty, void_t< typename _Ty::_Unchecked_type> >  : public true_type { 
#line 415
}; 
#line 418
template < class _Iter > inline
 typename _Is_checked_helper < _Iter > :: type _Is_checked ( _Iter )
 {
 return { };
 }
#line 425
template < class _Iter > inline
 _Iter _Unchecked ( _Iter _Src )
 {
 return ( _Src );
 }
#line 445 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Iter > inline
 _Iter _Unchecked_idl0 ( _Iter _Src )
 {
 return ( _Src );
 }
#line 454 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Iter,
 class _UIter > inline
 _Iter & _Rechecked ( _Iter & _Dest, _UIter _Src )
 {
 _Dest = _Src;
 return ( _Dest );
 }
#line 506 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
struct input_iterator_tag { 
#line 508
}; 
#line 510
struct _Mutable_iterator_tag { 
#line 512
}; 
#line 514
struct output_iterator_tag : public _Mutable_iterator_tag { 
#line 517
}; 
#line 519
struct forward_iterator_tag : public input_iterator_tag, public _Mutable_iterator_tag { 
#line 522
}; 
#line 524
struct bidirectional_iterator_tag : public forward_iterator_tag { 
#line 527
}; 
#line 529
struct random_access_iterator_tag : public bidirectional_iterator_tag { 
#line 532
}; 
#line 535
struct _General_ptr_iterator_tag { 
#line 537
}; 
#line 539
struct _Trivially_copyable_ptr_iterator_tag : public _General_ptr_iterator_tag { 
#line 542
}; 
#line 544
struct _Really_trivial_ptr_iterator_tag : public _Trivially_copyable_ptr_iterator_tag { 
#line 547
}; 
#line 550
struct _Any_tag { 
#line 552
constexpr _Any_tag() noexcept = default;
#line 553
template < class _Ty >
  constexpr _Any_tag ( _Ty && ) noexcept { }
#line 555
}; 
#line 558
template< class _Category, class 
#line 559
_Ty, class 
#line 560
_Diff = ptrdiff_t, class 
#line 561
_Pointer = _Ty *, class 
#line 562
_Reference = _Ty &> 
#line 563
struct iterator { 
#line 565
typedef _Category iterator_category; 
#line 566
typedef _Ty value_type; 
#line 567
typedef _Diff difference_type; 
#line 569
typedef _Pointer pointer; 
#line 570
typedef _Reference reference; 
#line 571
}; 
#line 573
template< class _Category, class 
#line 574
_Ty, class 
#line 575
_Diff, class 
#line 576
_Pointer, class 
#line 577
_Reference, class 
#line 578
_Base> 
#line 579
struct _Iterator012 : public _Base { 
#line 582
typedef _Category iterator_category; 
#line 583
typedef _Ty value_type; 
#line 584
typedef _Diff difference_type; 
#line 586
typedef _Pointer pointer; 
#line 587
typedef _Reference reference; 
#line 588
}; 
#line 591
typedef iterator< output_iterator_tag, void, void, void, void>  _Outit; 
#line 594
template< class , class 
#line 595
 = void> 
#line 596
struct _Iterator_traits_base { 
#line 598
}; 
#line 600
template< class _Iter> 
#line 601
struct _Iterator_traits_base< _Iter, void_t< typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type, typename _Iter::pointer, typename _Iter::reference> >  { 
#line 609
typedef typename _Iter::iterator_category iterator_category; 
#line 610
typedef typename _Iter::value_type value_type; 
#line 611
typedef typename _Iter::difference_type difference_type; 
#line 613
typedef typename _Iter::pointer pointer; 
#line 614
typedef typename _Iter::reference reference; 
#line 615
}; 
#line 617
template< class _Iter> 
#line 618
struct iterator_traits : public _Iterator_traits_base< _Iter>  { 
#line 621
}; 
#line 623
template< class _Ty> 
#line 624
struct iterator_traits< _Ty *>  { 
#line 626
typedef random_access_iterator_tag iterator_category; 
#line 627
typedef _Ty value_type; 
#line 628
typedef ptrdiff_t difference_type; 
#line 630
typedef _Ty *pointer; 
#line 631
typedef _Ty &reference; 
#line 632
}; 
#line 634
template< class _Ty> 
#line 635
struct iterator_traits< const _Ty *>  { 
#line 637
typedef random_access_iterator_tag iterator_category; 
#line 638
typedef _Ty value_type; 
#line 639
typedef ptrdiff_t difference_type; 
#line 641
typedef const _Ty *pointer; 
#line 642
typedef const _Ty &reference; 
#line 643
}; 
#line 646
template< class _Iter> using _Iter_value_t = typename iterator_traits< _Iter> ::value_type; 
#line 650
template< class _Iter> using _Iter_diff_t = typename iterator_traits< _Iter> ::difference_type; 
#line 654
template< class _Iter> using _Iter_cat_t = typename iterator_traits< _Iter> ::iterator_category; 
#line 658
template< class _Ty, class 
#line 659
 = void> 
#line 660
struct _Is_iterator : public false_type { 
#line 663
}; 
#line 665
template< class _Ty> 
#line 666
struct _Is_iterator< _Ty, void_t< typename iterator_traits< _Ty> ::iterator_category> >  : public true_type { 
#line 671
}; 
#line 683 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Iter,
 class _Diff > inline
 auto _Unchecked_n1 ( _Iter _Src, _Diff, false_type )
 {
 return ( _Src );
 }
#line 690
template < class _Iter,
 class _Diff > inline
 auto _Unchecked_n1 ( _Iter _Src, _Diff _Count, true_type )
 {
 if ( 0 < _Count )
  {
  static_cast < void > ( ( _Src ) + ( _Count ) );
  }

 return ( _Unchecked ( _Src ) );
 }
#line 702
template < class _Iter,
 class _Diff > inline
 auto _Unchecked_n ( _Iter _Src, _Diff _Count )
 {
 return ( _Unchecked_n1 ( _Src, _Count, is_base_of < random_access_iterator_tag, _Iter_cat_t < _Iter >> ( ) ) );
 }
#line 712 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template< class _Ty1, class 
#line 713
_Ty2> 
#line 714
struct _Is_same_size : public bool_constant< sizeof(_Ty1) == sizeof(_Ty2)>  { 
#line 717
}; 
#line 720
template< class _Elem, bool 
#line 721
_Is_enum = is_enum< _Elem> ::value> 
#line 722
struct _Unwrap_enum { 
#line 724
typedef underlying_type_t< _Elem>  type; 
#line 725
}; 
#line 727
template< class _Elem> 
#line 728
struct _Unwrap_enum< _Elem, false>  { 
#line 730
typedef _Elem type; 
#line 731
}; 
#line 734
template< class _Ty1, class 
#line 735
_Ty2> 
#line 736
struct _Both_or_neither_bool : public bool_constant< is_same< bool, _Ty1> ::value == is_same< bool, _Ty2> ::value>  { 
#line 739
}; 
#line 742
template< class _Source, class 
#line 743
_Dest> 
#line 744
struct _Ptr_cat_helper { 
#line 746
typedef typename _Unwrap_enum< _Source> ::type _USource; 
#line 747
typedef typename _Unwrap_enum< _Dest> ::type _UDest; 
#line 759
typedef conditional_t< conjunction< _Is_same_size< typename _Unwrap_enum< _Source> ::type, typename _Unwrap_enum< _Dest> ::type> , is_integral< typename _Unwrap_enum< _Source> ::type> , is_integral< typename _Unwrap_enum< _Dest> ::type> , _Both_or_neither_bool< typename _Unwrap_enum< _Source> ::type, typename _Unwrap_enum< _Dest> ::type> , negation< is_volatile< _Source> > , negation< is_volatile< _Dest> > > ::value, _Really_trivial_ptr_iterator_tag, _General_ptr_iterator_tag>  type; 
#line 760
}; 
#line 762
template< class _Elem> 
#line 763
struct _Ptr_cat_helper< _Elem, _Elem>  { 
#line 770
typedef conditional_t< is_trivially_copyable< _Elem> ::value, conditional_t< is_trivial< _Elem> ::value, _Really_trivial_ptr_iterator_tag, _Trivially_copyable_ptr_iterator_tag> , _General_ptr_iterator_tag>  type; 
#line 771
}; 
#line 773
template< class _Anything> 
#line 774
struct _Ptr_cat_helper< _Anything *, const _Anything *>  { 
#line 776
typedef _Really_trivial_ptr_iterator_tag type; 
#line 777
}; 
#line 779
template < class _Source,
 class _Dest > inline
 _General_ptr_iterator_tag _Ptr_copy_cat ( const _Source &, const _Dest & )
 {
 return { };
 }
#line 786
template < class _Source,
 class _Dest > inline
 conditional_t < is_trivially_assignable < _Dest &, _Source & > :: value,
  typename _Ptr_cat_helper < remove_const_t < _Source >, _Dest > :: type,
  _General_ptr_iterator_tag >
  _Ptr_copy_cat ( _Source * const &, _Dest * const & )
 {
 return { };
 }
#line 796
template < class _Source,
 class _Dest > inline
 _General_ptr_iterator_tag _Ptr_move_cat ( const _Source &, const _Dest & )
 {
 return { };
 }
#line 803
template < class _Source,
 class _Dest > inline
 conditional_t < is_trivially_assignable < _Dest &, _Source > :: value,
  typename _Ptr_cat_helper < remove_const_t < _Source >, _Dest > :: type,
  _General_ptr_iterator_tag >
  _Ptr_move_cat ( _Source * const &, _Dest * const & )
 {
 return { };
 }
#line 887 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Pr,
 class _Ty1,
 class _Ty2 > inline
 constexpr bool _Debug_lt_pred ( _Pr && _Pred,
  _Ty1 && _Left, _Ty2 && _Right,
  _Dbfile_t _File, _Dbline_t _Line )
  noexcept ( noexcept ( ! _Pred ( _Left, _Right ) ) && noexcept ( _Pred ( _Right, _Left ) ) )

 {
 return ( ! _Pred ( _Left, _Right )
  ? false
  : _Pred ( _Right, _Left )
   ? ( _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x63\x6f\x6d\x70\x61\x72\x61\x74\x6f\x72", _File, _Line ), true )
   : true );
 }
#line 904 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Ty1,
 class _Ty2 > inline
 constexpr bool _Debug_lt ( _Ty1 && _Left, _Ty2 && _Right,
  _Dbfile_t _File, _Dbline_t _Line )
  noexcept ( noexcept ( ! ( _Left < _Right ) ) && noexcept ( _Right < _Left ) )

 {
 return ( _Debug_lt_pred ( less < > ( ),
  :: std :: forward < _Ty1 > ( _Left ), :: std :: forward < _Ty2 > ( _Right ), _File, _Line ) );
 }
#line 916 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _InIt > inline
 void _Debug_pointer ( _InIt &, _Dbfile_t, _Dbline_t )
 {
 }
#line 921
template < class _Ty > inline
 void _Debug_pointer ( _Ty * _Ptr, _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( _Ptr == 0 )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6e\x75\x6c\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72", _File, _Line );
 }
#line 929
template < class _InIt > inline
 void _Debug_pointer_if ( bool, _InIt &, _Dbfile_t, _Dbline_t )
 {
 }
#line 934
template < class _Ty > inline
 void _Debug_pointer_if ( bool _Test, _Ty * _Ptr,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( _Test && _Ptr == 0 )
  _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x6e\x75\x6c\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72", _File, _Line );
 }
#line 943
template < class _InIt > inline
 void _Debug_range2 ( _InIt _First, _InIt _Last,
  _Dbfile_t, _Dbline_t, input_iterator_tag )
 {
 static_cast < void > ( _First == _Last );
 }
#line 950
template < class _RanIt > inline
 void _Debug_range2 ( _RanIt _First, _RanIt _Last,
  _Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag )
 {
 if ( _First != _Last )
  {
  _Debug_pointer ( _First, _File, _Line );
  _Debug_pointer ( _Last, _File, _Line );
  if ( _Last < _First )
   _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x72\x61\x6e\x67\x65", _File, _Line );
  }
 }
#line 963
template < class _InIt > inline
 void _Debug_range ( _InIt _First, _InIt _Last,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 _Debug_range2 ( _First, _Last, _File, _Line, _Iter_cat_t < _InIt > ( ) );
 }
#line 971
template < class _InIt,
 class _Pty > inline
 void _Debug_range_ptr2 ( _InIt _First, _InIt _Last, _Pty & _Ptr,
  _Dbfile_t _File, _Dbline_t _Line, input_iterator_tag )
 {
 if ( _First != _Last )
  _Debug_pointer ( _Ptr, _File, _Line );
 }
#line 980
template < class _RanIt,
 class _Pty > inline
 void _Debug_range_ptr2 ( _RanIt _First, _RanIt _Last, _Pty & _Ptr,
  _Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag )
 {
 if ( _First != _Last )
  {
  _Debug_pointer ( _First, _File, _Line );
  _Debug_pointer ( _Last, _File, _Line );
  if ( _Last < _First )
   _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x72\x61\x6e\x67\x65", _File, _Line );
  _Debug_pointer ( _Ptr, _File, _Line );
  }
 }
#line 995
template < class _InIt,
 class _Pty > inline
 void _Debug_range_ptr ( _InIt _First, _InIt _Last, _Pty & _Ptr,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 _Debug_range_ptr2 ( _First, _Last, _Ptr, _File, _Line, _Iter_cat_t < _InIt > ( ) );
 }
#line 1004
template < class _InIt,
 class _Pr > inline
 void _Debug_order2 ( _InIt, _InIt, _Pr &,
  _Dbfile_t, _Dbline_t, input_iterator_tag )
 {
 }
#line 1011
template < class _FwdIt,
 class _Pr > inline
 void _Debug_order2 ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred,
  _Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag )
 {
 for ( _FwdIt _Next = _First; _First != _Last && ++ _Next != _Last; ++ _First )
  if ( _Debug_lt_pred ( _Pred, * _Next, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1017 ) )
   _Debug_message ( L"\x73\x65\x71\x75\x65\x6e\x63\x65\x20\x6e\x6f\x74\x20\x6f\x72\x64\x65\x72\x65\x64", _File, _Line );
 }
#line 1021
template < class _InIt,
 class _Pr > inline
 void _Debug_order ( _InIt _First, _InIt _Last, _Pr && _Pred,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, _File, _Line );
 _Debug_order2 ( _First, _Last, _Pred, _File, _Line, _Iter_cat_t < _InIt > ( ) );
 }
#line 1043 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Ty,
 size_t _Actual,
 class _Diff > inline
 void _Debug_array_size2 ( _Ty ( & ) [ _Actual ], _Diff _Desired,
  _Dbfile_t _File, _Dbline_t _Line )
 {
 if ( _Actual < _Desired )
  _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c", _File, _Line );
 }
#line 1057 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _InIt,
 class _Diff > inline
 void _Advance1 ( _InIt & _Where, _Diff _Off, input_iterator_tag )
 {

 if ( _Off < 0 )
  _Debug_message ( L"\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x69\x6e\x20\x61\x64\x76\x61\x6e\x63\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1063 );


 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 1070 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _BidIt,
 class _Diff > inline
 void _Advance1 ( _BidIt & _Where, _Diff _Off, bidirectional_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _Where;
 for (; _Off < 0; ++ _Off )
  -- _Where;
 }
#line 1080
template < class _RanIt,
 class _Diff > inline
 void _Advance1 ( _RanIt & _Where, _Diff _Off, random_access_iterator_tag )
 {
 _Where += _Off;
 }
#line 1087
template < class _InIt,
 class _Diff > inline
 void advance ( _InIt & _Where, _Diff _Off )
 {

 _Advance1 ( _Where, _Off, _Iter_cat_t < remove_const_t < _InIt >> ( ) );
 }
#line 1096
template < class _InIt > inline
 _Iter_diff_t < _InIt >
  _Distance1 ( _InIt _First, _InIt _Last, input_iterator_tag )
 {
 _Iter_diff_t < _InIt > _Off = 0;
 for (; _First != _Last; ++ _First )
  ++ _Off;

 return ( _Off );
 }
#line 1107
template < class _RanIt > inline
 _Iter_diff_t < _RanIt >
  _Distance1 ( _RanIt _First, _RanIt _Last, random_access_iterator_tag )
 {

 if ( _First != _Last )
  {
  _Debug_pointer ( _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1114 );
  _Debug_pointer ( _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1115 );
  }


 return ( _Last - _First );
 }
#line 1122 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _InIt > inline
 _Iter_diff_t < _InIt >
  distance ( _InIt _First, _InIt _Last )
 {
 return ( _Distance1 ( _First, _Last, _Iter_cat_t < _InIt > ( ) ) );
 }
#line 1130
template < class _InIt > inline
 _InIt next ( _InIt _First, _Iter_diff_t < _InIt > _Off = 1 )
 {
 static_assert ( is_base_of < input_iterator_tag,
  typename iterator_traits < _InIt > :: iterator_category > :: value,
  "next requires input iterator" );

 :: std :: advance ( _First, _Off );
 return ( _First );
 }
#line 1142
template < class _BidIt > inline
 _BidIt prev ( _BidIt _First, _Iter_diff_t < _BidIt > _Off = 1 )
 {
 static_assert ( is_base_of < bidirectional_iterator_tag,
  typename iterator_traits < _BidIt > :: iterator_category > :: value,
  "prev requires bidirectional iterator" );

 :: std :: advance ( _First, - _Off );
 return ( _First );
 }
#line 1154
template < class _Ty >
 struct pointer_traits;
#line 1157
template < class _RanIt >
 class reverse_iterator
  : public iterator <
   typename iterator_traits < _RanIt > :: iterator_category,
   typename iterator_traits < _RanIt > :: value_type,
   typename iterator_traits < _RanIt > :: difference_type,
   typename iterator_traits < _RanIt > :: pointer,
   typename iterator_traits < _RanIt > :: reference >
 {
 typedef reverse_iterator < _RanIt > _Myt;

public :
 typedef typename iterator_traits < _RanIt > :: difference_type difference_type;
 typedef typename iterator_traits < _RanIt > :: pointer pointer;
 typedef typename iterator_traits < _RanIt > :: reference reference;
 typedef _RanIt iterator_type;

 reverse_iterator ( )
  : current ( )
  {
  }

 explicit reverse_iterator ( _RanIt _Right )
  : current ( _Right )
  {
  }

 template < class _Other >
  reverse_iterator ( const reverse_iterator < _Other > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 template < class _Other >
  _Myt & operator = ( const reverse_iterator < _Other > & _Right )
  {
  current = _Right . base ( );
  return ( * this );
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  _RanIt _Tmp = current;
  return ( * -- _Tmp );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

protected :
 _RanIt current;
 };
#line 1272
template< class _RanIt> 
#line 1273
struct _Is_checked_helper< reverse_iterator< _RanIt> , void>  : public _Is_checked_helper< _RanIt>  { 
#line 1276
}; 
#line 1279
template < class _RanIt > inline
 reverse_iterator < _RanIt > operator + (
  typename reverse_iterator < _RanIt > :: difference_type _Off,
  const reverse_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 1287
template < class _RanIt1,
 class _RanIt2 >
 auto inline operator - ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
   -> decltype ( _Right . base ( ) - _Left . base ( ) )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }
#line 1296
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . base ( ) == _Right . base ( ) );
 }
#line 1304
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1312
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right . base ( ) < _Left . base ( ) );
 }
#line 1320
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1328
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1336
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1345
template < class _RanIt > inline
 reverse_iterator < _RanIt > make_reverse_iterator ( _RanIt _Iter )
 {
 return ( reverse_iterator < _RanIt > ( _Iter ) );
 }
#line 1353
template < class _Container >
 auto inline begin ( _Container & _Cont ) -> decltype ( _Cont . begin ( ) )
 {
 return ( _Cont . begin ( ) );
 }
#line 1359
template < class _Container >
 auto inline begin ( const _Container & _Cont ) -> decltype ( _Cont . begin ( ) )
 {
 return ( _Cont . begin ( ) );
 }
#line 1365
template < class _Container >
 auto inline end ( _Container & _Cont ) -> decltype ( _Cont . end ( ) )
 {
 return ( _Cont . end ( ) );
 }
#line 1371
template < class _Container >
 auto inline end ( const _Container & _Cont ) -> decltype ( _Cont . end ( ) )
 {
 return ( _Cont . end ( ) );
 }
#line 1377
template < class _Ty,
 size_t _Size > inline
 constexpr _Ty * begin ( _Ty ( & _Array ) [ _Size ] ) noexcept
 {
 return ( _Array );
 }
#line 1384
template < class _Ty,
 size_t _Size > inline
 constexpr _Ty * end ( _Ty ( & _Array ) [ _Size ] ) noexcept
 {
 return ( _Array + _Size );
 }
#line 1392
template < class _Container >
 constexpr auto inline cbegin ( const _Container & _Cont )
  noexcept ( noexcept ( :: std :: begin ( _Cont ) ) )
  -> decltype ( :: std :: begin ( _Cont ) )
 {
 return ( :: std :: begin ( _Cont ) );
 }
#line 1400
template < class _Container >
 constexpr auto inline cend ( const _Container & _Cont )
  noexcept ( noexcept ( :: std :: end ( _Cont ) ) )
  -> decltype ( :: std :: end ( _Cont ) )
 {
 return ( :: std :: end ( _Cont ) );
 }
#line 1409
template < class _Container >
 auto inline rbegin ( _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) )
 {
 return ( _Cont . rbegin ( ) );
 }
#line 1415
template < class _Container >
 auto inline rbegin ( const _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) )
 {
 return ( _Cont . rbegin ( ) );
 }
#line 1421
template < class _Container >
 auto inline rend ( _Container & _Cont ) -> decltype ( _Cont . rend ( ) )
 {
 return ( _Cont . rend ( ) );
 }
#line 1427
template < class _Container >
 auto inline rend ( const _Container & _Cont ) -> decltype ( _Cont . rend ( ) )
 {
 return ( _Cont . rend ( ) );
 }
#line 1433
template < class _Ty,
 size_t _Size > inline
 reverse_iterator < _Ty * > rbegin ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( reverse_iterator < _Ty * > ( _Array + _Size ) );
 }
#line 1440
template < class _Ty,
 size_t _Size > inline
 reverse_iterator < _Ty * > rend ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( reverse_iterator < _Ty * > ( _Array ) );
 }
#line 1447
template < class _Elem > inline
 reverse_iterator < const _Elem * >
  rbegin ( :: std :: initializer_list < _Elem > _Ilist )
 {
 return ( reverse_iterator < const _Elem * > ( _Ilist . end ( ) ) );
 }
#line 1454
template < class _Elem > inline
 reverse_iterator < const _Elem * >
  rend ( :: std :: initializer_list < _Elem > _Ilist )
 {
 return ( reverse_iterator < const _Elem * > ( _Ilist . begin ( ) ) );
 }
#line 1462
template < class _Container >
 auto inline crbegin ( const _Container & _Cont )
  -> decltype ( :: std :: rbegin ( _Cont ) )
 {
 return ( :: std :: rbegin ( _Cont ) );
 }
#line 1469
template < class _Container >
 auto inline crend ( const _Container & _Cont )
  -> decltype ( :: std :: rend ( _Cont ) )
 {
 return ( :: std :: rend ( _Cont ) );
 }
#line 1477
template < class _Container >
 constexpr auto inline size ( const _Container & _Cont )
  -> decltype ( _Cont . size ( ) )
 {
 return ( _Cont . size ( ) );
 }
#line 1484
template < class _Ty,
 size_t _Size > inline
 constexpr size_t size ( const _Ty ( & ) [ _Size ] ) noexcept
 {
 return ( _Size );
 }
#line 1491
template < class _Container >
 constexpr auto inline empty ( const _Container & _Cont )
  -> decltype ( _Cont . empty ( ) )
 {
 return ( _Cont . empty ( ) );
 }
#line 1498
template < class _Ty,
 size_t _Size > inline
 constexpr bool empty ( const _Ty ( & ) [ _Size ] ) noexcept
 {
 return ( false );
 }
#line 1505
template < class _Elem > inline
 constexpr bool empty (
  :: std :: initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . size ( ) == 0 );
 }
#line 1512
template < class _Container >
 constexpr auto inline data ( _Container & _Cont )
  -> decltype ( _Cont . data ( ) )
 {
 return ( _Cont . data ( ) );
 }
#line 1519
template < class _Container >
 constexpr auto inline data ( const _Container & _Cont )
  -> decltype ( _Cont . data ( ) )
 {
 return ( _Cont . data ( ) );
 }
#line 1526
template < class _Ty,
 size_t _Size > inline
 constexpr _Ty * data ( _Ty ( & _Array ) [ _Size ] ) noexcept
 {
 return ( _Array );
 }
#line 1533
template < class _Elem > inline
 constexpr const _Elem * data (
  :: std :: initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . begin ( ) );
 }
#line 1541
template < class _Ty,
 size_t _Size >
 class _Array_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty &,
   _Iterator_base >
 {
public :
 typedef _Array_const_iterator < _Ty, _Size > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty * pointer;
 typedef const _Ty & reference;
 enum { _EEN_SIZE = _Size };






























































































































 _Array_const_iterator ( )
  : _Ptr ( ),
  _Idx ( 0 )
  {
  }

 explicit _Array_const_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Ptr ( _Parg ),
  _Idx ( _Off )
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  _Idx = _Right - _Ptr;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Ptr + _Idx );
  }

 reference operator * ( ) const
  {

  if ( _Ptr == 0
   || _Size <= _Idx )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1718 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1719, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1719, 0 ); };
   }






  ;

  return ( _Ptr [ _Idx ] );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {

  if ( _Ptr == 0
   || _Size <= _Idx )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65" L"", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1743 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1744, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1744, 0 ); };
   }






  ++ _Idx;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {

  if ( _Ptr == 0
   || _Idx <= 0 )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65" L"", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1769 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1770, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1770, 0 ); };
   }






  -- _Idx;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {

  if ( _Size < _Idx + _Off )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x2b\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72" L"\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1794 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1795, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1795, 0 ); };
   }





  _Idx += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx < _Right . _Idx
   ? - ( difference_type ) ( _Right . _Idx - _Idx )
   : ( difference_type ) _Idx - _Right . _Idx );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx == _Right . _Idx );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx < _Right . _Idx );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


 void _Compat ( const _Myiter & _Right ) const
  {
  if ( _Ptr != _Right . _Ptr )
   {
   _Debug_message ( L"\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1873 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Invalid Argument" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1874, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x49\x6e\x76\x61\x6c\x69\x64\x20" L"\x41\x72\x67\x75\x6d\x65\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 1874, 0 ); };
   }
  }








 pointer _Ptr;
 size_t _Idx;

 };
#line 1890 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _Ty,
 size_t _Size > inline
 typename _Array_const_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_const_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 1898
template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > &
  _Rechecked ( _Array_const_iterator < _Ty, _Size > & _Iter,
   typename _Array_const_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 1908
template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > operator + (
  typename _Array_const_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_const_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 1918
template < class _Ty,
 size_t _Size >
 class _Array_iterator
  : public _Array_const_iterator < _Ty, _Size >
 {
public :
 typedef _Array_iterator < _Ty, _Size > _Myiter;
 typedef _Array_const_iterator < _Ty, _Size > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty * pointer;
 typedef _Ty & reference;

 _Array_iterator ( )
  {
  }

 explicit _Array_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Mybase ( _Parg, _Off )
  {
  }
 enum { _EEN_SIZE = _Size };
 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  ( ( _Mybase * ) this ) -> _Rechecked ( _Right );
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( ( pointer ) ( ( _Mybase * ) this ) -> _Unchecked ( ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 2026
template < class _Ty,
 size_t _Size > inline
 typename _Array_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 2034
template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > &
  _Rechecked ( _Array_iterator < _Ty, _Size > & _Iter,
   typename _Array_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 2044
template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > operator + (
  typename _Array_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 2054
template < class _RanIt >
 class move_iterator
 {
public :
 typedef move_iterator < _RanIt > _Myt;
 typedef typename iterator_traits < _RanIt > :: iterator_category
  iterator_category;
 typedef typename iterator_traits < _RanIt > :: value_type
  value_type;
 typedef typename iterator_traits < _RanIt > :: difference_type
  difference_type;
 typedef _RanIt pointer;
 typedef typename iterator_traits < _RanIt > :: reference _Ref0;
 typedef conditional_t < is_reference < _Ref0 > :: value,
  remove_reference_t < _Ref0 > &&, _Ref0 > reference;
 typedef _RanIt iterator_type;

 move_iterator ( )
  : current ( )
  {
  }

 explicit move_iterator ( iterator_type _Right )
  : current ( _Right )
  {
  }

 template < class _RanIt2 >
  move_iterator ( const move_iterator < _RanIt2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 template < class _RanIt2 >
  _Myt & operator = ( const move_iterator < _RanIt2 > & _Right )
  {
  current = _Right . base ( );
  return ( * this );
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  return ( static_cast < reference > ( * current ) );
  }

 pointer operator -> ( ) const
  {
  return ( current );
  }

 _Myt & operator ++ ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 template < class _RanIt2 >
  bool _Equal ( const move_iterator < _RanIt2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( :: std :: move ( current [ _Off ] ) );
  }

 template < class _RanIt2 >
  bool _Less ( const move_iterator < _RanIt2 > & _Right ) const
  {
  return ( current < _Right . base ( ) );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( current - _Right . base ( ) );
  }

protected :
 iterator_type current;
 };
#line 2185
template< class _RanIt> 
#line 2186
struct _Is_checked_helper< move_iterator< _RanIt> , void>  : public _Is_checked_helper< _RanIt>  { 
#line 2189
}; 
#line 2192
template < class _RanIt,
 class _Diff > inline
 move_iterator < _RanIt >
  operator + ( _Diff _Off,
  const move_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 2201
template < class _RanIt1,
 class _RanIt2 >
 auto inline operator - (
  move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
   -> decltype ( _Left . base ( ) - _Right . base ( ) )
 {
 return ( _Left . base ( ) - _Right . base ( ) );
 }
#line 2211
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 2220
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2229
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 2238
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2247
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2256
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2266
template < class _RanIt > inline
 move_iterator < _RanIt > make_move_iterator ( _RanIt _Iter )
 {
 return ( move_iterator < _RanIt > ( _Iter ) );
 }
#line 2273
template < class _Traits >
 struct _Char_traits_eq
 {
 typedef typename _Traits :: char_type _Elem;

 bool operator ( ) ( _Elem _Left, _Elem _Right ) const
  {
  return ( _Traits :: eq ( _Left, _Right ) );
  }
 };
#line 2285
template < class _Traits >
 struct _Char_traits_lt
 {
 typedef typename _Traits :: char_type _Elem;

 bool operator ( ) ( _Elem _Left, _Elem _Right ) const
  {
  return ( _Traits :: lt ( _Left, _Right ) );
  }
 };
#line 2297
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_memmove ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 const char * const _First_ch = reinterpret_cast < const char * > ( _First );
 const char * const _Last_ch = reinterpret_cast < const char * > ( _Last );
 char * const _Dest_ch = reinterpret_cast < char * > ( _Dest );
 const size_t _Count = _Last_ch - _First_ch;
 :: memmove ( _Dest_ch, _First_ch, _Count );
 return ( reinterpret_cast < _OutIt > ( _Dest_ch + _Count ) );
 }
#line 2310
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }
#line 2320
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 2328
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {

 return ( _Copy_unchecked1 ( _First, _Last,
  _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 2338
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Copy_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 2347
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Copy_unchecked ( _First, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 2357
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_no_deprecate ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2362 );
 return ( _Copy_no_deprecate1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Iter_cat_t < _InIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 2367
template < class _InIt,
 class _OutIt > inline
 _OutIt copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are co" "rrect. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Copy_no_deprecate ( _First, _Last, _Dest ) );
 }
#line 2377
template < class _InIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  _Copy_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }
#line 2390 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked2 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag )
 {
 if ( 0 < _Count )
  {
  * _Dest = * _First;
  while ( 0 < -- _Count )
   * ++ _Dest = * ++ _First;
  return ( ++ _Dest );
  }

 return ( _Dest );
 }
#line 2407
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked2 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag )
 {
 for (; 0 < _Count; -- _Count, ( void ) ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }
#line 2418
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked1 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _General_ptr_iterator_tag )
 {


 return ( _Copy_n_unchecked2 ( _First, _Count,
  _Dest, _Iter_cat_t < _InIt > ( ) ) );
 }
#line 2430
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked1 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 if ( 0 < _Count )
  return ( _Copy_memmove ( _First, _First + _Count, _Dest ) );
 return ( _Dest );
 }
#line 2441
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 return ( _Copy_n_unchecked1 ( _First, _Count,
  _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 2451
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {

 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::copy_n\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are " "correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" "" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Rechecked ( _Dest,
  _Copy_n_unchecked ( _Unchecked_n ( _First, _Count ), _Count, _Unchecked_n ( _Dest, _Count ) ) ) );
 }
#line 2464
template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InTy ( & _First ) [ _InSize ], _Diff _Count,
  _OutIt _Dest )
 {

 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::copy_n\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are " "correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" "" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_array_size2 ( _First, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2473 );
 return ( _Rechecked ( _Dest,
  _Copy_n_unchecked ( _First, _Count, _Unchecked_n ( _Dest, _Count ) ) ) );
 }
#line 2478
template < class _InIt,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * copy_n ( _InIt _First, _Diff _Count,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 _Debug_array_size2 ( _Dest, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2485 );
 return ( _Copy_n_unchecked ( _Unchecked_n ( _First, _Count ), _Count, _Dest ) );
 }
#line 2489
template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * copy_n ( _InTy ( & _First ) [ _InSize ], _Diff _Count,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 _Debug_array_size2 ( _First, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2497 );
 _Debug_array_size2 ( _Dest, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2498 );
 return ( _Copy_n_unchecked ( _First, _Count, _Dest ) );
 }
#line 2504 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_memmove ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 const char * const _First_ch = reinterpret_cast < const char * > ( _First );
 const char * const _Last_ch = reinterpret_cast < const char * > ( _Last );
 char * const _Dest_ch = reinterpret_cast < char * > ( _Dest );
 const size_t _Count = _Last_ch - _First_ch;
 return ( static_cast < _BidIt2 > (
  :: memmove ( _Dest_ch - _Count, _First_ch, _Count ) ) );
 }
#line 2517
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_unchecked1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = * -- _Last;
 return ( _Dest );
 }
#line 2527
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_unchecked1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_backward_memmove ( _First, _Last, _Dest ) );
 }
#line 2535
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Copy_backward_unchecked1 ( _First, _Last,
  _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 2544
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Copy_backward_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 2553
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) - ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Copy_backward_unchecked ( _First, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 2563
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::copy_backward\' with parameters that may be unsafe - this call relies on the caller to check that the passed valu" "es are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Ite" "rators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2569 );
 return ( _Copy_backward1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Iter_cat_t < _BidIt1 > ( ), _Iter_cat_t < _BidIt2 > ( ) ) );
 }
#line 2575
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  * _Dest = :: std :: move ( * _First );
 return ( _Dest );
 }
#line 2585
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 2593
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Move_unchecked1 ( _First, _Last,
  _Dest, _Ptr_move_cat ( _First, _Dest ) ) );
 }
#line 2602
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Move_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 2611
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Move_unchecked ( _First, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 2621
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_no_deprecate ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2626 );
 return ( _Move_no_deprecate1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Iter_cat_t < _InIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 2631
template< class _InIt, class 
#line 2632
_OutIt> inline _OutIt 
#line 2633
move(_InIt _First, _InIt _Last, _OutIt 
#line 2634
_Dest) 
#line 2635
{ 
#line 2636
struct _Unchecked_iterators { __declspec(deprecated("Call to \'std::move\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are co" "rrect. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'")) static void _Deprecate(std::false_type) { } static void _Deprecate(std::true_type) { } }; _Unchecked_iterators::_Deprecate(_Is_checked(_Dest)); 
#line 2637
return _Move_no_deprecate(_First, _Last, _Dest); 
#line 2638
} 
#line 2641
template< class _InIt, class 
#line 2642
_OutTy, size_t 
#line 2643
_OutSize> inline _OutTy *
#line 2644
move(_InIt _First, _InIt _Last, _OutTy (&
#line 2645
_Dest)[_OutSize]) 
#line 2646
{ 
#line 2647
return _Unchecked(_Move_no_deprecate(_First, _Last, ((_Array_iterator< _OutTy, _OutSize> )(_Dest)))); 
#line 2650
} 
#line 2654 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward_unchecked1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = :: std :: move ( * -- _Last );
 return ( _Dest );
 }
#line 2664
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward_unchecked1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_backward_memmove ( _First, _Last, _Dest ) );
 }
#line 2672
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Move_backward_unchecked1 ( _First, _Last,
  _Dest, _Ptr_move_cat ( _First, _Dest ) ) );
 }
#line 2681
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Move_backward_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 2690
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) - ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Move_backward_unchecked ( _First, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 2700
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::move_backward\' with parameters that may be unsafe - this call relies on the caller to check that the passed valu" "es are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Ite" "rators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2706 );
 return ( _Move_backward1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Iter_cat_t < _BidIt1 > ( ), _Iter_cat_t < _BidIt2 > ( ) ) );
 }
#line 2712
template< class _Ty> 
#line 2713
struct _Is_character : public false_type { 
#line 2716
}; 
#line 2719
template<> struct _Is_character< char>  : public true_type { 
#line 2722
}; 
#line 2725
template<> struct _Is_character< signed char>  : public true_type { 
#line 2728
}; 
#line 2731
template<> struct _Is_character< unsigned char>  : public true_type { 
#line 2734
}; 
#line 2736
template< class _FwdIt, class 
#line 2737
_Ty> 
#line 2738
struct _Fill_memset_is_safe_helper { 
#line 2740
typedef _Iter_value_t< _FwdIt>  _Value_type; 
#line 2750
typedef typename conjunction< is_pointer< _FwdIt> , disjunction< conjunction< _Is_character< _Ty> , _Is_character< _Iter_value_t< _FwdIt> > > , conjunction< is_same< bool, _Ty> , is_same< bool, _Iter_value_t< _FwdIt> > > > > ::type type; 
#line 2751
}; 
#line 2753
template < class _FwdIt,
 class _Ty > inline
 typename _Fill_memset_is_safe_helper < _FwdIt, _Ty > :: type
 _Fill_memset_is_safe ( const _FwdIt &, const _Ty & )
 {
 return { };
 }
#line 2761
template < class _FwdIt,
 class _Ty > inline
 void _Fill_unchecked1 ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, false_type )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Val;
 }
#line 2769
template < class _FwdIt,
 class _Ty > inline
 void _Fill_unchecked1 ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, true_type )
 {
 :: memset ( _First, _Val, _Last - _First );
 }
#line 2776
template < class _FwdIt,
 class _Ty > inline
 void _Fill_unchecked ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Fill_unchecked1 ( _First, _Last, _Val, _Fill_memset_is_safe ( _First, _Val ) );
 }
#line 2783
template < class _FwdIt,
 class _Ty > inline
 void fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2787 );
 _Fill_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val );
 }
#line 2792
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt _Fill_n_unchecked1 ( _OutIt _Dest, _Diff _Count, const _Ty & _Val, false_type )
 {
 for (; 0 < _Count; -- _Count, ( void ) ++ _Dest )
  * _Dest = _Val;
 return ( _Dest );
 }
#line 2802
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt _Fill_n_unchecked1 ( _OutIt _Dest, _Diff _Count, const _Ty & _Val, true_type )
 {
 if ( 0 < _Count )
  {
  :: memset ( _Dest, _Val, _Count );
  return ( _Dest + _Count );
  }

 return ( _Dest );
 }
#line 2816
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt _Fill_n_unchecked ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {

 return ( _Fill_n_unchecked1 ( _Dest, _Count, _Val, _Fill_memset_is_safe ( _Dest, _Val ) ) );
 }
#line 2825
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 return ( _Rechecked ( _Dest,
  _Fill_n_unchecked ( _Unchecked_n ( _Dest, _Count ), _Count, _Val ) ) );
 }
#line 2835
template< class _Elem1, class 
#line 2836
_Elem2> 
#line 2837
struct _Value_equality_is_bitwise_equality : public bool_constant< (static_cast< _Elem1>(-1)) == (static_cast< _Elem2>(-1))>  { 
#line 2843
}; 
#line 2845
template< class _Elem1, class 
#line 2846
_Elem2, class 
#line 2847
_Pr> 
#line 2848
struct _Equal_memcmp_is_safe_helper : public false_type { 
#line 2852
}; 
#line 2854
template< class _Elem1, class 
#line 2855
_Elem2> 
#line 2856
struct _Equal_memcmp_is_safe_helper< _Elem1, _Elem2, equal_to<> >  : public conjunction< _Is_same_size< _Elem1, _Elem2> , is_integral< _Elem1> , is_integral< _Elem2> , negation< is_same< bool, _Elem1> > , negation< is_same< bool, _Elem2> > , negation< is_volatile< _Elem1> > , negation< is_volatile< _Elem2> > , _Value_equality_is_bitwise_equality< _Elem1, _Elem2> > ::type { 
#line 2870
}; 
#line 2872
template< class _Elem1, class 
#line 2873
_Elem2> 
#line 2874
struct _Equal_memcmp_is_safe_helper< _Elem1 *, _Elem2 *, equal_to<> >  : public is_same< remove_cv_t< _Elem1> , remove_cv_t< _Elem2> > ::type { 
#line 2877
}; 
#line 2879
template< class _Elem> 
#line 2880
struct _Equal_memcmp_is_safe_helper< _Elem, _Elem, _Char_traits_eq< char_traits< _Elem> > >  : public _Equal_memcmp_is_safe_helper< _Elem, _Elem, equal_to<> > ::type { 
#line 2883
}; 
#line 2885
template< class _Elem> 
#line 2886
struct _Equal_memcmp_is_safe_helper< _Elem, _Elem, equal_to< _Elem> >  : public _Equal_memcmp_is_safe_helper< _Elem, _Elem, equal_to<> > ::type { 
#line 2890
}; 
#line 2892
template < class _Iter1,
 class _Iter2,
 class _Pr > inline
 false_type _Equal_memcmp_is_safe ( const _Iter1 &, const _Iter2 &, const _Pr & )
 {
 return { };
 }
#line 2900
template < class _Obj1,
 class _Obj2,
 class _Pr > inline
 typename _Equal_memcmp_is_safe_helper <
  remove_const_t < _Obj1 >,
  remove_const_t < _Obj2 >,
  _Pr > :: type
  _Equal_memcmp_is_safe ( _Obj1 * const &, _Obj2 * const &, const _Pr & )
 {
 return { };
 }
#line 2912
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr & _Pred, false_type )
 {
 for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   return ( false );
 return ( true );
 }
#line 2924
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr &, true_type )
 {
 const char * const _First1_ch = reinterpret_cast < const char * > ( _First1 );
 const char * const _First2_ch = reinterpret_cast < const char * > ( _First2 );
 const size_t _Count = reinterpret_cast < const char * > ( _Last1 ) - _First1_ch;
 return ( :: memcmp ( _First1_ch, _First2_ch, _Count ) == 0 );
 }
#line 2936
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr & _Pred )
 {
 return ( _Equal_unchecked1 ( _First1, _Last1, _First2, _Pred,
  _Equal_memcmp_is_safe ( _First1, _First2, _Pred ) ) );
 }
#line 2946
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr & _Pred, input_iterator_tag, input_iterator_tag )
 {
 return ( _Equal_unchecked ( _First1, _Last1, _Unchecked_idl0 ( _First2 ), _Pred ) );
 }
#line 2955
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr & _Pred, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _First2 ) + ( ( _Last1 ) - ( _First1 ) ) );
 return ( _Equal_unchecked ( _First1, _Last1, _Unchecked ( _First2 ), _Pred ) );
 }
#line 2965
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr & _Pred )
 {
 _Debug_range_ptr ( _First1, _Last1, _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2971 );
 _Debug_pointer_if ( _First1 != _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 2972 );
 return ( _Equal_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Pred, _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _InIt2 > ( ) ) );
 }
#line 2977
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::equal\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are c" "orrect. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" "" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _First2 ) ) );
 return ( _Equal_no_deprecate ( _First1, _Last1, _First2, _Pred ) );
 }
#line 2988
template < class _InIt1,
 class _InTy,
 size_t _InSize,
 class _Pr,
 class = enable_if_t < ! is_same < _InTy *, _Pr > :: value > > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ], _Pr _Pred )
 {
 return ( _Equal_no_deprecate ( _First1, _Last1,
  _Array_iterator < _InTy, _InSize > ( _First2 ), _Pred ) );
 }
#line 3002 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2 )
 {
 return ( :: std :: equal ( _First1, _Last1, _First2,
  equal_to < > ( ) ) );
 }
#line 3012
template < class _InIt1,
 class _InTy,
 size_t _InSize > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ] )
 {
 return ( :: std :: equal ( _First1, _Last1, _First2,
  equal_to < > ( ) ) );
 }
#line 3024 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr & _Pred,
   input_iterator_tag, input_iterator_tag )
 {

 _Debug_pointer_if ( _First1 != _Last1 && _First2 != _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3032 );
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ( void ) ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   return ( false );
 return ( _First1 == _Last1 && _First2 == _Last2 );
 }
#line 3039
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr & _Pred,
   random_access_iterator_tag, random_access_iterator_tag )
 {

 if ( _Last1 - _First1 != _Last2 - _First2 )
  return ( false );
 _Debug_pointer_if ( _First1 != _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3049 );
 return ( _Equal_unchecked ( _First1, _Last1, _First2, _Pred ) );
 }
#line 3053
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3059 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3060 );
 return ( _Equal_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred,
   _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _InIt2 > ( ) ) );
 }
#line 3067
template < class _InIt1,
 class _InIt2 > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 return ( :: std :: equal ( _First1, _Last1, _First2, _Last2,
  equal_to < > ( ) ) );
 }
#line 3077
template< class _Elem1, class 
#line 3078
_Elem2, class 
#line 3079
_FTy> 
#line 3080
struct _Lex_compare_check_element_types_helper : public conjunction< _Is_character< _Elem1> , _Is_character< _Elem2> , _Is_character< _FTy> , is_unsigned< _FTy> > ::type { 
#line 3088
}; 
#line 3090
template< class _Elem1, class 
#line 3091
_Elem2> 
#line 3092
struct _Lex_compare_check_element_types_helper< _Elem1, _Elem2, void>  : public conjunction< _Is_character< _Elem1> , _Is_character< _Elem2> , is_unsigned< _Elem1> , is_unsigned< _Elem2> > ::type { 
#line 3100
}; 
#line 3102
template< class _Memcmp_pr> 
#line 3103
struct _Lex_compare_optimize { 
#line 3105
}; 
#line 3107
template< class _Memcmp_pr, class 
#line 3108
_Obj1, class 
#line 3109
_Obj2, class 
#line 3110
_FTy> using _Lex_compare_check_element_types = _Lex_compare_optimize< conditional_t< _Lex_compare_check_element_types_helper< remove_const_t< _Obj1> , remove_const_t< _Obj2> , _FTy> ::value, _Memcmp_pr, void> > ; 
#line 3115
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 _Lex_compare_optimize < void > _Lex_compare_memcmp_classify ( const _InIt1 &, const _InIt2 &, const _Pr & )
 {

 return { };
 }
#line 3124
template < class _Obj1,
 class _Obj2,
 class _FTy > inline
 _Lex_compare_check_element_types < less < int >, _Obj1, _Obj2, _FTy >
  _Lex_compare_memcmp_classify ( _Obj1 * const &, _Obj2 * const &, const less < _FTy > & )
 {
 return { };
 }
#line 3133
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Lex_compare_unchecked1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr & _Pred, _Lex_compare_optimize < void > )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ( void ) ++ _First2 )
  {
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3141 ) )
   return ( true );
  else if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
  }

 return ( _First1 == _Last1 && _First2 != _Last2 );
 }
#line 3150
template < class _InIt1,
 class _InIt2,
 class _Pr,
 class _Memcmp_pr > inline
 bool _Lex_compare_unchecked1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr &, _Lex_compare_optimize < _Memcmp_pr > )
 {
 const size_t _Num1 = _Last1 - _First1;
 const size_t _Num2 = _Last2 - _First2;
 const int _Ans = :: memcmp ( _First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2 );
 return ( _Memcmp_pr { } ( _Ans, 0 ) || _Ans == 0 && _Num1 < _Num2 );
 }
#line 3163
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Lex_compare_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr & _Pred )
 {
 return ( _Lex_compare_unchecked1 ( _First1, _Last1, _First2, _Last2, _Pred,
  _Lex_compare_memcmp_classify ( _First1, _First2, _Pred ) ) );
 }
#line 3173
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3179 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3180 );
 _Debug_pointer_if ( _First1 != _Last1 && _First2 != _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3181 );
 return ( _Lex_compare_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) );
 }
#line 3187
template < class _InIt1,
 class _InIt2 > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 return ( :: std :: lexicographical_compare ( _First1, _Last1,
  _First2, _Last2, less < > ( ) ) );
 }
#line 3197
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, true_type, _Any_tag )
 {
 return ( ( - 128 ) <= _Val && _Val <= 127 );
 }
#line 3203
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, false_type, true_type )
 {
 return ( _Val <= 127 || static_cast < _Ty > ( ( - 128 ) ) <= _Val );
 }
#line 3209
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, false_type, false_type )
 {
 return ( _Val <= 127 );
 }
#line 3215
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, false_type, true_type, _Any_tag )
 {
 return ( 0 <= _Val && _Val <= 255 );
 }
#line 3221
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, false_type, false_type, _Any_tag )
 {
 return ( _Val <= 255 );
 }
#line 3227
template < class _InIt,
 class _Ty > inline
 bool _Within_limits ( _InIt, const _Ty & _Val )
 {
 typedef typename remove_pointer < _InIt > :: type _Elem;
 return ( _Within_limits ( _Val, is_signed < _Elem > ( ), is_signed < _Ty > ( ),
  integral_constant < bool, - 1 == static_cast < _Ty > ( - 1 ) > ( ) ) );
 }
#line 3236
template < class _InIt > inline
 bool _Within_limits ( _InIt, const bool & )
 {
 return ( true );
 }
#line 3242
template < class _InIt,
 class _Ty > inline
 _InIt _Find_unchecked1 ( _InIt _First, _InIt _Last, const _Ty & _Val, true_type )
 {
 if ( ! _Within_limits ( _First, _Val ) )
  return ( _Last );
 _First = static_cast < _InIt > ( :: memchr (
  _First, static_cast < unsigned char > ( _Val ), _Last - _First ) );
 return ( _First ? _First : _Last );
 }
#line 3253
template < class _InIt,
 class _Ty > inline
 _InIt _Find_unchecked1 ( _InIt _First, _InIt _Last, const _Ty & _Val, false_type )
 {
 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   break;
 return ( _First );
 }
#line 3263
template < class _InIt,
 class _Ty > inline
 _InIt _Find_unchecked ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {

 typedef integral_constant < bool,
  ( is_same < _InIt, char * > :: value
  || is_same < _InIt, signed char * > :: value
  || is_same < _InIt, unsigned char * > :: value
  || is_same < _InIt, const char * > :: value
  || is_same < _InIt, const signed char * > :: value
  || is_same < _InIt, const unsigned char * > :: value )
  && is_integral < _Ty > :: value
 > _Memchr_opt;
 return ( _Find_unchecked1 ( _First, _Last, _Val, _Memchr_opt ( ) ) );
 }
#line 3280
template < class _InIt,
 class _Ty > inline
 _InIt find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3284 );
 return ( _Rechecked ( _First,
  _Find_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) ) );
 }
#line 3290
template < class _InIt,
 class _Ty,
 class _Pr > inline
 _InIt _Find_pr ( _InIt _First, _InIt _Last, const _Ty & _Val, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First, _Val ) )
   break;
 return ( _First );
 }
#line 3302
template < class _InIt,
 class _Ty > inline
 _Iter_diff_t < _InIt >
  _Count_unchecked ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 _Iter_diff_t < _InIt > _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   ++ _Count;
 return ( _Count );
 }
#line 3315
template < class _InIt,
 class _Ty > inline
 _Iter_diff_t < _InIt >
  count ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3320 );
 return ( _Count_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) );
 }
#line 3325
template < class _InIt,
 class _Ty,
 class _Pr > inline
 _Iter_diff_t < _InIt >
  _Count_pr ( _InIt _First, _InIt _Last, const _Ty & _Val, _Pr & _Pred )
 {
 _Iter_diff_t < _InIt > _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First, _Val ) )
   ++ _Count;
 return ( _Count );
 }
#line 3340
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 void _Trim_matching_suffixes ( _FwdIt1 &, _FwdIt2 &, _Pr &,
  forward_iterator_tag, forward_iterator_tag )
 {
 }
#line 3348
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 void _Trim_matching_suffixes ( _FwdIt1 & _Last1, _FwdIt2 & _Last2, _Pr & _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag )
 {

 while ( _Pred ( * -- _Last1, * -- _Last2 ) )
  ;
 ++ _Last1;
 ++ _Last2;
 }
#line 3362
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Check_match_counts ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred )
 {
 _Trim_matching_suffixes ( _Last1, _Last2, _Pred,
  _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) );
 for ( _FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++ _Next1 )
  if ( _Next1 == _Find_pr ( _First1, _Next1, * _Next1, _Pred ) )
   {
   _Iter_diff_t < _FwdIt2 > _Count2 = _Count_pr ( _First2, _Last2, * _Next1, _Pred );
   if ( _Count2 == 0 )
    return ( false );
   _FwdIt1 _Skip1 = :: std :: next ( _Next1 );
   _Iter_diff_t < _FwdIt1 > _Count1 = _Count_pr ( _Skip1, _Last1, * _Next1, _Pred ) + 1;
   if ( _Count2 != _Count1 )
    return ( false );
   }

 return ( true );
 }
#line 3386
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr & _Pred )
 {
 for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   {
   _FwdIt2 _Last2 = :: std :: next ( _First2,
    :: std :: distance ( _First1, _Last1 ) );
   return ( _Check_match_counts ( _First1, _Last1,
    _First2, _Last2, _Pred ) );
   }

 return ( true );
 }
#line 3404
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_no_deprecate1 ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr & _Pred, forward_iterator_tag, forward_iterator_tag )
 {
 return ( _Is_permutation_unchecked ( _First1, _Last1, _Unchecked_idl0 ( _First2 ), _Pred ) );
 }
#line 3413
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_no_deprecate1 ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr & _Pred, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _First2 ) + ( ( _Last1 ) - ( _First1 ) ) );
 return ( _Is_permutation_unchecked ( _First1, _Last1, _Unchecked ( _First2 ), _Pred ) );
 }
#line 3423
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_no_deprecate ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr & _Pred )
 {
 _Debug_range_ptr ( _First1, _Last1, _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3429 );
 _Debug_pointer_if ( _First1 != _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3430 );
 return ( _Is_permutation_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Pred, _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) ) );
 }
#line 3435
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::is_permutation\' with parameters that may be unsafe - this call relies on the caller to check that the passed val" "ues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked It" "erators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _First2 ) ) );
 return ( _Is_permutation_no_deprecate ( _First1, _Last1, _First2, _Pred ) );
 }
#line 3446
template < class _FwdIt1,
 class _InTy,
 size_t _InSize,
 class _Pr,
 class = enable_if_t < ! is_same < _InTy *, _Pr > :: value > > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ], _Pr _Pred )
 {
 return ( _Is_permutation_no_deprecate ( _First1, _Last1,
  _Array_iterator < _InTy, _InSize > ( _First2 ), _Pred ) );
 }
#line 3460 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _FwdIt1,
 class _FwdIt2 > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2 )
 {
 return ( :: std :: is_permutation ( _First1, _Last1,
  _First2, equal_to < > ( ) ) );
 }
#line 3471
template < class _FwdIt1,
 class _InTy,
 size_t _InSize > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ] )
 {
 return ( :: std :: is_permutation ( _First1, _Last1, _First2, equal_to < > ( ) ) );
 }
#line 3482 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred,
  forward_iterator_tag, forward_iterator_tag )
 {

 _Debug_pointer_if ( _First1 != _Last1 && _First2 != _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3490 );
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ( void ) ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   {
   if ( :: std :: distance ( _First1, _Last1 )
    != :: std :: distance ( _First2, _Last2 ) )
    return ( false );
   else
    return ( _Check_match_counts ( _First1, _Last1,
     _First2, _Last2, _Pred ) );
   }

 return ( _First1 == _Last1 && _First2 == _Last2 );
 }
#line 3505
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred,
  random_access_iterator_tag, random_access_iterator_tag )
 {

 if ( _Last1 - _First1 != _Last2 - _First2 )
  return ( false );
 _Debug_pointer_if ( _First1 != _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3515 );
 return ( _Is_permutation_unchecked ( _First1, _Last1, _First2, _Pred ) );
 }
#line 3519
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {

 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3526 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3527 );
 return ( _Is_permutation_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred,
  _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) ) );
 }
#line 3534
template < class _FwdIt1,
 class _FwdIt2 > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 return ( :: std :: is_permutation ( _First1, _Last1,
  _First2, _Last2, equal_to < > ( ) ) );
 }
#line 3544
template < class _BidIt > inline
 void _Reverse_unchecked ( _BidIt _First, _BidIt _Last )
 {
 for (; _First != _Last && _First != -- _Last; ++ _First )
  :: std :: iter_swap ( _First, _Last );
 }
#line 3551
template < class _BidIt > inline
 void reverse ( _BidIt _First, _BidIt _Last )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3554 );
 _Reverse_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ) );
 }
#line 3559
template < class _FwdIt > inline
 _FwdIt _Rotate_unchecked1 ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag )
 {
 for ( _FwdIt _Next = _Mid, _Res = _Last;; )
  {
  :: std :: iter_swap ( _First, _Next );
  if ( ++ _First == _Mid )
   {
   if ( ++ _Next == _Last )
    return ( _Res == _Last ? _Mid : _Res );
   else
    _Mid = _Next;
   }
  else if ( ++ _Next == _Last )
   {
   if ( _Res == _Last )
    _Res = _First;
   _Next = _Mid;
   }
  }
 }
#line 3582
template < class _BidIt > inline
 pair < _BidIt, _BidIt > _Reverse_until_sentinel_unchecked (
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last )
 {
 while ( _First != _Sentinel && _Last != _Sentinel )
  :: std :: iter_swap ( _First ++, -- _Last );
 return ( :: std :: make_pair ( _First, _Last ) );
 }
#line 3591
template < class _BidIt > inline
 _BidIt _Rotate_unchecked1 ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag )
 {
 _Reverse_unchecked ( _First, _Mid );
 _Reverse_unchecked ( _Mid, _Last );
 pair < _BidIt, _BidIt > _Tmp = _Reverse_until_sentinel_unchecked ( _First, _Mid, _Last );
 _Reverse_unchecked ( _Tmp . first, _Tmp . second );
 return ( _Mid != _Tmp . first ? _Tmp . first : _Tmp . second );
 }
#line 3602
template < class _RanIt > inline
 _RanIt _Rotate_unchecked1 ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag )
 {
 _Reverse_unchecked ( _First, _Mid );
 _Reverse_unchecked ( _Mid, _Last );
 _Reverse_unchecked ( _First, _Last );
 return ( _First + ( _Last - _Mid ) );
 }
#line 3612
template < class _FwdIt > inline
 _FwdIt _Rotate_unchecked ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 if ( _First == _Mid )
  return ( _Last );
 if ( _Mid == _Last )
  return ( _First );
 return ( _Rotate_unchecked1 ( _First, _Mid, _Last, _Iter_cat_t < _FwdIt > ( ) ) );
 }
#line 3622
template < class _FwdIt > inline
 _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 _Debug_range ( _First, _Mid, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3625 );
 _Debug_range ( _Mid, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x75\x74\x69\x6c\x69\x74\x79", 3626 );
 return ( _Rechecked ( _First,
  _Rotate_unchecked ( _Unchecked ( _First ), _Unchecked ( _Mid ),
  _Unchecked ( _Last ) ) ) );
 }
#line 3633
template < class _Diff,
 class _Urng >
 class _Rng_from_urng
 {
public :
 typedef typename make_unsigned < _Diff > :: type _Ty0;
 typedef typename _Urng :: result_type _Ty1;

 typedef typename _If < sizeof ( _Ty1 ) < sizeof ( _Ty0 ),
  _Ty0, _Ty1 > :: type _Udiff;


 explicit _Rng_from_urng ( _Urng & _Func )
  : _Ref ( _Func ), _Bits ( 8 * sizeof ( _Udiff ) ), _Bmask ( _Udiff ( - 1 ) )
  {
  for (; ( _Urng :: max ) ( ) - ( _Urng :: min ) ( ) < _Bmask; _Bmask >>= 1 )
   -- _Bits;
  }

 _Diff operator ( ) ( _Diff _Index )
  {
  for (;; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while ( _Mask < _Udiff ( _Index - 1 ) )
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits ( );
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if ( _Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff ( _Index - 1 ) )
    return ( _Ret % _Index );
   }
  }

 _Udiff _Get_all_bits ( )
  {
  _Udiff _Ret = 0;

  for ( size_t _Num = 0; _Num < 8 * sizeof ( _Udiff );
   _Num += _Bits )
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits ( );
   }

  return ( _Ret );
  }

 _Rng_from_urng ( const _Rng_from_urng & ) = delete;
 _Rng_from_urng & operator = ( const _Rng_from_urng & ) = delete;

private :
 _Udiff _Get_bits ( )
  {
  for (;; )
   {
   _Udiff _Val = _Ref ( ) - ( _Urng :: min ) ( );

   if ( _Val <= _Bmask )
    return ( _Val );
   }
  }

 _Urng & _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };
#line 3712
template < class _Elem >
 class __declspec ( dllimport ) _Yarn
 {
public :
 typedef _Yarn < _Elem > _Myt;

  _Yarn ( )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  }

  _Yarn ( const _Myt & _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

  _Yarn ( const _Elem * _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  return ( * this = _Right . _Myptr );
  }

 _Myt & operator = ( const _Elem * _Right )
  {
  if ( _Myptr != _Right )
   {
   _Tidy ( );

   if ( _Right != 0 )
    {
    const _Elem * _Ptr = _Right;
    while ( * _Ptr != ( _Elem ) 0 )
     ++ _Ptr;
    size_t _Count = ( ( const char * ) ++ _Ptr - ( const char * ) _Right );


    _Myptr = ( _Elem * ) _malloc_dbg ( _Count, 2,
     "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility", 3755 );





    if ( _Myptr != 0 )
     :: memcpy ( _Myptr, _Right, _Count );
    }
   }

  return ( * this );
  }

  ~ _Yarn ( ) noexcept
  {
  _Tidy ( );
  }

 bool empty ( ) const
  {
  return ( _Myptr == 0 );
  }

 const _Elem * c_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

 bool _Empty ( ) const
  {
  return ( _Myptr == 0 );
  }

 const _Elem * _C_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

private :
 void _Tidy ( )
  {
  if ( _Myptr != 0 )


   _free_dbg ( _Myptr, 2 );





  _Myptr = 0;
  }

 _Elem * _Myptr;
 _Elem _Nul;
 };
#line 3814 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
template< class _Ty, class 
#line 3815
_Alloc> 
#line 3816
struct _Has_allocator_type { 
#line 3818
template< class _Uty> static auto _Fn(int)->is_convertible< _Alloc, typename _Uty::allocator_type> ; 
#line 3822
template< class _Uty> static auto _Fn(_Wrap_int)->false_type; 
#line 3826
typedef decltype((_Fn< _Ty> (0))) type; 
#line 3827
}; 
#line 3830
struct allocator_arg_t { 
#line 3832
}; 
#line 3834
constexpr allocator_arg_t allocator_arg{}; 
#line 3836
[[noreturn]] __declspec(dllimport) void __cdecl _Xbad_alloc(); 
#line 3837
[[noreturn]] __declspec(dllimport) void __cdecl _Xinvalid_argument(const char *); 
#line 3838
[[noreturn]] __declspec(dllimport) void __cdecl _Xlength_error(const char *); 
#line 3839
[[noreturn]] __declspec(dllimport) void __cdecl _Xout_of_range(const char *); 
#line 3840
[[noreturn]] __declspec(dllimport) void __cdecl _Xoverflow_error(const char *); 
#line 3841
[[noreturn]] __declspec(dllimport) void __cdecl _Xruntime_error(const char *); 
#line 3842
}
#line 3844
namespace std { 
#line 3846
template< class _Ty, class 
#line 3847
_Alloc> 
#line 3848
struct uses_allocator : public _Has_allocator_type< _Ty, _Alloc> ::type { 
#line 3851
}; 
#line 3854
template< class _Ty, class 
#line 3855
_Alloc> constexpr bool 
#line 3856
uses_allocator_v = (uses_allocator< _Ty, _Alloc> ::value); 
#line 3858 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
}
#line 3860
#pragma warning(pop)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
#pragma warning(push,3)
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
#pragma warning(disable: 4100)
#line 3861 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xutility"
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
#pragma pack ( push, 8 )
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
namespace std { 
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
__declspec(allocator) inline void *_Allocate(size_t _Count, size_t _Sz, bool 
#line 47
_Try_aligned_allocation = true) 
#line 48
{ 
#line 49
void *_Ptr = (0); 
#line 51
if (_Count == (0)) { 
#line 52
return _Ptr; }  
#line 55
if ((((size_t)(-1)) / _Sz) < _Count) { 
#line 56
_Xbad_alloc(); }  
#line 57
const size_t _User_size = _Count * _Sz; 
#line 60
if (_Try_aligned_allocation && ((4096) <= _User_size)) 
#line 62
{ 
#line 63
static_assert((sizeof(void *) < (32)), "Big allocations should at least match vector register size");
#line 65
const size_t _Block_size = ((((2) * sizeof(void *)) + (32)) - (1)) + _User_size; 
#line 66
if (_Block_size <= _User_size) { 
#line 67
_Xbad_alloc(); }  
#line 68
const uintptr_t _Ptr_container = reinterpret_cast< uintptr_t>(::operator new(_Block_size)); 
#line 70
{ if (!(_Ptr_container != (0))) { (void)(((!(!(("_Ptr_container != 0") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 70, 0, L"\x25\x6c\x73", L"\x22\x5f\x50\x74\x72\x5f\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x21\x3d\x20\x30\x22\x20\x26\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x41\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 70, 0); }  ; } ; 
#line 71
_Ptr = (reinterpret_cast< void *>((_Ptr_container + ((((2) * sizeof(void *)) + (32)) - (1))) & (~(32 - 1)))); 
#line 73
((static_cast< uintptr_t *>(_Ptr))[-1]) = _Ptr_container; 
#line 76
((static_cast< uintptr_t *>(_Ptr))[-2]) = 18085043209519168250Ui64; 
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
} else 
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
{ 
#line 83
_Ptr = ::operator new(_User_size); 
#line 84
{ if (!(_Ptr != (0))) { (void)(((!(!(("_Ptr != 0") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 84, 0, L"\x25\x6c\x73", L"\x22\x5f\x50\x74\x72\x20\x21\x3d\x20\x30\x22\x20\x26\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x41\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 84, 0); }  ; } ; 
#line 85
}  
#line 86
return _Ptr; 
#line 87
} 
#line 91
inline void _Deallocate(void *_Ptr, size_t _Count, size_t _Sz) 
#line 92
{ 
#line 94
{ if (!(_Count <= (((size_t)(-1)) / _Sz))) { (void)(((!(!(("_Count <= (size_t)(-1) / _Sz") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 94, 0, L"\x25\x6c\x73", L"\x22\x5f\x43\x6f\x75\x6e\x74\x20\x3c\x3d\x20\x28\x73\x69\x7a\x65\x5f\x74\x29\x28\x2d\x31\x29\x20\x2f\x20\x5f\x53\x7a\x22\x20\x26" L"\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x44\x65\x61\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 94, 0); }  ; } ; 
#line 95
const size_t _User_size = _Count * _Sz; 
#line 96
if ((4096) <= _User_size) 
#line 97
{ 
#line 98
const uintptr_t _Ptr_user = reinterpret_cast< uintptr_t>(_Ptr); 
#line 99
{ if (!((_Ptr_user & (32 - 1)) == (0))) { (void)(((!(!(("(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 100, 0, L"\x25\x6c\x73", L"\x22\x28\x5f\x50\x74\x72\x5f\x75\x73\x65\x72\x20\x26\x20\x28\x5f\x42\x49\x47\x5f\x41\x4c\x4c\x4f\x43\x41\x54\x49\x4f\x4e\x5f\x41" L"\x4c\x49\x47\x4e\x4d\x45\x4e\x54\x20\x2d\x20\x31\x29\x29\x20\x3d\x3d\x20\x30\x22\x20\x26\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x44\x65\x61\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 100, 0); }  ; } ; 
#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *); 
#line 102
const uintptr_t _Ptr_container = *(reinterpret_cast< uintptr_t *>(_Ptr_ptr)); 
#line 108
{ if (!(((reinterpret_cast< uintptr_t *>(_Ptr_ptr))[-1]) == 18085043209519168250Ui64)) { (void)(((!(!(("reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 110, 0, L"\x25\x6c\x73", L"\x22\x72\x65\x69\x6e\x74\x65\x72\x70\x72\x65\x74\x5f\x63\x61\x73\x74\x3c\x75\x69\x6e\x74\x70\x74\x72\x5f\x74\x20\x2a\x3e\x28\x5f" L"\x50\x74\x72\x5f\x70\x74\x72\x29\x5b\x2d\x31\x5d\x20\x3d\x3d\x20\x5f\x42\x49\x47\x5f\x41\x4c\x4c\x4f\x43\x41\x54\x49\x4f\x4e\x5f" L"\x53\x45\x4e\x54\x49\x4e\x45\x4c\x22\x20\x26\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x44\x65\x61\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 110, 0); }  ; } ; 
#line 114 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
{ if (!(_Ptr_container < _Ptr_user)) { (void)(((!(!(("_Ptr_container < _Ptr_user") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 114, 0, L"\x25\x6c\x73", L"\x22\x5f\x50\x74\x72\x5f\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x3c\x20\x5f\x50\x74\x72\x5f\x75\x73\x65\x72\x22\x20\x26\x26\x20" L"\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x44\x65\x61\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 114, 0); }  ; } ; 
#line 117
{ if (!(((2) * sizeof(void *)) <= (_Ptr_user - _Ptr_container))) { (void)(((!(!(("2 * sizeof(void *) <= _Ptr_user - _Ptr_container") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 118, 0, L"\x25\x6c\x73", L"\x22\x32\x20\x2a\x20\x73\x69\x7a\x65\x6f\x66\x28\x76\x6f\x69\x64\x20\x2a\x29\x20\x3c\x3d\x20\x5f\x50\x74\x72\x5f\x75\x73\x65\x72" L"\x20\x2d\x20\x5f\x50\x74\x72\x5f\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x22\x20\x26\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x44\x65\x61\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 118, 0); }  ; } ; 
#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
{ if (!((_Ptr_user - _Ptr_container) <= ((((2) * sizeof(void *)) + (32)) - (1)))) { (void)(((!(!(("_Ptr_user - _Ptr_container <= _NON_USER_SIZE") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 126, 0, L"\x25\x6c\x73", L"\x22\x5f\x50\x74\x72\x5f\x75\x73\x65\x72\x20\x2d\x20\x5f\x50\x74\x72\x5f\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x20\x3c\x3d\x20\x5f" L"\x4e\x4f\x4e\x5f\x55\x53\x45\x52\x5f\x53\x49\x5a\x45\x22\x20\x26\x26\x20\x30"))) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x44\x65\x61\x6c\x6c\x6f\x63\x61\x74\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 126, 0); }  ; } ; 
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
_Ptr = (reinterpret_cast< void *>(_Ptr_container)); 
#line 129
}  
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
::operator delete(_Ptr); 
#line 133
} 
#line 136
template < class _Ty1,
 class _Ty2 > inline
 void _Construct ( _Ty1 * _Ptr, _Ty2 && _Val )
 {
 void * _Vptr = _Ptr;
 :: new ( _Vptr ) _Ty1 ( :: std :: forward < _Ty2 > ( _Val ) );
 }
#line 144
template < class _Ty1 > inline
 void _Construct ( _Ty1 * _Ptr )
 {
 void * _Vptr = _Ptr;

 :: new ( _Vptr ) _Ty1 ( );
 }
#line 153
template< class _Alty> 
#line 154
struct _Is_simple_alloc : public _Cat_base< ((((is_same< typename _Alty::size_type, unsigned __int64> ::value && is_same< typename _Alty::difference_type, __int64> ::value) && is_same< typename _Alty::pointer, typename _Alty::value_type *> ::value) && is_same< typename _Alty::const_pointer, const typename _Alty::value_type *> ::value) && is_same< typename _Alty::reference, typename _Alty::value_type &> ::value) && is_same< typename _Alty::const_reference, const typename _Alty::value_type &> ::value>  { 
#line 166
}; 
#line 169
template< class _Value_type> 
#line 170
struct _Simple_types { 
#line 172
typedef _Value_type value_type; 
#line 173
typedef size_t size_type; 
#line 174
typedef ptrdiff_t difference_type; 
#line 175
typedef value_type *pointer; 
#line 176
typedef const value_type *const_pointer; 
#line 177
typedef value_type &reference; 
#line 178
typedef const value_type &const_reference; 
#line 179
}; 
#line 182
template< class _Alty, class 
#line 183
_Pointer> 
#line 184
struct _Get_voidptr { 
#line 186
typedef typename _Alty::template rebind< void> ::other _Alvoid; 
#line 187
typedef typename _Alvoid::pointer type; 
#line 188
}; 
#line 190
template< class _Alty, class 
#line 191
_Ty> 
#line 192
struct _Get_voidptr< _Alty, _Ty *>  { 
#line 194
typedef void *type; 
#line 195
}; 
#line 198
template< class _Ty> struct _Get_first_parameter; 
#line 201
template< template< class , class ...>  class _Ty, class 
#line 202
_First, class ...
#line 203
_Rest> 
#line 204
struct _Get_first_parameter< _Ty< _First, _Rest...> >  { 
#line 206
typedef _First type; 
#line 207
}; 
#line 210
template< class _Newfirst, class 
#line 211
_Ty> struct _Replace_first_parameter; 
#line 214
template< class _Newfirst, 
#line 215
template< class , class ...>  class _Ty, class 
#line 216
_First, class ...
#line 217
_Rest> 
#line 218
struct _Replace_first_parameter< _Newfirst, _Ty< _First, _Rest...> >  { 
#line 220
typedef _Ty< _Newfirst, _Rest...>  type; 
#line 221
}; 
#line 224
template< class _Ty> 
#line 225
struct _Get_element_type { 
#line 226
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::element_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Get_first_parameter< _Uty> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 231
struct _Get_ptr_difference_type { 
#line 232
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::difference_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< __int64> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty, class 
#line 237
_Other> 
#line 238
struct _Get_rebind_type { 
#line 239
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::template rebind< _Other> ::other> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Replace_first_parameter< _Other, _Uty> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template < class _Ty >
 struct pointer_traits
 {
 typedef typename _Get_element_type < _Ty > :: type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type < _Ty > :: type difference_type;

 template < class _Other >
  using rebind = typename _Get_rebind_type < _Ty, _Other > :: type;

 typedef typename _If < is_void < element_type > :: value,
  char &,
  typename add_lvalue_reference < element_type > :: type > :: type _Reftype;

 static pointer pointer_to ( _Reftype _Val )
  {
  return ( _Ty :: pointer_to ( _Val ) );
  }
 };
#line 264
template < class _Ty >
 struct pointer_traits < _Ty * >
 {
 typedef _Ty element_type;
 typedef _Ty * pointer;
 typedef ptrdiff_t difference_type;

 template < class _Other >
  using rebind = _Other *;

 typedef typename _If < is_void < _Ty > :: value,
  char &,
  typename add_lvalue_reference < _Ty > :: type > :: type _Reftype;

 static pointer pointer_to ( _Reftype _Val )
  {
  return ( :: std :: addressof ( _Val ) );
  }
 };
#line 286
template < class _Ptrty > inline
 void _Destroy ( _Ptrty _Ptr )
 {
 typedef typename pointer_traits < _Ptrty > :: element_type _Ty;
 _Ptr -> ~ _Ty ( );
 }
#line 294
template < class _Ptrty > inline
 auto _Const_cast ( _Ptrty _Ptr )
 {
 using _Elem = typename pointer_traits < _Ptrty > :: element_type;
 using _Modifiable = remove_const_t < _Elem >;
 using _Dest = typename pointer_traits < _Ptrty > :: template rebind < _Modifiable >;

 return ( pointer_traits < _Dest > :: pointer_to ( const_cast < _Modifiable & > ( * _Ptr ) ) );
 }
#line 304
template < class _Ty > inline
 auto _Const_cast ( _Ty * _Ptr )
 {
 return ( const_cast < remove_const_t < _Ty > * > ( _Ptr ) );
 }
#line 312
template< class _Ty> 
#line 313
struct _Get_pointer_type { 
#line 314
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Ty::value_type *> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 318 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 319
struct _Get_const_pointer_type { 
#line 320
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::const_pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< const typename _Ty::value_type> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 325 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 326
struct _Get_void_pointer_type { 
#line 327
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::void_pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< void> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 333
struct _Get_const_void_pointer_type { 
#line 334
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::const_void_pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< const void> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 339 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 340
struct _Get_difference_type { 
#line 341
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::difference_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Get_ptr_difference_type< typename _Get_pointer_type< _Ty> ::type> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 346 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 347
struct _Get_size_type { 
#line 348
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::size_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename make_unsigned< typename _Get_difference_type< _Ty> ::type> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 353 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 354
struct _Get_propagate_on_container_copy { 
#line 355
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::propagate_on_container_copy_assignment> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< integral_constant< bool, false> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 359 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 360
struct _Get_propagate_on_container_move { 
#line 361
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::propagate_on_container_move_assignment> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< integral_constant< bool, false> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 366
struct _Get_propagate_on_container_swap { 
#line 367
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::propagate_on_container_swap> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< integral_constant< bool, false> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 371 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> 
#line 372
struct _Get_is_always_equal { 
#line 373
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::is_always_equal> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename is_empty< _Ty> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 377 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template< class _Ty> class allocator; 
#line 379
template < class _Alloc >
 struct _Wrap_alloc;
#line 382
template< class _Alloc> 
#line 383
struct _Unwrap_alloc { 
#line 385
typedef _Alloc type; 
#line 386
}; 
#line 388
template< class _Alloc> 
#line 389
struct _Unwrap_alloc< _Wrap_alloc< _Alloc> >  { 
#line 391
typedef _Alloc type; 
#line 392
}; 
#line 396
template< class _Alloc> using _Unwrap_alloc_t = typename _Unwrap_alloc< _Alloc> ::type; 
#line 401
template< class _Alloc, class 
#line 402
 = void> 
#line 403
struct _Is_default_allocator : public false_type { 
#line 406
}; 
#line 408
template< class _Ty> 
#line 409
struct _Is_default_allocator< allocator< _Ty> , typename allocator< _Ty> ::_Not_user_specialized>  : public true_type { 
#line 412
}; 
#line 415
struct _Alloc_allocate { 
#line 419
template < class _Alloc,
  class _Size_type,
  class _Const_void_pointer >
  static auto _Fn ( int, _Alloc & _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint )
   -> decltype ( _Al . allocate ( _Count, _Hint ) )
  {
  return ( _Al . allocate ( _Count, _Hint ) );
  }
#line 430
template < class _Alloc,
  class _Size_type,
  class _Const_void_pointer >
  static auto _Fn ( _Wrap_int, _Alloc & _Al,
   _Size_type _Count,
   _Const_void_pointer )
   -> decltype ( _Al . allocate ( _Count ) )
  {
  return ( _Al . allocate ( _Count ) );
  }
#line 440
}; 
#line 443
struct _Has_no_alloc_construct_tag { 
#line 445
}; 
#line 447
template< class _Void, class ...
#line 448
_Types> 
#line 449
struct _Has_no_alloc_construct : public true_type { 
#line 452
}; 
#line 454
template< class _Alloc, class 
#line 455
_Ptr, class ...
#line 456
_Args> 
#line 457
struct _Has_no_alloc_construct< void_t< _Has_no_alloc_construct_tag, decltype(((std::declval< _Alloc &> ().construct(std::declval< _Ptr> (), std::declval< _Args> ()...))))> , _Alloc, _Ptr, _Args...>  : public false_type { 
#line 464
}; 
#line 466
template< class _Alloc, class 
#line 467
_Ptr, class ...
#line 468
_Args> using _Uses_default_construct = disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_construct< void, _Alloc, _Ptr, _Args...> > ; 
#line 473
template< class _Alloc, class 
#line 474
_Ptr, class ...
#line 475
_Args> using _Uses_default_construct_t = typename disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_construct< void, _Alloc, _Ptr, _Args...> > ::type; 
#line 480
struct _Has_no_alloc_destroy_tag { 
#line 482
}; 
#line 484
template< class _Alloc, class 
#line 485
_Ptr, class 
#line 486
 = void> 
#line 487
struct _Has_no_alloc_destroy : public true_type { 
#line 490
}; 
#line 492
template< class _Alloc, class 
#line 493
_Ptr> 
#line 494
struct _Has_no_alloc_destroy< _Alloc, _Ptr, void_t< _Has_no_alloc_destroy_tag, decltype(((std::declval< _Alloc &> ().destroy(std::declval< _Ptr> ()))))> >  : public false_type { 
#line 499
}; 
#line 501
template< class _Alloc, class 
#line 502
_Ptr> using _Uses_default_destroy = disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ; 
#line 507
template< class _Alloc, class 
#line 508
_Ptr> using _Uses_default_destroy_t = typename disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ::type; 
#line 513
struct _Alloc_max_size { 
#line 515
template < class _Ty >
  static auto _Fn ( int, const _Ty & _Al ) noexcept
   -> decltype ( _Al . max_size ( ) )
  {
  return ( _Al . max_size ( ) );
  }
#line 522
template < class _Ty >
  static auto _Fn ( _Wrap_int, const _Ty & ) noexcept
   -> typename _Get_size_type < _Ty > :: type
  {
  return ( ( numeric_limits < typename _Get_size_type < _Ty > :: type > :: max ) ( )
   / sizeof ( typename _Ty :: value_type ) );
  }
#line 529
}; 
#line 532
struct _Alloc_select { 
#line 536
template < class _Ty >
  static auto _Fn ( int, const _Ty & _Al )
   -> decltype ( ( _Ty ) _Al . select_on_container_copy_construction ( ) )
  {
  return ( _Al . select_on_container_copy_construction ( ) );
  }
#line 543
template < class _Ty >
  static auto _Fn ( _Wrap_int, const _Ty & _Al )
   -> _Ty
  {
  return ( _Al );
  }
#line 549
}; 
#line 552
template < class _Alloc >
 struct allocator_traits
 {
 typedef _Alloc allocator_type;
 typedef typename _Alloc :: value_type value_type;

 typedef typename _Get_pointer_type < _Alloc > :: type
  pointer;
 typedef typename _Get_const_pointer_type < _Alloc > :: type
  const_pointer;
 typedef typename _Get_void_pointer_type < _Alloc > :: type
  void_pointer;
 typedef typename _Get_const_void_pointer_type < _Alloc > :: type
  const_void_pointer;

 typedef typename _Get_size_type < _Alloc > :: type size_type;
 typedef typename _Get_difference_type < _Alloc > :: type difference_type;

 typedef typename _Get_propagate_on_container_copy < _Alloc > :: type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move < _Alloc > :: type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap < _Alloc > :: type
  propagate_on_container_swap;
 typedef typename _Get_is_always_equal < _Alloc > :: type
  is_always_equal;

 template < class _Other >
  using rebind_alloc = typename _Get_rebind_type < _Alloc, _Other > :: type;

 template < class _Other >
  using rebind_traits = allocator_traits < rebind_alloc < _Other > >;

 static __declspec ( allocator ) pointer allocate ( _Alloc & _Al, size_type _Count )
  {
  return ( _Al . allocate ( _Count ) );
  }

 static __declspec ( allocator ) pointer allocate ( _Alloc & _Al, size_type _Count,
  const_void_pointer _Hint )
  {
  return ( _Alloc_allocate :: _Fn ( 0, _Al, _Count, _Hint ) );
  }

 static void deallocate ( _Alloc & _Al,
  pointer _Ptr, size_type _Count )
  {
  _Al . deallocate ( _Ptr, _Count );
  }

 template < class _Ty,
  class ... _Types >
  static void _Construct1 ( true_type, _Alloc &, _Ty * _Ptr,
   _Types && ... _Args )
  {
  :: new ( static_cast < void * > ( _Ptr ) )
   _Ty ( :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Ty,
  class ... _Types >
  static void _Construct1 ( false_type, _Alloc & _Al, _Ty * _Ptr,
   _Types && ... _Args )
  {
  _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Ty,
  class ... _Types >
  static void construct ( _Alloc & _Al, _Ty * _Ptr,
   _Types && ... _Args )
  {
  _Construct1 ( _Uses_default_construct_t < _Unwrap_alloc_t < _Alloc >, _Ty *, _Types ... > ( ),
   _Al, _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Ty >
  static void _Destroy1 ( _Alloc &, _Ty * _Ptr, true_type )
  {
  _Ptr -> ~ _Ty ( );
  }

 template < class _Ty >
  static void _Destroy1 ( _Alloc & _Al, _Ty * _Ptr, false_type )
  {
  _Al . destroy ( _Ptr );
  }

 template < class _Ty >
  static void destroy ( _Alloc & _Al, _Ty * _Ptr )
  {
  _Destroy1 ( _Al, _Ptr, _Uses_default_destroy_t < _Unwrap_alloc_t < _Alloc >, _Ty * > ( ) );
  }

 static size_type max_size ( const _Alloc & _Al ) noexcept
  {
  return ( _Alloc_max_size :: _Fn ( 0, _Al ) );
  }

 static _Alloc select_on_container_copy_construction (
  const _Alloc & _Al )
  {
  return ( _Alloc_select :: _Fn ( 0, _Al ) );
  }
 };
#line 659
template < class _Ty >
 class allocator
 {
public :
 static_assert ( ! is_const < _Ty > :: value,
  "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed."
                                             );

 typedef void _Not_user_specialized;

 typedef _Ty value_type;

 typedef value_type * pointer;
 typedef const value_type * const_pointer;

 typedef value_type & reference;
 typedef const value_type & const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef true_type propagate_on_container_move_assignment;
 typedef true_type is_always_equal;

 template < class _Other >
  struct rebind
  {
  typedef allocator < _Other > other;
  };

 pointer address ( reference _Val ) const noexcept
  {
  return ( :: std :: addressof ( _Val ) );
  }

 const_pointer address ( const_reference _Val ) const noexcept
  {
  return ( :: std :: addressof ( _Val ) );
  }

 allocator ( ) noexcept
  {
  }

 allocator ( const allocator < _Ty > & ) noexcept
  {
  }

 template < class _Other >
  allocator ( const allocator < _Other > & ) noexcept
  {
  }

 template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }

 void deallocate ( pointer _Ptr, size_type _Count )
  {
  _Deallocate ( _Ptr, _Count, sizeof ( _Ty ) );
  }

 __declspec ( allocator ) pointer allocate ( size_type _Count )
  {
  return ( static_cast < pointer > ( _Allocate ( _Count, sizeof ( _Ty ) ) ) );
  }

 __declspec ( allocator ) pointer allocate ( size_type _Count, const void * )
  {
  return ( allocate ( _Count ) );
  }

 template < class _Objty,
  class ... _Types >
  void construct ( _Objty * _Ptr, _Types && ... _Args )
  {
  :: new ( ( void * ) _Ptr ) _Objty ( :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Uty >
  void destroy ( _Uty * _Ptr )
  {
  _Ptr -> ~ _Uty ( );
  }

 size_t max_size ( ) const noexcept
  {
  return ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) );
  }
 };
#line 755
#pragma pack(8)
template<> 
#line 755
class allocator< void>  { 
#line 758
public: typedef void _Not_user_specialized; 
#line 760
typedef void value_type; 
#line 762
typedef void *pointer; 
#line 763
typedef const void *const_pointer; 
#line 765
template< class _Other> 
#line 766
struct rebind { 
#line 768
typedef std::allocator< _Other>  other; 
#line 769
}; 
#line 771
allocator() noexcept 
#line 772
{ 
#line 773
} 
#line 775
allocator(const std::allocator< void>  &) noexcept 
#line 776
{ 
#line 777
} 
#line 779
template < class _Other >
  allocator ( const allocator < _Other > & ) noexcept
  {
  }
#line 784
template < class _Other >
  allocator < void > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }
#line 789
}; 
#pragma pack(8)
template < class _Ty,
 class _Other > inline
 bool operator == ( const allocator < _Ty > &,
  const allocator < _Other > & ) noexcept
 {
 return ( true );
 }
#line 799
template < class _Ty,
 class _Other > inline
 bool operator != ( const allocator < _Ty > & _Left,
  const allocator < _Other > & _Right ) noexcept
 {
 return ( false );
 }
#line 808
template < class _Ty >
 struct allocator_traits < allocator < _Ty > >
 {
 typedef allocator < _Ty > _Alloc;

 typedef _Alloc allocator_type;
 typedef _Ty value_type;

 typedef value_type * pointer;
 typedef const value_type * const_pointer;
 typedef void * void_pointer;
 typedef const void * const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef true_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;
 typedef true_type is_always_equal;

 template < class _Other >
  using rebind_alloc = allocator < _Other >;

 template < class _Other >
  using rebind_traits = allocator_traits < allocator < _Other > >;

 static __declspec ( allocator ) pointer allocate ( _Alloc & _Al, size_type _Count )
  {
  return ( _Al . allocate ( _Count ) );
  }

 static __declspec ( allocator ) pointer allocate ( _Alloc & _Al, size_type _Count,
  const_void_pointer _Hint )
  {
  return ( _Al . allocate ( _Count, _Hint ) );
  }

 static void deallocate ( _Alloc & _Al,
  pointer _Ptr, size_type _Count )
  {
  _Al . deallocate ( _Ptr, _Count );
  }

 template < class _Objty,
  class ... _Types >
  static void construct ( _Alloc & _Al, _Objty * _Ptr,
   _Types && ... _Args )
  {
  _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Uty >
  static void destroy ( _Alloc & _Al, _Uty * _Ptr )
  {
  _Al . destroy ( _Ptr );
  }

 static size_type max_size ( const _Alloc & _Al ) noexcept
  {
  return ( _Al . max_size ( ) );
  }

 static _Alloc select_on_container_copy_construction (
  const _Alloc & _Al )
  {
  return ( _Al );
  }
 };
#line 880
template < class _Alloc >
 struct _Wrap_alloc
  : public _Alloc
 {
 typedef _Alloc _Mybase;
 typedef allocator_traits < _Alloc > _Mytraits;

 typedef typename _Mytraits :: value_type value_type;

 typedef typename _Mytraits :: pointer pointer;
 typedef typename _Mytraits :: const_pointer const_pointer;
 typedef typename _Mytraits :: void_pointer void_pointer;
 typedef typename _Mytraits :: const_void_pointer const_void_pointer;

 typedef typename _If < is_void < value_type > :: value,
  int, value_type > :: type & reference;
 typedef typename _If < is_void < const value_type > :: value,
  const int, const value_type > :: type & const_reference;

 typedef typename _Mytraits :: size_type size_type;
 typedef typename _Mytraits :: difference_type difference_type;

 typedef typename _Mytraits :: propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits :: propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits :: propagate_on_container_swap
  propagate_on_container_swap;
 typedef typename _Mytraits :: is_always_equal
  is_always_equal;

 _Wrap_alloc select_on_container_copy_construction ( _Nil = _Nil ( ) ) const
  {
  return ( _Mytraits :: select_on_container_copy_construction ( * this ) );
  }

 template < class _Other >
  struct rebind
  {
  typedef typename _Mytraits :: template rebind_alloc < _Other >
   _Other_alloc;
  typedef _Wrap_alloc < _Other_alloc > other;
  };

 pointer address ( reference _Val ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( _Val ) );
  }

 const_pointer address ( const_reference _Val ) const
  {
  return ( pointer_traits < const_pointer > :: pointer_to ( _Val ) );
  }

 _Wrap_alloc ( ) noexcept ( is_nothrow_default_constructible < _Alloc > :: value )
  : _Mybase ( )
  {
  }

 _Wrap_alloc ( const _Wrap_alloc & _Right ) noexcept
  : _Mybase ( _Right )
  {
  }

 _Wrap_alloc ( _Wrap_alloc && _Right ) noexcept
  : _Mybase ( :: std :: move ( _Right ) )
  {
  }

 template < class _Other >
  _Wrap_alloc ( _Other && _Right ) noexcept
  : _Mybase ( :: std :: forward < _Other > ( _Right ) )
  {
  }

 _Wrap_alloc & operator = ( const _Wrap_alloc & _Right )
  {
  _Mybase :: operator = ( _Right );
  return ( * this );
  }

 _Wrap_alloc & operator = ( _Wrap_alloc && _Right )
  {
  _Mybase :: operator = ( :: std :: move ( _Right ) );
  return ( * this );
  }

 template < class _Other >
  _Wrap_alloc & operator = ( _Other && _Right )
  {
  _Mybase :: operator = ( :: std :: forward < _Other > ( _Right ) );
  return ( * this );
  }

 __declspec ( allocator ) pointer allocate ( size_type _Count )
  {
  return ( _Mybase :: allocate ( _Count ) );
  }

 __declspec ( allocator ) pointer allocate ( size_type _Count,
  const_void_pointer _Hint, _Nil = _Nil ( ) )
  {
  return ( _Mytraits :: allocate ( * this, _Count, _Hint ) );
  }

 void deallocate ( pointer _Ptr, size_type _Count )
  {
  _Mybase :: deallocate ( _Ptr, _Count );
  }

 template < class _Ty,
  class ... _Types >
  void construct ( _Ty * _Ptr,
   _Types && ... _Args )
  {
  _Mytraits :: construct ( * this, _Ptr,
   :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Ty >
  void destroy ( _Ty * _Ptr )
  {
  _Mytraits :: destroy ( * this, _Ptr );
  }

 size_type max_size ( _Nil = _Nil ( ) ) const noexcept
  {
  return ( _Mytraits :: max_size ( * this ) );
  }
 };
#line 1012
template < class _Ty,
 class _Other > inline
 bool operator == ( const _Wrap_alloc < _Ty > & _Left,
  const _Wrap_alloc < _Other > & _Right ) noexcept
 {
 return ( static_cast < const _Ty & > ( _Left )
  == static_cast < const _Other & > ( _Right ) );
 }
#line 1021
template < class _Ty,
 class _Other > inline
 bool operator != ( const _Wrap_alloc < _Ty > & _Left,
  const _Wrap_alloc < _Other > & _Right ) noexcept
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1030
template < class _Alty > inline
 void _Pocca ( _Alty & _Left, const _Alty & _Right, true_type ) noexcept
 {
 _Left = _Right;
 }
#line 1036
template < class _Alty > inline
 void _Pocca ( _Alty &, const _Alty &, false_type ) noexcept
 {
 }
#line 1041
template < class _Alty > inline
 void _Pocca ( _Alty & _Left, const _Alty & _Right ) noexcept
 {
 typename _Alty :: propagate_on_container_copy_assignment _Tag;
 _Pocca ( _Left, _Right, _Tag );
 }
#line 1049
template < class _Alty > inline
 void _Pocma ( _Alty & _Left, _Alty & _Right, true_type ) noexcept
 {
 _Left = :: std :: move ( _Right );
 }
#line 1055
template < class _Alty > inline
 void _Pocma ( _Alty &, _Alty &, false_type ) noexcept
 {
 }
#line 1060
template < class _Alty > inline
 void _Pocma ( _Alty & _Left, _Alty & _Right ) noexcept
 {
 typename _Alty :: propagate_on_container_move_assignment _Tag;
 _Pocma ( _Left, _Right, _Tag );
 }
#line 1068
template < class _Alty > inline
 void _Pocs ( _Alty & _Left, _Alty & _Right, true_type ) noexcept
 {
 _Swap_adl ( _Left, _Right );
 }
#line 1074
template < class _Alty > inline
 void _Pocs ( _Alty & _Left, _Alty & _Right, false_type ) noexcept
 {
 if ( _Left != _Right )
  {

  _Debug_message ( L"\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x20\x66\x6f\x72\x20\x73\x77\x61\x70" L"", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79\x30", 1080 );



  }
 }
#line 1087 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
template < class _Alty > inline
 void _Pocs ( _Alty & _Left, _Alty & _Right ) noexcept
 {
 typename _Alty :: propagate_on_container_swap _Tag;
 _Pocs ( _Left, _Right, _Tag );
 }
#line 1096
template < class _Alloc,
 class _Ptr = typename _Wrap_alloc < _Alloc > :: pointer > inline
 void _Destroy_range1 ( _Ptr _First, _Ptr _Last, _Wrap_alloc < _Alloc > & _Al, false_type )
 {
 for (; _First != _Last; ++ _First )
  _Al . destroy ( _Unfancy ( _First ) );
 }
#line 1104
template < class _Alloc,
 class _Ptr = typename _Wrap_alloc < _Alloc > :: pointer > inline
 void _Destroy_range1 ( _Ptr, _Ptr, _Wrap_alloc < _Alloc > &, true_type )
 {

 }
#line 1111
template < class _Alloc,
 class _Ptr = typename _Wrap_alloc < _Alloc > :: pointer > inline
 void _Destroy_range ( _Ptr _First, _Ptr _Last, _Wrap_alloc < _Alloc > & _Al )
 {


 typedef typename _Alloc :: value_type _Val;
 _Destroy_range1 ( _First, _Last, _Al, typename conjunction <
  is_trivially_destructible < _Val >,
  _Uses_default_destroy < _Alloc, _Val * >> :: type ( ) );
 }
#line 1125
template < class _FwdIt > inline
 void _Destroy_range1 ( _FwdIt _First, _FwdIt _Last, false_type )
 {
 for (; _First != _Last; ++ _First )
  _Destroy ( _First );
 }
#line 1132
template < class _FwdIt > inline
 void _Destroy_range1 ( _FwdIt, _FwdIt, true_type )
 {

 }
#line 1138
template < class _FwdIt > inline
 void _Destroy_range ( _FwdIt _First, _FwdIt _Last )
 {


 _Destroy_range1 ( _First, _Last, is_trivially_destructible < _Iter_value_t < _FwdIt >> ( ) );
 }
#line 1145
}
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xatomic0.h"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 22
typedef 
#line 15
enum memory_order { 
#line 16
memory_order_relaxed, 
#line 17
memory_order_consume, 
#line 18
memory_order_acquire, 
#line 19
memory_order_release, 
#line 20
memory_order_acq_rel, 
#line 21
memory_order_seq_cst
#line 22
} memory_order; 
#line 24
typedef _Uint32t _Uint4_t; 
#line 25
typedef _Uint4_t _Atomic_integral_t; 
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xatomic0.h"
typedef long _Atomic_flag_t; 
#line 52
typedef _Atomic_integral_t _Atomic_counter_t; 
#line 55
inline _Atomic_integral_t _Get_atomic_count(const _Atomic_counter_t &_Counter) 
#line 56
{ 
#line 57
return _Counter; 
#line 58
} 
#line 60
inline void _Init_atomic_counter(_Atomic_counter_t &_Counter, _Atomic_integral_t 
#line 61
_Value) 
#line 62
{ 
#line 63
_Counter = _Value; 
#line 64
} 
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xatomic0.h"
extern "C" {
#line 76
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock(); 
#line 77
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock(); 
#line 78
}
#line 79
}
#line 81
#pragma warning(pop)
#pragma pack ( pop )
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
typedef 
#line 48
struct __declspec(align(16)) _SETJMP_FLOAT128 { 
#line 50
unsigned __int64 Part[2]; 
#line 51
} SETJMP_FLOAT128; 
#line 54
typedef SETJMP_FLOAT128 _JBTYPE; 
#line 83
typedef 
#line 56
struct _JUMP_BUFFER { 
#line 58
unsigned __int64 Frame; 
#line 59
unsigned __int64 Rbx; 
#line 60
unsigned __int64 Rsp; 
#line 61
unsigned __int64 Rbp; 
#line 62
unsigned __int64 Rsi; 
#line 63
unsigned __int64 Rdi; 
#line 64
unsigned __int64 R12; 
#line 65
unsigned __int64 R13; 
#line 66
unsigned __int64 R14; 
#line 67
unsigned __int64 R15; 
#line 68
unsigned __int64 Rip; 
#line 69
unsigned long MxCsr; 
#line 70
unsigned short FpCsr; 
#line 71
unsigned short Spare; 
#line 73
SETJMP_FLOAT128 Xmm6; 
#line 74
SETJMP_FLOAT128 Xmm7; 
#line 75
SETJMP_FLOAT128 Xmm8; 
#line 76
SETJMP_FLOAT128 Xmm9; 
#line 77
SETJMP_FLOAT128 Xmm10; 
#line 78
SETJMP_FLOAT128 Xmm11; 
#line 79
SETJMP_FLOAT128 Xmm12; 
#line 80
SETJMP_FLOAT128 Xmm13; 
#line 81
SETJMP_FLOAT128 Xmm14; 
#line 82
SETJMP_FLOAT128 Xmm15; 
#line 83
} _JUMP_BUFFER; 
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
typedef _JBTYPE jmp_buf[16]; 
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
int __cdecl _setjmp(jmp_buf _Buf); 
#line 162
#pragma warning(push)
#pragma warning(disable:4987)
__declspec(noreturn) void __cdecl longjmp(jmp_buf _Buf, int _Value) throw(...); 
#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
}
#line 168 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
#pragma warning(pop)
#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\setjmp.h"
__pragma( pack ( pop )) 
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mmintrin.h"
extern "C" {
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mmintrin.h"
typedef 
#line 34
union __declspec(intrin_type) __declspec(align(8)) __m64 { 
#line 36
unsigned __int64 m64_u64; 
#line 37
float m64_f32[2]; 
#line 38
char m64_i8[8]; 
#line 39
short m64_i16[4]; 
#line 40
int m64_i32[2]; 
#line 41
__int64 m64_i64; 
#line 42
unsigned char m64_u8[8]; 
#line 43
unsigned short m64_u16[4]; 
#line 44
unsigned m64_u32[2]; 
#line 45
} __m64; 
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\mmintrin.h"
}
#line 75 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
typedef 
#line 65
union __declspec(intrin_type) __declspec(align(16)) __m128 { 
#line 66
float m128_f32[4]; 
#line 67
unsigned __int64 m128_u64[2]; 
#line 68
char m128_i8[16]; 
#line 69
short m128_i16[8]; 
#line 70
int m128_i32[4]; 
#line 71
__int64 m128_i64[2]; 
#line 72
unsigned char m128_u8[16]; 
#line 73
unsigned short m128_u16[8]; 
#line 74
unsigned m128_u32[4]; 
#line 75
} __m128; 
#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
extern "C" {
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
extern __m128 _mm_add_ss(__m128 _A, __m128 _B); 
#line 197
extern __m128 _mm_add_ps(__m128 _A, __m128 _B); 
#line 198
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B); 
#line 199
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B); 
#line 200
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B); 
#line 201
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B); 
#line 202
extern __m128 _mm_div_ss(__m128 _A, __m128 _B); 
#line 203
extern __m128 _mm_div_ps(__m128 _A, __m128 _B); 
#line 204
extern __m128 _mm_sqrt_ss(__m128 _A); 
#line 205
extern __m128 _mm_sqrt_ps(__m128 _A); 
#line 206
extern __m128 _mm_rcp_ss(__m128 _A); 
#line 207
extern __m128 _mm_rcp_ps(__m128 _A); 
#line 208
extern __m128 _mm_rsqrt_ss(__m128 _A); 
#line 209
extern __m128 _mm_rsqrt_ps(__m128 _A); 
#line 210
extern __m128 _mm_min_ss(__m128 _A, __m128 _B); 
#line 211
extern __m128 _mm_min_ps(__m128 _A, __m128 _B); 
#line 212
extern __m128 _mm_max_ss(__m128 _A, __m128 _B); 
#line 213
extern __m128 _mm_max_ps(__m128 _A, __m128 _B); 
#line 219
extern __m128 _mm_and_ps(__m128 _A, __m128 _B); 
#line 220
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B); 
#line 221
extern __m128 _mm_or_ps(__m128 _A, __m128 _B); 
#line 222
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B); 
#line 228
extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B); 
#line 229
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B); 
#line 230
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B); 
#line 231
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B); 
#line 232
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B); 
#line 233
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B); 
#line 234
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B); 
#line 235
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B); 
#line 236
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B); 
#line 237
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B); 
#line 238
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B); 
#line 239
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B); 
#line 240
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B); 
#line 241
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B); 
#line 242
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B); 
#line 243
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B); 
#line 244
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B); 
#line 245
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B); 
#line 246
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B); 
#line 247
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B); 
#line 248
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B); 
#line 249
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B); 
#line 250
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B); 
#line 251
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B); 
#line 252
extern int _mm_comieq_ss(__m128 _A, __m128 _B); 
#line 253
extern int _mm_comilt_ss(__m128 _A, __m128 _B); 
#line 254
extern int _mm_comile_ss(__m128 _A, __m128 _B); 
#line 255
extern int _mm_comigt_ss(__m128 _A, __m128 _B); 
#line 256
extern int _mm_comige_ss(__m128 _A, __m128 _B); 
#line 257
extern int _mm_comineq_ss(__m128 _A, __m128 _B); 
#line 258
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B); 
#line 259
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B); 
#line 260
extern int _mm_ucomile_ss(__m128 _A, __m128 _B); 
#line 261
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B); 
#line 262
extern int _mm_ucomige_ss(__m128 _A, __m128 _B); 
#line 263
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B); 
#line 269
extern int _mm_cvt_ss2si(__m128 _A); 
#line 270
extern int _mm_cvtt_ss2si(__m128 _A); 
#line 271
extern __m128 _mm_cvt_si2ss(__m128, int); 
#line 272
extern float _mm_cvtss_f32(__m128 _A); 
#line 287 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
extern __int64 _mm_cvtss_si64(__m128 _A); 
#line 288
extern __int64 _mm_cvttss_si64(__m128 _A); 
#line 289
extern __m128 _mm_cvtsi64_ss(__m128 _A, __int64 _B); 
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned _Imm8); 
#line 297
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B); 
#line 298
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B); 
#line 299
extern __m128 _mm_loadh_pi(__m128, const __m64 *); 
#line 300
extern __m128 _mm_movehl_ps(__m128, __m128); 
#line 301
extern __m128 _mm_movelh_ps(__m128, __m128); 
#line 302
extern void _mm_storeh_pi(__m64 *, __m128); 
#line 303
extern __m128 _mm_loadl_pi(__m128, const __m64 *); 
#line 304
extern void _mm_storel_pi(__m64 *, __m128); 
#line 305
extern int _mm_movemask_ps(__m128 _A); 
#line 331 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
extern __m128 _mm_set_ss(float _A); 
#line 332
extern __m128 _mm_set_ps1(float _A); 
#line 333
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D); 
#line 334
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D); 
#line 335
extern __m128 _mm_setzero_ps(); 
#line 336
extern __m128 _mm_load_ss(const float * _A); 
#line 337
extern __m128 _mm_load_ps1(const float * _A); 
#line 338
extern __m128 _mm_load_ps(const float * _A); 
#line 339
extern __m128 _mm_loadr_ps(const float * _A); 
#line 340
extern __m128 _mm_loadu_ps(const float * _A); 
#line 341
extern void _mm_store_ss(float * _V, __m128 _A); 
#line 342
extern void _mm_store_ps1(float * _V, __m128 _A); 
#line 343
extern void _mm_store_ps(float * _V, __m128 _A); 
#line 344
extern void _mm_storer_ps(float * _V, __m128 _A); 
#line 345
extern void _mm_storeu_ps(float * _V, __m128 _A); 
#line 346
extern void _mm_prefetch(const char * _A, int _Sel); 
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128); 
#line 351
extern __m128 _mm_move_ss(__m128 _A, __m128 _B); 
#line 353
extern void _mm_sfence(); 
#line 354
extern unsigned _mm_getcsr(); 
#line 355
extern void _mm_setcsr(unsigned); 
#line 509 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmmintrin.h"
}
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
typedef 
#line 44
union __declspec(intrin_type) __declspec(align(16)) __m128i { 
#line 45
char m128i_i8[16]; 
#line 46
short m128i_i16[8]; 
#line 47
int m128i_i32[4]; 
#line 48
__int64 m128i_i64[2]; 
#line 49
unsigned char m128i_u8[16]; 
#line 50
unsigned short m128i_u16[8]; 
#line 51
unsigned m128i_u32[4]; 
#line 52
unsigned __int64 m128i_u64[2]; 
#line 53
} __m128i; 
#line 57
typedef 
#line 55
struct __declspec(intrin_type) __declspec(align(16)) __m128d { 
#line 56
double m128d_f64[2]; 
#line 57
} __m128d; 
#line 69
extern "C" {
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128d _mm_add_sd(__m128d _A, __m128d _B); 
#line 78
extern __m128d _mm_add_pd(__m128d _A, __m128d _B); 
#line 79
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B); 
#line 80
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B); 
#line 81
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B); 
#line 82
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B); 
#line 83
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B); 
#line 84
extern __m128d _mm_sqrt_pd(__m128d _A); 
#line 85
extern __m128d _mm_div_sd(__m128d _A, __m128d _B); 
#line 86
extern __m128d _mm_div_pd(__m128d _A, __m128d _B); 
#line 87
extern __m128d _mm_min_sd(__m128d _A, __m128d _B); 
#line 88
extern __m128d _mm_min_pd(__m128d _A, __m128d _B); 
#line 89
extern __m128d _mm_max_sd(__m128d _A, __m128d _B); 
#line 90
extern __m128d _mm_max_pd(__m128d _A, __m128d _B); 
#line 96
extern __m128d _mm_and_pd(__m128d _A, __m128d _B); 
#line 97
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B); 
#line 98
extern __m128d _mm_or_pd(__m128d _A, __m128d _B); 
#line 99
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B); 
#line 105
extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B); 
#line 106
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B); 
#line 107
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B); 
#line 108
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B); 
#line 109
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B); 
#line 110
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B); 
#line 111
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B); 
#line 112
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B); 
#line 113
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B); 
#line 114
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B); 
#line 115
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B); 
#line 116
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B); 
#line 117
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B); 
#line 118
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B); 
#line 119
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B); 
#line 120
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B); 
#line 121
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B); 
#line 122
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B); 
#line 123
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B); 
#line 124
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B); 
#line 125
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B); 
#line 126
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B); 
#line 127
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B); 
#line 128
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B); 
#line 129
extern int _mm_comieq_sd(__m128d _A, __m128d _B); 
#line 130
extern int _mm_comilt_sd(__m128d _A, __m128d _B); 
#line 131
extern int _mm_comile_sd(__m128d _A, __m128d _B); 
#line 132
extern int _mm_comigt_sd(__m128d _A, __m128d _B); 
#line 133
extern int _mm_comige_sd(__m128d _A, __m128d _B); 
#line 134
extern int _mm_comineq_sd(__m128d _A, __m128d _B); 
#line 135
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B); 
#line 136
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B); 
#line 137
extern int _mm_ucomile_sd(__m128d _A, __m128d _B); 
#line 138
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B); 
#line 139
extern int _mm_ucomige_sd(__m128d _A, __m128d _B); 
#line 140
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B); 
#line 146
extern __m128d _mm_cvtepi32_pd(__m128i _A); 
#line 147
extern __m128i _mm_cvtpd_epi32(__m128d _A); 
#line 148
extern __m128i _mm_cvttpd_epi32(__m128d _A); 
#line 149
extern __m128 _mm_cvtepi32_ps(__m128i _A); 
#line 150
extern __m128i _mm_cvtps_epi32(__m128 _A); 
#line 151
extern __m128i _mm_cvttps_epi32(__m128 _A); 
#line 152
extern __m128 _mm_cvtpd_ps(__m128d _A); 
#line 153
extern __m128d _mm_cvtps_pd(__m128 _A); 
#line 154
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B); 
#line 155
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B); 
#line 157
extern int _mm_cvtsd_si32(__m128d _A); 
#line 158
extern int _mm_cvttsd_si32(__m128d _A); 
#line 159
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B); 
#line 171 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B); 
#line 172
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B); 
#line 173
extern int _mm_movemask_pd(__m128d _A); 
#line 174
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I); 
#line 180
extern __m128d _mm_load_pd(const double * _Dp); 
#line 181
extern __m128d _mm_load1_pd(const double * _Dp); 
#line 182
extern __m128d _mm_loadr_pd(const double * _Dp); 
#line 183
extern __m128d _mm_loadu_pd(const double * _Dp); 
#line 184
extern __m128d _mm_load_sd(const double * _Dp); 
#line 185
extern __m128d _mm_loadh_pd(__m128d _A, const double * _Dp); 
#line 186
extern __m128d _mm_loadl_pd(__m128d _A, const double * _Dp); 
#line 192
extern __m128d _mm_set_sd(double _W); 
#line 193
extern __m128d _mm_set1_pd(double _A); 
#line 194
extern __m128d _mm_set_pd(double _Z, double _Y); 
#line 195
extern __m128d _mm_setr_pd(double _Y, double _Z); 
#line 196
extern __m128d _mm_setzero_pd(); 
#line 197
extern __m128d _mm_move_sd(__m128d _A, __m128d _B); 
#line 203
extern void _mm_store_sd(double * _Dp, __m128d _A); 
#line 204
extern void _mm_store1_pd(double * _Dp, __m128d _A); 
#line 205
extern void _mm_store_pd(double * _Dp, __m128d _A); 
#line 206
extern void _mm_storeu_pd(double * _Dp, __m128d _A); 
#line 207
extern void _mm_storer_pd(double * _Dp, __m128d _A); 
#line 208
extern void _mm_storeh_pd(double * _Dp, __m128d _A); 
#line 209
extern void _mm_storel_pd(double * _Dp, __m128d _A); 
#line 215
extern __m128i _mm_add_epi8(__m128i _A, __m128i _B); 
#line 216
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B); 
#line 217
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B); 
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B); 
#line 222
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B); 
#line 223
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B); 
#line 224
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B); 
#line 225
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B); 
#line 226
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B); 
#line 227
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B); 
#line 228
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B); 
#line 229
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B); 
#line 230
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B); 
#line 231
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B); 
#line 232
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B); 
#line 233
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B); 
#line 234
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B); 
#line 235
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B); 
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B); 
#line 240
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B); 
#line 241
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B); 
#line 242
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B); 
#line 243
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B); 
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B); 
#line 248
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B); 
#line 249
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B); 
#line 250
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B); 
#line 251
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B); 
#line 257
extern __m128i _mm_and_si128(__m128i _A, __m128i _B); 
#line 258
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B); 
#line 259
extern __m128i _mm_or_si128(__m128i _A, __m128i _B); 
#line 260
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B); 
#line 266
extern __m128i _mm_slli_si128(__m128i _A, int _Imm); 
#line 267
extern __m128i _mm_slli_epi16(__m128i _A, int _Count); 
#line 268
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count); 
#line 269
extern __m128i _mm_slli_epi32(__m128i _A, int _Count); 
#line 270
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count); 
#line 271
extern __m128i _mm_slli_epi64(__m128i _A, int _Count); 
#line 272
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count); 
#line 273
extern __m128i _mm_srai_epi16(__m128i _A, int _Count); 
#line 274
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count); 
#line 275
extern __m128i _mm_srai_epi32(__m128i _A, int _Count); 
#line 276
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count); 
#line 277
extern __m128i _mm_srli_si128(__m128i _A, int _Imm); 
#line 278
extern __m128i _mm_srli_epi16(__m128i _A, int _Count); 
#line 279
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count); 
#line 280
extern __m128i _mm_srli_epi32(__m128i _A, int _Count); 
#line 281
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count); 
#line 282
extern __m128i _mm_srli_epi64(__m128i _A, int _Count); 
#line 283
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count); 
#line 289
extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B); 
#line 290
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B); 
#line 291
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B); 
#line 292
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B); 
#line 293
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B); 
#line 294
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B); 
#line 295
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B); 
#line 296
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B); 
#line 297
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B); 
#line 303
extern __m128i _mm_cvtsi32_si128(int _A); 
#line 304
extern int _mm_cvtsi128_si32(__m128i _A); 
#line 310
extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B); 
#line 311
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B); 
#line 312
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B); 
#line 313
extern int _mm_extract_epi16(__m128i _A, int _Imm); 
#line 314
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm); 
#line 315
extern int _mm_movemask_epi8(__m128i _A); 
#line 316
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm); 
#line 317
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm); 
#line 318
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm); 
#line 319
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B); 
#line 320
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B); 
#line 321
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B); 
#line 322
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B); 
#line 323
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B); 
#line 324
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B); 
#line 325
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B); 
#line 326
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B); 
#line 332
extern __m128i _mm_load_si128(const __m128i * _P); 
#line 333
extern __m128i _mm_loadu_si128(const __m128i * _P); 
#line 334
extern __m128i _mm_loadl_epi64(const __m128i * _P); 
#line 343 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1, __int64 _I0); 
#line 344
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0); 
#line 345
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4, short _W3, short _W2, short _W1, short _W0); 
#line 347
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12, char _B11, char _B10, char _B9, char _B8, char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); 
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i); 
#line 355
extern __m128i _mm_set1_epi32(int _I); 
#line 356
extern __m128i _mm_set1_epi16(short _W); 
#line 357
extern __m128i _mm_set1_epi8(char _B); 
#line 358
extern __m128i _mm_setl_epi64(__m128i _Q); 
#line 362 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3); 
#line 363
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3, short _W4, short _W5, short _W6, short _W7); 
#line 365
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12, char _B11, char _B10, char _B9, char _B8, char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); 
#line 369
extern __m128i _mm_setzero_si128(); 
#line 375
extern void _mm_store_si128(__m128i * _P, __m128i _B); 
#line 376
extern void _mm_storeu_si128(__m128i * _P, __m128i _B); 
#line 377
extern void _mm_storel_epi64(__m128i * _P, __m128i _Q); 
#line 378
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char * _P); 
#line 384
extern __m128i _mm_move_epi64(__m128i _Q); 
#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
extern void _mm_stream_pd(double * _Dp, __m128d _A); 
#line 395
extern void _mm_stream_si128(__m128i * _P, __m128i _A); 
#line 396
extern void _mm_clflush(const void * _P); 
#line 397
extern void _mm_lfence(); 
#line 398
extern void _mm_mfence(); 
#line 399
extern void _mm_stream_si32(int * _P, int _I); 
#line 400
extern void _mm_pause(); 
#line 406
extern double _mm_cvtsd_f64(__m128d _A); 
#line 414
extern __m128 _mm_castpd_ps(__m128d); 
#line 415
extern __m128i _mm_castpd_si128(__m128d); 
#line 416
extern __m128d _mm_castps_pd(__m128); 
#line 417
extern __m128i _mm_castps_si128(__m128); 
#line 418
extern __m128 _mm_castsi128_ps(__m128i); 
#line 419
extern __m128d _mm_castsi128_pd(__m128i); 
#line 426
extern __int64 _mm_cvtsd_si64(__m128d); 
#line 427
extern __int64 _mm_cvttsd_si64(__m128d); 
#line 428
extern __m128d _mm_cvtsi64_sd(__m128d, __int64); 
#line 429
extern __m128i _mm_cvtsi64_si128(__int64); 
#line 430
extern __int64 _mm_cvtsi128_si64(__m128i); 
#line 436 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\emmintrin.h"
}
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\pmmintrin.h"
extern "C" {
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\pmmintrin.h"
extern __m128 _mm_addsub_ps(__m128, __m128); 
#line 67
extern __m128 _mm_hadd_ps(__m128, __m128); 
#line 68
extern __m128 _mm_hsub_ps(__m128, __m128); 
#line 69
extern __m128 _mm_movehdup_ps(__m128); 
#line 70
extern __m128 _mm_moveldup_ps(__m128); 
#line 76
extern __m128d _mm_addsub_pd(__m128d, __m128d); 
#line 77
extern __m128d _mm_hadd_pd(__m128d, __m128d); 
#line 78
extern __m128d _mm_hsub_pd(__m128d, __m128d); 
#line 79
extern __m128d _mm_loaddup_pd(const double *); 
#line 80
extern __m128d _mm_movedup_pd(__m128d); 
#line 85
extern __m128i _mm_lddqu_si128(const __m128i *); 
#line 93
extern void _mm_monitor(const void *, unsigned, unsigned); 
#line 98
extern void _mm_mwait(unsigned, unsigned); 
#line 101
}
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern "C" {
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_hadd_epi16(__m128i, __m128i); 
#line 46
extern __m128i _mm_hadd_epi32(__m128i, __m128i); 
#line 47
extern __m128i _mm_hadds_epi16(__m128i, __m128i); 
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_hsub_epi16(__m128i, __m128i); 
#line 64
extern __m128i _mm_hsub_epi32(__m128i, __m128i); 
#line 65
extern __m128i _mm_hsubs_epi16(__m128i, __m128i); 
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_maddubs_epi16(__m128i, __m128i); 
#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_mulhrs_epi16(__m128i, __m128i); 
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_shuffle_epi8(__m128i, __m128i); 
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_sign_epi8(__m128i, __m128i); 
#line 110
extern __m128i _mm_sign_epi16(__m128i, __m128i); 
#line 111
extern __m128i _mm_sign_epi32(__m128i, __m128i); 
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_alignr_epi8(__m128i, __m128i, int); 
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
extern __m128i _mm_abs_epi8(__m128i); 
#line 132
extern __m128i _mm_abs_epi16(__m128i); 
#line 133
extern __m128i _mm_abs_epi32(__m128i); 
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\tmmintrin.h"
}
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h"
extern "C" {
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h"
extern __m128i _mm_blend_epi16(__m128i, __m128i, const int); 
#line 90
extern __m128i _mm_blendv_epi8(__m128i, __m128i, __m128i mask); 
#line 95
extern __m128 _mm_blend_ps(__m128, __m128, const int); 
#line 96
extern __m128 _mm_blendv_ps(__m128, __m128, __m128); 
#line 101
extern __m128d _mm_blend_pd(__m128d, __m128d, const int); 
#line 102
extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d); 
#line 107
extern __m128 _mm_dp_ps(__m128, __m128, const int); 
#line 108
extern __m128d _mm_dp_pd(__m128d, __m128d, const int); 
#line 113
extern __m128i _mm_cmpeq_epi64(__m128i, __m128i); 
#line 117
extern __m128i _mm_min_epi8(__m128i, __m128i); 
#line 118
extern __m128i _mm_max_epi8(__m128i, __m128i); 
#line 120
extern __m128i _mm_min_epu16(__m128i, __m128i); 
#line 121
extern __m128i _mm_max_epu16(__m128i, __m128i); 
#line 123
extern __m128i _mm_min_epi32(__m128i, __m128i); 
#line 124
extern __m128i _mm_max_epi32(__m128i, __m128i); 
#line 125
extern __m128i _mm_min_epu32(__m128i, __m128i); 
#line 126
extern __m128i _mm_max_epu32(__m128i, __m128i); 
#line 131
extern __m128i _mm_mullo_epi32(__m128i, __m128i); 
#line 136
extern __m128i _mm_mul_epi32(__m128i, __m128i); 
#line 141
extern int _mm_testz_si128(__m128i, __m128i); 
#line 146
extern int _mm_testc_si128(__m128i, __m128i); 
#line 152
extern int _mm_testnzc_si128(__m128i, __m128i); 
#line 160
extern __m128 _mm_insert_ps(__m128, __m128, const int); 
#line 170
extern int _mm_extract_ps(__m128, const int); 
#line 188
extern __m128i _mm_insert_epi8(__m128i, int, const int); 
#line 189
extern __m128i _mm_insert_epi32(__m128i, int, const int); 
#line 192
extern __m128i _mm_insert_epi64(__m128i, __int64, const int); 
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h"
extern int _mm_extract_epi8(__m128i, const int); 
#line 198
extern int _mm_extract_epi32(__m128i, const int); 
#line 201
extern __int64 _mm_extract_epi64(__m128i, const int); 
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\smmintrin.h"
extern __m128i _mm_minpos_epu16(__m128i); 
#line 211
extern __m128d _mm_round_pd(__m128d, int); 
#line 212
extern __m128d _mm_round_sd(__m128d, __m128d, int); 
#line 216
extern __m128 _mm_round_ps(__m128, int); 
#line 217
extern __m128 _mm_round_ss(__m128, __m128, int); 
#line 221
extern __m128i _mm_cvtepi8_epi32(__m128i); 
#line 222
extern __m128i _mm_cvtepi16_epi32(__m128i); 
#line 223
extern __m128i _mm_cvtepi8_epi64(__m128i); 
#line 224
extern __m128i _mm_cvtepi32_epi64(__m128i); 
#line 225
extern __m128i _mm_cvtepi16_epi64(__m128i); 
#line 226
extern __m128i _mm_cvtepi8_epi16(__m128i); 
#line 230
extern __m128i _mm_cvtepu8_epi32(__m128i); 
#line 231
extern __m128i _mm_cvtepu16_epi32(__m128i); 
#line 232
extern __m128i _mm_cvtepu8_epi64(__m128i); 
#line 233
extern __m128i _mm_cvtepu32_epi64(__m128i); 
#line 234
extern __m128i _mm_cvtepu16_epi64(__m128i); 
#line 235
extern __m128i _mm_cvtepu8_epi16(__m128i); 
#line 241
extern __m128i _mm_packus_epi32(__m128i, __m128i); 
#line 247
extern __m128i _mm_mpsadbw_epu8(__m128i, __m128i, const int); 
#line 253
extern __m128i _mm_stream_load_si128(const __m128i *); 
#line 256
}
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h"
extern "C" {
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h"
extern __m128i _mm_cmpistrm(__m128i, __m128i, const int); 
#line 84
extern int _mm_cmpistri(__m128i, __m128i, const int); 
#line 86
extern __m128i _mm_cmpestrm(__m128i, int, __m128i, int, const int); 
#line 87
extern int _mm_cmpestri(__m128i, int, __m128i, int, const int); 
#line 93
extern int _mm_cmpistrz(__m128i, __m128i, const int); 
#line 94
extern int _mm_cmpistrc(__m128i, __m128i, const int); 
#line 95
extern int _mm_cmpistrs(__m128i, __m128i, const int); 
#line 96
extern int _mm_cmpistro(__m128i, __m128i, const int); 
#line 97
extern int _mm_cmpistra(__m128i, __m128i, const int); 
#line 99
extern int _mm_cmpestrz(__m128i, int, __m128i, int, const int); 
#line 100
extern int _mm_cmpestrc(__m128i, int, __m128i, int, const int); 
#line 101
extern int _mm_cmpestrs(__m128i, int, __m128i, int, const int); 
#line 102
extern int _mm_cmpestro(__m128i, int, __m128i, int, const int); 
#line 103
extern int _mm_cmpestra(__m128i, int, __m128i, int, const int); 
#line 110
extern __m128i _mm_cmpgt_epi64(__m128i, __m128i); 
#line 116
extern int _mm_popcnt_u32(unsigned); 
#line 119
extern __int64 _mm_popcnt_u64(unsigned __int64); 
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h"
extern unsigned _mm_crc32_u8(unsigned, unsigned char); 
#line 127
extern unsigned _mm_crc32_u16(unsigned, unsigned short); 
#line 128
extern unsigned _mm_crc32_u32(unsigned, unsigned); 
#line 131
extern unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64); 
#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\nmmintrin.h"
}
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\wmmintrin.h"
extern "C" {
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\wmmintrin.h"
extern __m128i _mm_aesdec_si128(__m128i, __m128i); 
#line 48
extern __m128i _mm_aesdeclast_si128(__m128i, __m128i); 
#line 54
extern __m128i _mm_aesenc_si128(__m128i, __m128i); 
#line 60
extern __m128i _mm_aesenclast_si128(__m128i, __m128i); 
#line 66
extern __m128i _mm_aesimc_si128(__m128i); 
#line 73
extern __m128i _mm_aeskeygenassist_si128(__m128i, const int); 
#line 81
extern __m128i _mm_clmulepi64_si128(__m128i, __m128i, const int); 
#line 86
}
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern "C" {
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
typedef 
#line 37
union __declspec(intrin_type) __declspec(align(32)) __m256 { 
#line 38
float m256_f32[8]; 
#line 39
} __m256; 
#line 43
typedef 
#line 41
struct __declspec(intrin_type) __declspec(align(32)) __m256d { 
#line 42
double m256d_f64[4]; 
#line 43
} __m256d; 
#line 54
typedef 
#line 45
union __declspec(intrin_type) __declspec(align(32)) __m256i { 
#line 46
char m256i_i8[32]; 
#line 47
short m256i_i16[16]; 
#line 48
int m256i_i32[8]; 
#line 49
__int64 m256i_i64[4]; 
#line 50
unsigned char m256i_u8[32]; 
#line 51
unsigned short m256i_u16[16]; 
#line 52
unsigned m256i_u32[8]; 
#line 53
unsigned __int64 m256i_u64[4]; 
#line 54
} __m256i; 
#line 106
extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d); 
#line 116
extern __m256 __cdecl _mm256_add_ps(__m256, __m256); 
#line 129
extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d); 
#line 142
extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256); 
#line 151
extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d); 
#line 160
extern __m256 __cdecl _mm256_and_ps(__m256, __m256); 
#line 169
extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d); 
#line 178
extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256); 
#line 192
extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int); 
#line 206
extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int); 
#line 216
extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d); 
#line 226
extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256); 
#line 235
extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d); 
#line 244
extern __m256 __cdecl _mm256_div_ps(__m256, __m256); 
#line 259
extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int); 
#line 268
extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d); 
#line 277
extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256); 
#line 286
extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d); 
#line 295
extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256); 
#line 304
extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d); 
#line 313
extern __m256 __cdecl _mm256_max_ps(__m256, __m256); 
#line 322
extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d); 
#line 331
extern __m256 __cdecl _mm256_min_ps(__m256, __m256); 
#line 341
extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d); 
#line 351
extern __m256 __cdecl _mm256_mul_ps(__m256, __m256); 
#line 360
extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d); 
#line 369
extern __m256 __cdecl _mm256_or_ps(__m256, __m256); 
#line 381
extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int); 
#line 394
extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int); 
#line 403
extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d); 
#line 413
extern __m256 __cdecl _mm256_sub_ps(__m256, __m256); 
#line 422
extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d); 
#line 431
extern __m256 __cdecl _mm256_xor_ps(__m256, __m256); 
#line 447
extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int); 
#line 448
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int); 
#line 464
extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int); 
#line 465
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int); 
#line 478
extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int); 
#line 484
extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int); 
#line 497
extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int); 
#line 503
extern int __cdecl _mm_comi_ss(__m128, __m128, const int); 
#line 512
extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i); 
#line 521
extern __m256 __cdecl _mm256_cvtepi32_ps(__m256i); 
#line 531
extern __m128 __cdecl _mm256_cvtpd_ps(__m256d); 
#line 540
extern __m256i __cdecl _mm256_cvtps_epi32(__m256); 
#line 550
extern __m256d __cdecl _mm256_cvtps_pd(__m128); 
#line 563
extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d); 
#line 572
extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d); 
#line 585
extern __m256i __cdecl _mm256_cvttps_epi32(__m256); 
#line 593
extern __m128 __cdecl _mm256_extractf128_ps(__m256, const int); 
#line 594
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int); 
#line 595
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int); 
#line 602
extern void __cdecl _mm256_zeroall(); 
#line 610
extern void __cdecl _mm256_zeroupper(); 
#line 620
extern __m256 __cdecl _mm256_permutevar_ps(__m256, __m256i); 
#line 621
extern __m128 __cdecl _mm_permutevar_ps(__m128, __m128i); 
#line 631
extern __m256 __cdecl _mm256_permute_ps(__m256, int); 
#line 632
extern __m128 __cdecl _mm_permute_ps(__m128, int); 
#line 642
extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i); 
#line 643
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i); 
#line 653
extern __m256d __cdecl _mm256_permute_pd(__m256d, int); 
#line 654
extern __m128d __cdecl _mm_permute_pd(__m128d, int); 
#line 663
extern __m256 __cdecl _mm256_permute2f128_ps(__m256, __m256, int); 
#line 664
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int); 
#line 665
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int); 
#line 674
extern __m256 __cdecl _mm256_broadcast_ss(const float *); 
#line 675
extern __m128 __cdecl _mm_broadcast_ss(const float *); 
#line 683
extern __m256d __cdecl _mm256_broadcast_sd(const double *); 
#line 691
extern __m256 __cdecl _mm256_broadcast_ps(const __m128 *); 
#line 692
extern __m256d __cdecl _mm256_broadcast_pd(const __m128d *); 
#line 702
extern __m256 __cdecl _mm256_insertf128_ps(__m256, __m128, int); 
#line 703
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int); 
#line 704
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int); 
#line 713
extern __m256d __cdecl _mm256_load_pd(const double *); 
#line 714
extern void __cdecl _mm256_store_pd(double *, __m256d); 
#line 723
extern __m256 __cdecl _mm256_load_ps(const float *); 
#line 724
extern void __cdecl _mm256_store_ps(float *, __m256); 
#line 733
extern __m256d __cdecl _mm256_loadu_pd(const double *); 
#line 734
extern void __cdecl _mm256_storeu_pd(double *, __m256d); 
#line 743
extern __m256 __cdecl _mm256_loadu_ps(const float *); 
#line 744
extern void __cdecl _mm256_storeu_ps(float *, __m256); 
#line 753
extern __m256i __cdecl _mm256_load_si256(const __m256i *); 
#line 754
extern void __cdecl _mm256_store_si256(__m256i *, __m256i); 
#line 763
extern __m256i __cdecl _mm256_loadu_si256(const __m256i *); 
#line 764
extern void __cdecl _mm256_storeu_si256(__m256i *, __m256i); 
#line 836
extern __m256d __cdecl _mm256_maskload_pd(const double *, __m256i); 
#line 837
extern void __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d); 
#line 838
extern __m128d __cdecl _mm_maskload_pd(const double *, __m128i); 
#line 839
extern void __cdecl _mm_maskstore_pd(double *, __m128i, __m128d); 
#line 859
extern __m256 __cdecl _mm256_maskload_ps(const float *, __m256i); 
#line 860
extern void __cdecl _mm256_maskstore_ps(float *, __m256i, __m256); 
#line 861
extern __m128 __cdecl _mm_maskload_ps(const float *, __m128i); 
#line 862
extern void __cdecl _mm_maskstore_ps(float *, __m128i, __m128); 
#line 870
extern __m256 __cdecl _mm256_movehdup_ps(__m256); 
#line 878
extern __m256 __cdecl _mm256_moveldup_ps(__m256); 
#line 886
extern __m256d __cdecl _mm256_movedup_pd(__m256d); 
#line 896
extern __m256i __cdecl _mm256_lddqu_si256(const __m256i *); 
#line 904
extern void __cdecl _mm256_stream_si256(__m256i *, __m256i); 
#line 913
extern void __cdecl _mm256_stream_pd(double *, __m256d); 
#line 922
extern void __cdecl _mm256_stream_ps(float *, __m256); 
#line 932
extern __m256 __cdecl _mm256_rcp_ps(__m256); 
#line 943
extern __m256 __cdecl _mm256_rsqrt_ps(__m256); 
#line 952
extern __m256d __cdecl _mm256_sqrt_pd(__m256d); 
#line 961
extern __m256 __cdecl _mm256_sqrt_ps(__m256); 
#line 974
extern __m256d __cdecl _mm256_round_pd(__m256d, int); 
#line 989
extern __m256 __cdecl _mm256_round_ps(__m256, int); 
#line 999
extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d); 
#line 1007
extern __m256 __cdecl _mm256_unpackhi_ps(__m256, __m256); 
#line 1015
extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d); 
#line 1023
extern __m256 __cdecl _mm256_unpacklo_ps(__m256, __m256); 
#line 1033
extern int __cdecl _mm256_testz_si256(__m256i, __m256i); 
#line 1037
extern int __cdecl _mm256_testc_si256(__m256i, __m256i); 
#line 1041
extern int __cdecl _mm256_testnzc_si256(__m256i, __m256i); 
#line 1056
extern int __cdecl _mm256_testz_pd(__m256d, __m256d); 
#line 1057
extern int __cdecl _mm256_testc_pd(__m256d, __m256d); 
#line 1058
extern int __cdecl _mm256_testnzc_pd(__m256d, __m256d); 
#line 1059
extern int __cdecl _mm_testz_pd(__m128d, __m128d); 
#line 1060
extern int __cdecl _mm_testc_pd(__m128d, __m128d); 
#line 1061
extern int __cdecl _mm_testnzc_pd(__m128d, __m128d); 
#line 1074
extern int __cdecl _mm256_testz_ps(__m256, __m256); 
#line 1075
extern int __cdecl _mm256_testc_ps(__m256, __m256); 
#line 1076
extern int __cdecl _mm256_testnzc_ps(__m256, __m256); 
#line 1077
extern int __cdecl _mm_testz_ps(__m128, __m128); 
#line 1078
extern int __cdecl _mm_testc_ps(__m128, __m128); 
#line 1079
extern int __cdecl _mm_testnzc_ps(__m128, __m128); 
#line 1088
extern int __cdecl _mm256_movemask_pd(__m256d); 
#line 1097
extern int __cdecl _mm256_movemask_ps(__m256); 
#line 1102
extern __m256d __cdecl _mm256_setzero_pd(); 
#line 1103
extern __m256 __cdecl _mm256_setzero_ps(); 
#line 1104
extern __m256i __cdecl _mm256_setzero_si256(); 
#line 1109
extern __m256d __cdecl _mm256_set_pd(double, double, double, double); 
#line 1110
extern __m256 __cdecl _mm256_set_ps(float, float, float, float, float, float, float, float); 
#line 1112
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 1120
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); 
#line 1124
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int, int, int, int, int); 
#line 1126
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64, __int64, __int64); 
#line 1138
extern __m256d __cdecl _mm256_setr_pd(double, double, double, double); 
#line 1139
extern __m256 __cdecl _mm256_setr_ps(float, float, float, float, float, float, float, float); 
#line 1141
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 1149
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); 
#line 1153
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int, int, int, int, int); 
#line 1155
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64, __int64, __int64); 
#line 1164
extern __m256d __cdecl _mm256_set1_pd(double); 
#line 1165
extern __m256 __cdecl _mm256_set1_ps(float); 
#line 1166
extern __m256i __cdecl _mm256_set1_epi8(char); 
#line 1167
extern __m256i __cdecl _mm256_set1_epi16(short); 
#line 1168
extern __m256i __cdecl _mm256_set1_epi32(int); 
#line 1169
extern __m256i __cdecl _mm256_set1_epi64x(__int64); 
#line 1177
extern __m256 __cdecl _mm256_castpd_ps(__m256d); 
#line 1178
extern __m256d __cdecl _mm256_castps_pd(__m256); 
#line 1179
extern __m256i __cdecl _mm256_castps_si256(__m256); 
#line 1180
extern __m256i __cdecl _mm256_castpd_si256(__m256d); 
#line 1181
extern __m256 __cdecl _mm256_castsi256_ps(__m256i); 
#line 1182
extern __m256d __cdecl _mm256_castsi256_pd(__m256i); 
#line 1183
extern __m128 __cdecl _mm256_castps256_ps128(__m256); 
#line 1184
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d); 
#line 1185
extern __m128i __cdecl _mm256_castsi256_si128(__m256i); 
#line 1186
extern __m256 __cdecl _mm256_castps128_ps256(__m128); 
#line 1187
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d); 
#line 1188
extern __m256i __cdecl _mm256_castsi128_si256(__m128i); 
#line 1195
extern __m128 __cdecl _mm_cvtph_ps(__m128i); 
#line 1196
extern __m256 __cdecl _mm256_cvtph_ps(__m128i); 
#line 1197
extern __m128i __cdecl _mm_cvtps_ph(__m128, const int); 
#line 1198
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int); 
#line 1219
extern unsigned __int64 __cdecl _xgetbv(unsigned); 
#line 1222
extern void __cdecl _xsetbv(unsigned, unsigned __int64); 
#line 1229
extern void __cdecl _xsave(void *, unsigned __int64); 
#line 1231
extern void __cdecl _xsave64(void *, unsigned __int64); 
#line 1239 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _xsaveopt(void *, unsigned __int64); 
#line 1241
extern void __cdecl _xsaveopt64(void *, unsigned __int64); 
#line 1248 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _xsavec(void *, unsigned __int64); 
#line 1250
extern void __cdecl _xsavec64(void *, unsigned __int64); 
#line 1258 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _xrstor(const void *, unsigned __int64); 
#line 1260
extern void __cdecl _xrstor64(const void *, unsigned __int64); 
#line 1268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _xsaves(void *, unsigned __int64); 
#line 1270
extern void __cdecl _xsaves64(void *, unsigned __int64); 
#line 1278 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _xrstors(const void *, unsigned __int64); 
#line 1280
extern void __cdecl _xrstors64(const void *, unsigned __int64); 
#line 1287 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _fxsave(void *); 
#line 1289
extern void __cdecl _fxsave64(void *); 
#line 1296 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _fxrstor(const void *); 
#line 1298
extern void __cdecl _fxrstor64(const void *); 
#line 1307 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern int __cdecl _rdrand16_step(unsigned short *); 
#line 1308
extern int __cdecl _rdrand32_step(unsigned *); 
#line 1310
extern int __cdecl _rdrand64_step(unsigned __int64 *); 
#line 1317 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern unsigned __cdecl _readfsbase_u32(); 
#line 1318
extern unsigned __cdecl _readgsbase_u32(); 
#line 1319
extern unsigned __int64 __cdecl _readfsbase_u64(); 
#line 1320
extern unsigned __int64 __cdecl _readgsbase_u64(); 
#line 1325
extern void __cdecl _writefsbase_u32(unsigned); 
#line 1326
extern void __cdecl _writegsbase_u32(unsigned); 
#line 1327
extern void __cdecl _writefsbase_u64(unsigned __int64); 
#line 1328
extern void __cdecl _writegsbase_u64(unsigned __int64); 
#line 1334 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern __m128 __cdecl _mm_fmadd_ps(__m128, __m128, __m128); 
#line 1335
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d); 
#line 1336
extern __m128 __cdecl _mm_fmadd_ss(__m128, __m128, __m128); 
#line 1337
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d); 
#line 1338
extern __m128 __cdecl _mm_fmsub_ps(__m128, __m128, __m128); 
#line 1339
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d); 
#line 1340
extern __m128 __cdecl _mm_fmsub_ss(__m128, __m128, __m128); 
#line 1341
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d); 
#line 1342
extern __m128 __cdecl _mm_fnmadd_ps(__m128, __m128, __m128); 
#line 1343
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d); 
#line 1344
extern __m128 __cdecl _mm_fnmadd_ss(__m128, __m128, __m128); 
#line 1345
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d); 
#line 1346
extern __m128 __cdecl _mm_fnmsub_ps(__m128, __m128, __m128); 
#line 1347
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d); 
#line 1348
extern __m128 __cdecl _mm_fnmsub_ss(__m128, __m128, __m128); 
#line 1349
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d); 
#line 1351
extern __m256 __cdecl _mm256_fmadd_ps(__m256, __m256, __m256); 
#line 1352
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d); 
#line 1353
extern __m256 __cdecl _mm256_fmsub_ps(__m256, __m256, __m256); 
#line 1354
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d); 
#line 1355
extern __m256 __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256); 
#line 1356
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d); 
#line 1357
extern __m256 __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256); 
#line 1358
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d); 
#line 1364
extern __m128 __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128); 
#line 1365
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d); 
#line 1366
extern __m128 __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128); 
#line 1367
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d); 
#line 1369
extern __m256 __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256); 
#line 1370
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d); 
#line 1371
extern __m256 __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256); 
#line 1372
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d); 
#line 1378
extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i); 
#line 1379
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i); 
#line 1380
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i); 
#line 1381
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i); 
#line 1383
extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i); 
#line 1384
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i); 
#line 1385
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i); 
#line 1386
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i); 
#line 1392
extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i); 
#line 1393
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i); 
#line 1394
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i); 
#line 1395
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i); 
#line 1396
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i); 
#line 1397
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i); 
#line 1399
extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i); 
#line 1400
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i); 
#line 1401
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i); 
#line 1402
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i); 
#line 1403
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i); 
#line 1404
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i); 
#line 1410
extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i); 
#line 1411
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i); 
#line 1412
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i); 
#line 1413
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i); 
#line 1419
extern __m256i __cdecl _mm256_abs_epi8(__m256i); 
#line 1420
extern __m256i __cdecl _mm256_abs_epi16(__m256i); 
#line 1421
extern __m256i __cdecl _mm256_abs_epi32(__m256i); 
#line 1423
extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i); 
#line 1424
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i); 
#line 1425
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i); 
#line 1426
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i); 
#line 1428
extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i); 
#line 1429
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i); 
#line 1430
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i); 
#line 1431
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i); 
#line 1433
extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i); 
#line 1434
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i); 
#line 1435
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i); 
#line 1436
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i); 
#line 1438
extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i); 
#line 1439
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i); 
#line 1440
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i); 
#line 1441
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i); 
#line 1443
extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i); 
#line 1444
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i); 
#line 1446
extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i); 
#line 1447
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i); 
#line 1448
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i); 
#line 1450
extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i); 
#line 1451
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i); 
#line 1452
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i); 
#line 1454
extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i); 
#line 1455
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i); 
#line 1457
extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i); 
#line 1458
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i); 
#line 1460
extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i); 
#line 1461
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i); 
#line 1463
extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i); 
#line 1464
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i); 
#line 1466
extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i); 
#line 1467
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i); 
#line 1468
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i); 
#line 1470
extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i); 
#line 1472
extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i); 
#line 1473
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int); 
#line 1479
extern __m256i __cdecl _mm256_slli_si256(__m256i, const int); 
#line 1481
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int); 
#line 1484
extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i); 
#line 1485
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i); 
#line 1486
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i); 
#line 1488
extern __m256i __cdecl _mm256_slli_epi16(__m256i, int); 
#line 1489
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int); 
#line 1490
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int); 
#line 1492
extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i); 
#line 1493
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i); 
#line 1495
extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i); 
#line 1496
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i); 
#line 1498
extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i); 
#line 1499
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i); 
#line 1501
extern __m256i __cdecl _mm256_srai_epi16(__m256i, int); 
#line 1502
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int); 
#line 1504
extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i); 
#line 1506
extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i); 
#line 1508
extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i); 
#line 1509
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i); 
#line 1510
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i); 
#line 1512
extern __m256i __cdecl _mm256_srli_epi16(__m256i, int); 
#line 1513
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int); 
#line 1514
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int); 
#line 1516
extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i); 
#line 1517
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i); 
#line 1519
extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i); 
#line 1520
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i); 
#line 1526
extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int); 
#line 1528
extern __m256i __cdecl _mm256_blend_epi32(__m256i, __m256i, const int); 
#line 1530
extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int); 
#line 1532
extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i); 
#line 1533
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int); 
#line 1535
extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i); 
#line 1536
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i); 
#line 1537
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i); 
#line 1538
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i); 
#line 1540
extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i); 
#line 1541
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i); 
#line 1542
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i); 
#line 1543
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i); 
#line 1545
extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i); 
#line 1546
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i); 
#line 1547
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i); 
#line 1548
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i); 
#line 1550
extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i); 
#line 1551
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int); 
#line 1553
extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int); 
#line 1554
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int); 
#line 1556
extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int); 
#line 1557
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int); 
#line 1563
extern __m128 __cdecl _mm_broadcastss_ps(__m128); 
#line 1564
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d); 
#line 1566
extern __m128i __cdecl _mm_broadcastb_epi8(__m128i); 
#line 1567
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i); 
#line 1568
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i); 
#line 1569
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i); 
#line 1571
extern __m256 __cdecl _mm256_broadcastss_ps(__m128); 
#line 1572
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d); 
#line 1574
extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i); 
#line 1575
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i); 
#line 1576
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i); 
#line 1577
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i); 
#line 1579
extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i); 
#line 1586
extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i); 
#line 1587
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i); 
#line 1588
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i); 
#line 1589
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i); 
#line 1590
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i); 
#line 1591
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i); 
#line 1593
extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i); 
#line 1594
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i); 
#line 1595
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i); 
#line 1596
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i); 
#line 1597
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i); 
#line 1598
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i); 
#line 1605
extern int __cdecl _mm256_movemask_epi8(__m256i); 
#line 1611
extern __m128i __cdecl _mm_maskload_epi32(const int *, __m128i); 
#line 1613
extern __m128i __cdecl _mm_maskload_epi64(const __int64 *, __m128i); 
#line 1616
extern void __cdecl _mm_maskstore_epi32(int *, __m128i, __m128i); 
#line 1619
extern void __cdecl _mm_maskstore_epi64(__int64 *, __m128i, __m128i); 
#line 1623
extern __m256i __cdecl _mm256_maskload_epi32(const int *, __m256i); 
#line 1625
extern __m256i __cdecl _mm256_maskload_epi64(const __int64 *, __m256i); 
#line 1628
extern void __cdecl _mm256_maskstore_epi32(int *, __m256i, __m256i); 
#line 1631
extern void __cdecl _mm256_maskstore_epi64(__int64 *, __m256i, __m256i); 
#line 1639
extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i); 
#line 1640
extern __m256 __cdecl _mm256_permutevar8x32_ps(__m256, __m256i); 
#line 1642
extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int); 
#line 1643
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int); 
#line 1645
extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int); 
#line 1651
extern __m256i __cdecl _mm256_stream_load_si256(const __m256i *); 
#line 1658
extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d, const double *, __m128i, __m256d, const int); 
#line 1663
extern __m256 __cdecl _mm256_mask_i32gather_ps(__m256, const float *, __m256i, __m256, const int); 
#line 1668
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d, const double *, __m256i, __m256d, const int); 
#line 1673
extern __m128 __cdecl _mm256_mask_i64gather_ps(__m128, const float *, __m256i, __m128, const int); 
#line 1679
extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d, const double *, __m128i, __m128d, const int); 
#line 1684
extern __m128 __cdecl _mm_mask_i32gather_ps(__m128, const float *, __m128i, __m128, const int); 
#line 1689
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d, const double *, __m128i, __m128d, const int); 
#line 1694
extern __m128 __cdecl _mm_mask_i64gather_ps(__m128, const float *, __m128i, __m128, const int); 
#line 1701
extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i, const int *, __m256i, __m256i, const int); 
#line 1706
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i, const __int64 *, __m128i, __m256i, const int); 
#line 1711
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i, const int *, __m256i, __m128i, const int); 
#line 1716
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i, const __int64 *, __m256i, __m256i, const int); 
#line 1722
extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i, const int *, __m128i, __m128i, const int); 
#line 1727
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i, const __int64 *, __m128i, __m128i, const int); 
#line 1732
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i, const int *, __m128i, __m128i, const int); 
#line 1737
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i, const __int64 *, __m128i, __m128i, const int); 
#line 1747
extern __m256d __cdecl _mm256_i32gather_pd(const double *, __m128i, const int); 
#line 1750
extern __m256 __cdecl _mm256_i32gather_ps(const float *, __m256i, const int); 
#line 1753
extern __m256d __cdecl _mm256_i64gather_pd(const double *, __m256i, const int); 
#line 1756
extern __m128 __cdecl _mm256_i64gather_ps(const float *, __m256i, const int); 
#line 1760
extern __m128d __cdecl _mm_i32gather_pd(const double *, __m128i, const int); 
#line 1763
extern __m128 __cdecl _mm_i32gather_ps(const float *, __m128i, const int); 
#line 1766
extern __m128d __cdecl _mm_i64gather_pd(const double *, __m128i, const int); 
#line 1769
extern __m128 __cdecl _mm_i64gather_ps(const float *, __m128i, const int); 
#line 1773
extern __m256i __cdecl _mm256_i32gather_epi32(const int *, __m256i, const int); 
#line 1776
extern __m256i __cdecl _mm256_i32gather_epi64(const __int64 *, __m128i, const int); 
#line 1779
extern __m128i __cdecl _mm256_i64gather_epi32(const int *, __m256i, const int); 
#line 1782
extern __m256i __cdecl _mm256_i64gather_epi64(const __int64 *, __m256i, const int); 
#line 1786
extern __m128i __cdecl _mm_i32gather_epi32(const int *, __m128i, const int); 
#line 1789
extern __m128i __cdecl _mm_i32gather_epi64(const __int64 *, __m128i, const int); 
#line 1792
extern __m128i __cdecl _mm_i64gather_epi32(const int *, __m128i, const int); 
#line 1795
extern __m128i __cdecl _mm_i64gather_epi64(const __int64 *, __m128i, const int); 
#line 1805
extern unsigned _bextr_u32(unsigned, unsigned, unsigned); 
#line 1808
extern unsigned _blsi_u32(unsigned); 
#line 1809
extern unsigned _blsmsk_u32(unsigned); 
#line 1810
extern unsigned _blsr_u32(unsigned); 
#line 1811
extern unsigned _bzhi_u32(unsigned, unsigned); 
#line 1813
extern unsigned _mulx_u32(unsigned, unsigned, unsigned *); 
#line 1816
extern unsigned _pdep_u32(unsigned, unsigned); 
#line 1818
extern unsigned _pext_u32(unsigned, unsigned); 
#line 1820
extern unsigned _rorx_u32(unsigned, const unsigned); 
#line 1822
extern int _sarx_i32(int, unsigned); 
#line 1824
extern unsigned _shlx_u32(unsigned, unsigned); 
#line 1826
extern unsigned _shrx_u32(unsigned, unsigned); 
#line 1830
extern unsigned __int64 _bextr_u64(unsigned __int64, unsigned, unsigned); 
#line 1833
extern unsigned __int64 _blsi_u64(unsigned __int64); 
#line 1834
extern unsigned __int64 _blsmsk_u64(unsigned __int64); 
#line 1835
extern unsigned __int64 _blsr_u64(unsigned __int64); 
#line 1836
extern unsigned __int64 _bzhi_u64(unsigned __int64, unsigned); 
#line 1838
extern unsigned __int64 _mulx_u64(unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 1841
extern unsigned __int64 _pdep_u64(unsigned __int64, unsigned __int64); 
#line 1843
extern unsigned __int64 _pext_u64(unsigned __int64, unsigned __int64); 
#line 1845
extern unsigned __int64 _rorx_u64(unsigned __int64, const unsigned); 
#line 1847
extern __int64 _sarx_i64(__int64, unsigned); 
#line 1849
extern unsigned __int64 _shlx_u64(unsigned __int64, unsigned); 
#line 1851
extern unsigned __int64 _shrx_u64(unsigned __int64, unsigned); 
#line 1862 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern unsigned _lzcnt_u32(unsigned); 
#line 1864
extern unsigned __int64 _lzcnt_u64(unsigned __int64); 
#line 1874 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern unsigned _tzcnt_u32(unsigned); 
#line 1876
extern unsigned __int64 _tzcnt_u64(unsigned __int64); 
#line 1884 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern void __cdecl _invpcid(unsigned, void *); 
#line 1887
extern void _Store_HLERelease(volatile long *, long); 
#line 1888
extern void _StorePointer_HLERelease(void *volatile *, void *); 
#line 1890
extern long _InterlockedExchange_HLEAcquire(volatile long *, long); 
#line 1891
extern long _InterlockedExchange_HLERelease(volatile long *, long); 
#line 1892
extern void *_InterlockedExchangePointer_HLEAcquire(void *volatile *, void *); 
#line 1893
extern void *_InterlockedExchangePointer_HLERelease(void *volatile *, void *); 
#line 1895
extern long _InterlockedCompareExchange_HLEAcquire(volatile long *, long, long); 
#line 1896
extern long _InterlockedCompareExchange_HLERelease(volatile long *, long, long); 
#line 1897
extern __int64 _InterlockedCompareExchange64_HLEAcquire(volatile __int64 *, __int64, __int64); 
#line 1898
extern __int64 _InterlockedCompareExchange64_HLERelease(volatile __int64 *, __int64, __int64); 
#line 1899
extern void *_InterlockedCompareExchangePointer_HLEAcquire(void *volatile *, void *, void *); 
#line 1900
extern void *_InterlockedCompareExchangePointer_HLERelease(void *volatile *, void *, void *); 
#line 1902
extern long _InterlockedExchangeAdd_HLEAcquire(volatile long *, long); 
#line 1903
extern long _InterlockedExchangeAdd_HLERelease(volatile long *, long); 
#line 1905
extern long _InterlockedAnd_HLEAcquire(volatile long *, long); 
#line 1906
extern long _InterlockedAnd_HLERelease(volatile long *, long); 
#line 1907
extern long _InterlockedOr_HLEAcquire(volatile long *, long); 
#line 1908
extern long _InterlockedOr_HLERelease(volatile long *, long); 
#line 1909
extern long _InterlockedXor_HLEAcquire(volatile long *, long); 
#line 1910
extern long _InterlockedXor_HLERelease(volatile long *, long); 
#line 1912
extern unsigned char _interlockedbittestandset_HLEAcquire(long *, long); 
#line 1913
extern unsigned char _interlockedbittestandset_HLERelease(long *, long); 
#line 1914
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *, long); 
#line 1915
extern unsigned char _interlockedbittestandreset_HLERelease(long *, long); 
#line 1918
extern void _Store64_HLERelease(volatile __int64 *, __int64); 
#line 1919
extern __int64 _InterlockedExchange64_HLEAcquire(volatile __int64 *, __int64); 
#line 1920
extern __int64 _InterlockedExchange64_HLERelease(volatile __int64 *, __int64); 
#line 1922
extern __int64 _InterlockedExchangeAdd64_HLEAcquire(volatile __int64 *, __int64); 
#line 1923
extern __int64 _InterlockedExchangeAdd64_HLERelease(volatile __int64 *, __int64); 
#line 1925
extern __int64 _InterlockedAnd64_HLEAcquire(volatile __int64 *, __int64); 
#line 1926
extern __int64 _InterlockedAnd64_HLERelease(volatile __int64 *, __int64); 
#line 1927
extern __int64 _InterlockedOr64_HLEAcquire(volatile __int64 *, __int64); 
#line 1928
extern __int64 _InterlockedOr64_HLERelease(volatile __int64 *, __int64); 
#line 1929
extern __int64 _InterlockedXor64_HLEAcquire(volatile __int64 *, __int64); 
#line 1930
extern __int64 _InterlockedXor64_HLERelease(volatile __int64 *, __int64); 
#line 1932
extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *, __int64); 
#line 1933
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *, __int64); 
#line 1934
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *, __int64); 
#line 1935
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *, __int64); 
#line 1948 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern unsigned __cdecl _xbegin(); 
#line 1949
extern void __cdecl _xend(); 
#line 1950
extern void __cdecl _xabort(const unsigned); 
#line 1951
extern unsigned char __cdecl _xtest(); 
#line 1960
extern int __cdecl _rdseed16_step(unsigned short *); 
#line 1961
extern int __cdecl _rdseed32_step(unsigned *); 
#line 1963
extern int __cdecl _rdseed64_step(unsigned __int64 *); 
#line 1975 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern unsigned char __cdecl _addcarryx_u32(unsigned char, unsigned, unsigned, unsigned *); 
#line 1982
extern unsigned char __cdecl _addcarryx_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 1992 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\immintrin.h"
extern unsigned short __cdecl _load_be_u16(const void *); 
#line 1993
extern unsigned __cdecl _load_be_u32(const void *); 
#line 1994
extern unsigned __int64 __cdecl _load_be_u64(const void *); 
#line 2002
extern void __cdecl _store_be_u16(void *, unsigned short); 
#line 2003
extern void __cdecl _store_be_u32(void *, unsigned); 
#line 2004
extern void __cdecl _store_be_u64(void *, unsigned __int64); 
#line 2012
extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i); 
#line 2013
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i); 
#line 2014
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i); 
#line 2015
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int); 
#line 2017
extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i); 
#line 2018
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i); 
#line 2019
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i); 
#line 2024
extern void *__cdecl _bnd_set_ptr_bounds(const void *, size_t); 
#line 2025
extern void *__cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t); 
#line 2026
extern void *__cdecl _bnd_copy_ptr_bounds(const void *, const void *); 
#line 2027
extern void *__cdecl _bnd_init_ptr_bounds(const void *); 
#line 2028
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *); 
#line 2029
extern void __cdecl _bnd_chk_ptr_lbounds(const void *); 
#line 2030
extern void __cdecl _bnd_chk_ptr_ubounds(const void *); 
#line 2031
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t); 
#line 2032
extern void *__cdecl _bnd_load_ptr_bounds(const void **, const void *); 
#line 2033
extern const void *__cdecl _bnd_get_ptr_lbound(const void *); 
#line 2034
extern const void *__cdecl _bnd_get_ptr_ubound(const void *); 
#line 2037
}
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h"
extern "C" {
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h"
__m128 _mm_macc_ps(__m128, __m128, __m128); 
#line 128
__m128d _mm_macc_pd(__m128d, __m128d, __m128d); 
#line 129
__m128 _mm_macc_ss(__m128, __m128, __m128); 
#line 130
__m128d _mm_macc_sd(__m128d, __m128d, __m128d); 
#line 131
__m128 _mm_maddsub_ps(__m128, __m128, __m128); 
#line 132
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d); 
#line 133
__m128 _mm_msubadd_ps(__m128, __m128, __m128); 
#line 134
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d); 
#line 135
__m128 _mm_msub_ps(__m128, __m128, __m128); 
#line 136
__m128d _mm_msub_pd(__m128d, __m128d, __m128d); 
#line 137
__m128 _mm_msub_ss(__m128, __m128, __m128); 
#line 138
__m128d _mm_msub_sd(__m128d, __m128d, __m128d); 
#line 139
__m128 _mm_nmacc_ps(__m128, __m128, __m128); 
#line 140
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d); 
#line 141
__m128 _mm_nmacc_ss(__m128, __m128, __m128); 
#line 142
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d); 
#line 143
__m128 _mm_nmsub_ps(__m128, __m128, __m128); 
#line 144
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d); 
#line 145
__m128 _mm_nmsub_ss(__m128, __m128, __m128); 
#line 146
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d); 
#line 149
__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i); 
#line 150
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i); 
#line 151
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i); 
#line 152
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i); 
#line 153
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i); 
#line 154
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i); 
#line 155
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i); 
#line 156
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i); 
#line 157
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i); 
#line 158
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i); 
#line 159
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i); 
#line 160
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i); 
#line 163
__m128i _mm_haddw_epi8(__m128i); 
#line 164
__m128i _mm_haddd_epi8(__m128i); 
#line 165
__m128i _mm_haddq_epi8(__m128i); 
#line 166
__m128i _mm_haddd_epi16(__m128i); 
#line 167
__m128i _mm_haddq_epi16(__m128i); 
#line 168
__m128i _mm_haddq_epi32(__m128i); 
#line 169
__m128i _mm_haddw_epu8(__m128i); 
#line 170
__m128i _mm_haddd_epu8(__m128i); 
#line 171
__m128i _mm_haddq_epu8(__m128i); 
#line 172
__m128i _mm_haddd_epu16(__m128i); 
#line 173
__m128i _mm_haddq_epu16(__m128i); 
#line 174
__m128i _mm_haddq_epu32(__m128i); 
#line 175
__m128i _mm_hsubw_epi8(__m128i); 
#line 176
__m128i _mm_hsubd_epi16(__m128i); 
#line 177
__m128i _mm_hsubq_epi32(__m128i); 
#line 180
__m128i _mm_cmov_si128(__m128i, __m128i, __m128i); 
#line 181
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i); 
#line 184
__m128i _mm_rot_epi8(__m128i, __m128i); 
#line 185
__m128i _mm_rot_epi16(__m128i, __m128i); 
#line 186
__m128i _mm_rot_epi32(__m128i, __m128i); 
#line 187
__m128i _mm_rot_epi64(__m128i, __m128i); 
#line 188
__m128i _mm_roti_epi8(__m128i, int); 
#line 189
__m128i _mm_roti_epi16(__m128i, int); 
#line 190
__m128i _mm_roti_epi32(__m128i, int); 
#line 191
__m128i _mm_roti_epi64(__m128i, int); 
#line 192
__m128i _mm_shl_epi8(__m128i, __m128i); 
#line 193
__m128i _mm_shl_epi16(__m128i, __m128i); 
#line 194
__m128i _mm_shl_epi32(__m128i, __m128i); 
#line 195
__m128i _mm_shl_epi64(__m128i, __m128i); 
#line 196
__m128i _mm_sha_epi8(__m128i, __m128i); 
#line 197
__m128i _mm_sha_epi16(__m128i, __m128i); 
#line 198
__m128i _mm_sha_epi32(__m128i, __m128i); 
#line 199
__m128i _mm_sha_epi64(__m128i, __m128i); 
#line 203
__m128i _mm_com_epu8(__m128i, __m128i, int); 
#line 204
__m128i _mm_com_epu16(__m128i, __m128i, int); 
#line 205
__m128i _mm_com_epu32(__m128i, __m128i, int); 
#line 206
__m128i _mm_com_epu64(__m128i, __m128i, int); 
#line 207
__m128i _mm_com_epi8(__m128i, __m128i, int); 
#line 208
__m128i _mm_com_epi16(__m128i, __m128i, int); 
#line 209
__m128i _mm_com_epi32(__m128i, __m128i, int); 
#line 210
__m128i _mm_com_epi64(__m128i, __m128i, int); 
#line 214
__m128 _mm_frcz_ps(__m128); 
#line 215
__m128d _mm_frcz_pd(__m128d); 
#line 216
__m128 _mm_frcz_ss(__m128, __m128); 
#line 217
__m128d _mm_frcz_sd(__m128d, __m128d); 
#line 226
__m128 _mm_permute2_ps(__m128, __m128, __m128i, int); 
#line 227
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int); 
#line 231
__m256 _mm256_macc_ps(__m256, __m256, __m256); 
#line 232
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d); 
#line 233
__m256 _mm256_maddsub_ps(__m256, __m256, __m256); 
#line 234
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d); 
#line 235
__m256 _mm256_msubadd_ps(__m256, __m256, __m256); 
#line 236
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d); 
#line 237
__m256 _mm256_msub_ps(__m256, __m256, __m256); 
#line 238
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d); 
#line 239
__m256 _mm256_nmacc_ps(__m256, __m256, __m256); 
#line 240
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d); 
#line 241
__m256 _mm256_nmsub_ps(__m256, __m256, __m256); 
#line 242
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d); 
#line 243
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i); 
#line 244
__m256 _mm256_frcz_ps(__m256); 
#line 245
__m256d _mm256_frcz_pd(__m256d); 
#line 246
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int); 
#line 247
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int); 
#line 250
void __llwpcb(void *); 
#line 251
void *__slwpcb(); 
#line 252
void __lwpval32(unsigned, unsigned, unsigned); 
#line 253
unsigned char __lwpins32(unsigned, unsigned, unsigned); 
#line 255
void __lwpval64(unsigned __int64, unsigned, unsigned); 
#line 256
unsigned char __lwpins64(unsigned __int64, unsigned, unsigned); 
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h"
unsigned _bextr_u32(unsigned, unsigned, unsigned); 
#line 261
unsigned _andn_u32(unsigned, unsigned); 
#line 262
unsigned _tzcnt_u32(unsigned); 
#line 263
unsigned _lzcnt_u32(unsigned); 
#line 264
unsigned _blsr_u32(unsigned); 
#line 265
unsigned _blsmsk_u32(unsigned); 
#line 266
unsigned _blsi_u32(unsigned); 
#line 268
unsigned __int64 _bextr_u64(unsigned __int64, unsigned, unsigned); 
#line 269
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64); 
#line 270
unsigned __int64 _tzcnt_u64(unsigned __int64); 
#line 271
unsigned __int64 _lzcnt_u64(unsigned __int64); 
#line 272
unsigned __int64 _blsr_u64(unsigned __int64); 
#line 273
unsigned __int64 _blsmsk_u64(unsigned __int64); 
#line 274
unsigned __int64 _blsi_u64(unsigned __int64); 
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h"
unsigned _bextri_u32(unsigned, unsigned); 
#line 279
unsigned _blcfill_u32(unsigned); 
#line 280
unsigned _blsfill_u32(unsigned); 
#line 281
unsigned _blcs_u32(unsigned); 
#line 282
unsigned _tzmsk_u32(unsigned); 
#line 283
unsigned _blcic_u32(unsigned); 
#line 284
unsigned _blsic_u32(unsigned); 
#line 285
unsigned _t1mskc_u32(unsigned); 
#line 286
unsigned _blcmsk_u32(unsigned); 
#line 287
unsigned _blci_u32(unsigned); 
#line 289
unsigned __int64 _bextri_u64(unsigned __int64, unsigned); 
#line 290
unsigned __int64 _blcfill_u64(unsigned __int64); 
#line 291
unsigned __int64 _blsfill_u64(unsigned __int64); 
#line 292
unsigned __int64 _blcs_u64(unsigned __int64); 
#line 293
unsigned __int64 _tzmsk_u64(unsigned __int64); 
#line 294
unsigned __int64 _blcic_u64(unsigned __int64); 
#line 295
unsigned __int64 _blsic_u64(unsigned __int64); 
#line 296
unsigned __int64 _t1mskc_u64(unsigned __int64); 
#line 297
unsigned __int64 _blcmsk_u64(unsigned __int64); 
#line 298
unsigned __int64 _blci_u64(unsigned __int64); 
#line 301 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\ammintrin.h"
void _mm_monitorx(const void *, unsigned, unsigned); 
#line 302
void _mm_mwaitx(unsigned, unsigned, unsigned); 
#line 304
void _mm_clzero(const void *); 
#line 307
}
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h"
extern "C" {
#line 129 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\intrin.h"
void *_AddressOfReturnAddress(); 
#line 130
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask); 
#line 131
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 133
unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask); 
#line 134
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 159
long _InterlockedAnd(volatile long * _Value, long _Mask); 
#line 160
short _InterlockedAnd16(volatile short * _Value, short _Mask); 
#line 163
short _InterlockedAnd16_np(volatile short * _Value, short _Mask); 
#line 165
__int64 _InterlockedAnd64(volatile __int64 * _Value, __int64 _Mask); 
#line 168
__int64 _InterlockedAnd64_np(volatile __int64 * _Value, __int64 _Mask); 
#line 170
char _InterlockedAnd8(volatile char * _Value, char _Mask); 
#line 173
char _InterlockedAnd8_np(volatile char * _Value, char _Mask); 
#line 177
long _InterlockedAnd_np(volatile long * _Value, long _Mask); 
#line 179
long _InterlockedCompareExchange(volatile long * _Destination, long _Exchange, long _Comparand); 
#line 181
unsigned char _InterlockedCompareExchange128(volatile __int64 * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult); 
#line 184
unsigned char _InterlockedCompareExchange128_np(volatile __int64 * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult); 
#line 186
short _InterlockedCompareExchange16(volatile short * _Destination, short _Exchange, short _Comparand); 
#line 189
short _InterlockedCompareExchange16_np(volatile short * _Destination, short _Exchange, short _Comparand); 
#line 191
__int64 _InterlockedCompareExchange64(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); 
#line 194
__int64 _InterlockedCompareExchange64_np(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); 
#line 196
char _InterlockedCompareExchange8(volatile char * _Destination, char _Exchange, char _Comparand); 
#line 200
void *_InterlockedCompareExchangePointer(void *volatile * _Destination, void * _Exchange, void * _Comparand); 
#line 203
void *_InterlockedCompareExchangePointer_np(void *volatile * _Destination, void * _Exchange, void * _Comparand); 
#line 207
long _InterlockedCompareExchange_np(volatile long * _Destination, long _Exchange, long _Comparand); 
#line 209
long _InterlockedDecrement(volatile long * _Addend); 
#line 211
short _InterlockedDecrement16(volatile short * _Addend); 
#line 215
__int64 _InterlockedDecrement64(volatile __int64 * _Addend); 
#line 222
long _InterlockedExchange(volatile long * _Target, long _Value); 
#line 224
short _InterlockedExchange16(volatile short * _Target, short _Value); 
#line 228
__int64 _InterlockedExchange64(volatile __int64 * _Target, __int64 _Value); 
#line 232
char _InterlockedExchange8(volatile char * _Target, char _Value); 
#line 236
long _InterlockedExchangeAdd(volatile long * _Addend, long _Value); 
#line 237
short _InterlockedExchangeAdd16(volatile short * _Addend, short _Value); 
#line 241
__int64 _InterlockedExchangeAdd64(volatile __int64 * _Addend, __int64 _Value); 
#line 245
char _InterlockedExchangeAdd8(volatile char * _Addend, char _Value); 
#line 252
void *_InterlockedExchangePointer(void *volatile * _Target, void * _Value); 
#line 259
long _InterlockedIncrement(volatile long * _Addend); 
#line 261
short _InterlockedIncrement16(volatile short * _Addend); 
#line 265
__int64 _InterlockedIncrement64(volatile __int64 * _Addend); 
#line 272
long _InterlockedOr(volatile long * _Value, long _Mask); 
#line 273
short _InterlockedOr16(volatile short * _Value, short _Mask); 
#line 276
short _InterlockedOr16_np(volatile short * _Value, short _Mask); 
#line 278
__int64 _InterlockedOr64(volatile __int64 * _Value, __int64 _Mask); 
#line 281
__int64 _InterlockedOr64_np(volatile __int64 * _Value, __int64 _Mask); 
#line 283
char _InterlockedOr8(volatile char * _Value, char _Mask); 
#line 286
char _InterlockedOr8_np(volatile char * _Value, char _Mask); 
#line 290
long _InterlockedOr_np(volatile long * _Value, long _Mask); 
#line 292
long _InterlockedXor(volatile long * _Value, long _Mask); 
#line 293
short _InterlockedXor16(volatile short * _Value, short _Mask); 
#line 296
short _InterlockedXor16_np(volatile short * _Value, short _Mask); 
#line 298
__int64 _InterlockedXor64(volatile __int64 * _Value, __int64 _Mask); 
#line 301
__int64 _InterlockedXor64_np(volatile __int64 * _Value, __int64 _Mask); 
#line 303
char _InterlockedXor8(volatile char * _Value, char _Mask); 
#line 306
char _InterlockedXor8_np(volatile char * _Value, char _Mask); 
#line 310
long _InterlockedXor_np(volatile long * _Value, long _Mask); 
#line 320
void _ReadBarrier(); 
#line 327
void _ReadWriteBarrier(); 
#line 328
void *_ReturnAddress(); 
#line 330
void _WriteBarrier(); 
#line 340
void __addgsbyte(unsigned long, unsigned char); 
#line 341
void __addgsdword(unsigned long, unsigned long); 
#line 342
void __addgsqword(unsigned long, unsigned __int64); 
#line 343
void __addgsword(unsigned long, unsigned short); 
#line 348
void __code_seg(const char *); 
#line 349
void __cpuid(int [4], int); 
#line 350
void __cpuidex(int [4], int, int); 
#line 351
void __cdecl __debugbreak(); 
#line 353
__int64 __emul(int, int); 
#line 354
unsigned __int64 __emulu(unsigned, unsigned); 
#line 355
__declspec(noreturn) void __fastfail(unsigned); 
#line 356
void __faststorefence(); 
#line 357
unsigned __getcallerseflags(); 
#line 358
void __halt(); 
#line 361
unsigned char __inbyte(unsigned short); 
#line 362
void __inbytestring(unsigned short, unsigned char *, unsigned long); 
#line 366
void __incgsbyte(unsigned long); 
#line 367
void __incgsdword(unsigned long); 
#line 368
void __incgsqword(unsigned long); 
#line 369
void __incgsword(unsigned long); 
#line 374
unsigned long __indword(unsigned short); 
#line 375
void __indwordstring(unsigned short, unsigned long *, unsigned long); 
#line 376
void __int2c(); 
#line 377
void __invlpg(void *); 
#line 378
unsigned short __inword(unsigned short); 
#line 379
void __inwordstring(unsigned short, unsigned short *, unsigned long); 
#line 389
void __lidt(void *); 
#line 390
unsigned __int64 __ll_lshift(unsigned __int64, int); 
#line 391
__int64 __ll_rshift(__int64, int); 
#line 392
unsigned __lzcnt(unsigned); 
#line 393
unsigned short __lzcnt16(unsigned short); 
#line 394
unsigned __int64 __lzcnt64(unsigned __int64); 
#line 395
void __movsb(unsigned char *, const unsigned char *, size_t); 
#line 396
void __movsd(unsigned long *, const unsigned long *, size_t); 
#line 397
void __movsq(unsigned __int64 *, const unsigned __int64 *, size_t); 
#line 398
void __movsw(unsigned short *, const unsigned short *, size_t); 
#line 399
__int64 __mulh(__int64, __int64); 
#line 400
void __nop(); 
#line 401
void __nvreg_restore_fence(); 
#line 402
void __nvreg_save_fence(); 
#line 403
void __outbyte(unsigned short, unsigned char); 
#line 404
void __outbytestring(unsigned short, unsigned char *, unsigned long); 
#line 405
void __outdword(unsigned short, unsigned long); 
#line 406
void __outdwordstring(unsigned short, unsigned long *, unsigned long); 
#line 407
void __outword(unsigned short, unsigned short); 
#line 408
void __outwordstring(unsigned short, unsigned short *, unsigned long); 
#line 409
unsigned __popcnt(unsigned); 
#line 410
unsigned short __popcnt16(unsigned short); 
#line 411
unsigned __int64 __popcnt64(unsigned __int64); 
#line 415
unsigned __int64 __rdtsc(); 
#line 416
unsigned __int64 __rdtscp(unsigned *); 
#line 417
unsigned __int64 __readcr0(); 
#line 419
unsigned __int64 __readcr2(); 
#line 421
unsigned __int64 __readcr3(); 
#line 423
unsigned __int64 __readcr4(); 
#line 425
unsigned __int64 __readcr8(); 
#line 427
unsigned __int64 __readdr(unsigned); 
#line 429
unsigned __int64 __readeflags(); 
#line 435
unsigned char __readgsbyte(unsigned long); 
#line 436
unsigned long __readgsdword(unsigned long); 
#line 437
unsigned __int64 __readgsqword(unsigned long); 
#line 438
unsigned short __readgsword(unsigned long); 
#line 439
unsigned __int64 __readmsr(unsigned long); 
#line 440
unsigned __int64 __readpmc(unsigned long); 
#line 445
unsigned long __segmentlimit(unsigned long); 
#line 447
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift); 
#line 448
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift); 
#line 449
void __sidt(void *); 
#line 451
void __stosb(unsigned char *, unsigned char, size_t); 
#line 452
void __stosd(unsigned long *, unsigned long, size_t); 
#line 453
void __stosq(unsigned __int64 *, unsigned __int64, size_t); 
#line 454
void __stosw(unsigned short *, unsigned short, size_t); 
#line 455
void __svm_clgi(); 
#line 456
void __svm_invlpga(void *, int); 
#line 457
void __svm_skinit(int); 
#line 458
void __svm_stgi(); 
#line 459
void __svm_vmload(size_t); 
#line 460
void __svm_vmrun(size_t); 
#line 461
void __svm_vmsave(size_t); 
#line 467
void __ud2(); 
#line 468
unsigned __int64 __ull_rshift(unsigned __int64, int); 
#line 469
unsigned __int64 __umulh(unsigned __int64, unsigned __int64); 
#line 470
void __vmx_off(); 
#line 471
unsigned char __vmx_on(unsigned __int64 *); 
#line 472
unsigned char __vmx_vmclear(unsigned __int64 *); 
#line 473
unsigned char __vmx_vmlaunch(); 
#line 474
unsigned char __vmx_vmptrld(unsigned __int64 *); 
#line 475
void __vmx_vmptrst(unsigned __int64 *); 
#line 476
unsigned char __vmx_vmread(size_t, size_t *); 
#line 477
unsigned char __vmx_vmresume(); 
#line 478
unsigned char __vmx_vmwrite(size_t, size_t); 
#line 479
void __wbinvd(); 
#line 482
void __writecr0(unsigned __int64); 
#line 484
void __writecr3(unsigned __int64); 
#line 486
void __writecr4(unsigned __int64); 
#line 488
void __writecr8(unsigned __int64); 
#line 490
void __writedr(unsigned, unsigned __int64); 
#line 492
void __writeeflags(unsigned __int64); 
#line 498
void __writegsbyte(unsigned long, unsigned char); 
#line 499
void __writegsdword(unsigned long, unsigned long); 
#line 500
void __writegsqword(unsigned long, unsigned __int64); 
#line 501
void __writegsword(unsigned long, unsigned short); 
#line 502
void __writemsr(unsigned long, unsigned __int64); 
#line 508
unsigned char _bittest(const long *, long); 
#line 509
unsigned char _bittest64(const __int64 *, __int64); 
#line 510
unsigned char _bittestandcomplement(long *, long); 
#line 511
unsigned char _bittestandcomplement64(__int64 *, __int64); 
#line 512
unsigned char _bittestandreset(long *, long); 
#line 513
unsigned char _bittestandreset64(__int64 *, __int64); 
#line 514
unsigned char _bittestandset(long *, long); 
#line 515
unsigned char _bittestandset64(__int64 *, __int64); 
#line 516
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64); 
#line 517
unsigned long __cdecl _byteswap_ulong(unsigned long); 
#line 518
unsigned short __cdecl _byteswap_ushort(unsigned short); 
#line 519
void __cdecl _disable(); 
#line 520
void __cdecl _enable(); 
#line 521
unsigned char _interlockedbittestandreset(volatile long *, long); 
#line 522
unsigned char _interlockedbittestandreset64(volatile __int64 *, __int64); 
#line 529
unsigned char _interlockedbittestandset(volatile long *, long); 
#line 530
unsigned char _interlockedbittestandset64(volatile __int64 *, __int64); 
#line 547
unsigned long __cdecl _lrotl(unsigned long, int); 
#line 548
unsigned long __cdecl _lrotr(unsigned long, int); 
#line 609
void _m_prefetch(void *); 
#line 610
void _m_prefetchw(const volatile void *); 
#line 646
__m128i _mm_abs_epi16(__m128i); 
#line 647
__m128i _mm_abs_epi32(__m128i); 
#line 648
__m128i _mm_abs_epi8(__m128i); 
#line 652
__m128i _mm_add_epi16(__m128i, __m128i); 
#line 653
__m128i _mm_add_epi32(__m128i, __m128i); 
#line 654
__m128i _mm_add_epi64(__m128i, __m128i); 
#line 655
__m128i _mm_add_epi8(__m128i, __m128i); 
#line 656
__m128d _mm_add_pd(__m128d, __m128d); 
#line 657
__m128 _mm_add_ps(__m128, __m128); 
#line 658
__m128d _mm_add_sd(__m128d, __m128d); 
#line 660
__m128 _mm_add_ss(__m128, __m128); 
#line 661
__m128i _mm_adds_epi16(__m128i, __m128i); 
#line 662
__m128i _mm_adds_epi8(__m128i, __m128i); 
#line 663
__m128i _mm_adds_epu16(__m128i, __m128i); 
#line 664
__m128i _mm_adds_epu8(__m128i, __m128i); 
#line 665
__m128d _mm_addsub_pd(__m128d, __m128d); 
#line 666
__m128 _mm_addsub_ps(__m128, __m128); 
#line 667
__m128i _mm_alignr_epi8(__m128i, __m128i, int); 
#line 669
__m128d _mm_and_pd(__m128d, __m128d); 
#line 670
__m128 _mm_and_ps(__m128, __m128); 
#line 671
__m128i _mm_and_si128(__m128i, __m128i); 
#line 672
__m128d _mm_andnot_pd(__m128d, __m128d); 
#line 673
__m128 _mm_andnot_ps(__m128, __m128); 
#line 674
__m128i _mm_andnot_si128(__m128i, __m128i); 
#line 675
__m128i _mm_avg_epu16(__m128i, __m128i); 
#line 676
__m128i _mm_avg_epu8(__m128i, __m128i); 
#line 677
__m128i _mm_blend_epi16(__m128i, __m128i, int); 
#line 678
__m128d _mm_blend_pd(__m128d, __m128d, int); 
#line 679
__m128 _mm_blend_ps(__m128, __m128, int); 
#line 680
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i); 
#line 681
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d); 
#line 682
__m128 _mm_blendv_ps(__m128, __m128, __m128); 
#line 683
void _mm_clflush(const void *); 
#line 684
void _mm_clflushopt(const void *); 
#line 685
void _mm_clwb(const void *); 
#line 686
void _mm_clzero(const void *); 
#line 687
__m128i _mm_cmpeq_epi16(__m128i, __m128i); 
#line 688
__m128i _mm_cmpeq_epi32(__m128i, __m128i); 
#line 689
__m128i _mm_cmpeq_epi64(__m128i, __m128i); 
#line 690
__m128i _mm_cmpeq_epi8(__m128i, __m128i); 
#line 691
__m128d _mm_cmpeq_pd(__m128d, __m128d); 
#line 692
__m128 _mm_cmpeq_ps(__m128, __m128); 
#line 693
__m128d _mm_cmpeq_sd(__m128d, __m128d); 
#line 694
__m128 _mm_cmpeq_ss(__m128, __m128); 
#line 695
int _mm_cmpestra(__m128i, int, __m128i, int, int); 
#line 696
int _mm_cmpestrc(__m128i, int, __m128i, int, int); 
#line 697
int _mm_cmpestri(__m128i, int, __m128i, int, int); 
#line 698
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int); 
#line 699
int _mm_cmpestro(__m128i, int, __m128i, int, int); 
#line 700
int _mm_cmpestrs(__m128i, int, __m128i, int, int); 
#line 701
int _mm_cmpestrz(__m128i, int, __m128i, int, int); 
#line 702
__m128d _mm_cmpge_pd(__m128d, __m128d); 
#line 703
__m128 _mm_cmpge_ps(__m128, __m128); 
#line 704
__m128d _mm_cmpge_sd(__m128d, __m128d); 
#line 705
__m128 _mm_cmpge_ss(__m128, __m128); 
#line 706
__m128i _mm_cmpgt_epi16(__m128i, __m128i); 
#line 707
__m128i _mm_cmpgt_epi32(__m128i, __m128i); 
#line 708
__m128i _mm_cmpgt_epi64(__m128i, __m128i); 
#line 709
__m128i _mm_cmpgt_epi8(__m128i, __m128i); 
#line 710
__m128d _mm_cmpgt_pd(__m128d, __m128d); 
#line 711
__m128 _mm_cmpgt_ps(__m128, __m128); 
#line 712
__m128d _mm_cmpgt_sd(__m128d, __m128d); 
#line 713
__m128 _mm_cmpgt_ss(__m128, __m128); 
#line 714
int _mm_cmpistra(__m128i, __m128i, int); 
#line 715
int _mm_cmpistrc(__m128i, __m128i, int); 
#line 716
int _mm_cmpistri(__m128i, __m128i, int); 
#line 717
__m128i _mm_cmpistrm(__m128i, __m128i, int); 
#line 718
int _mm_cmpistro(__m128i, __m128i, int); 
#line 719
int _mm_cmpistrs(__m128i, __m128i, int); 
#line 720
int _mm_cmpistrz(__m128i, __m128i, int); 
#line 721
__m128d _mm_cmple_pd(__m128d, __m128d); 
#line 722
__m128 _mm_cmple_ps(__m128, __m128); 
#line 723
__m128d _mm_cmple_sd(__m128d, __m128d); 
#line 724
__m128 _mm_cmple_ss(__m128, __m128); 
#line 725
__m128i _mm_cmplt_epi16(__m128i, __m128i); 
#line 726
__m128i _mm_cmplt_epi32(__m128i, __m128i); 
#line 727
__m128i _mm_cmplt_epi8(__m128i, __m128i); 
#line 728
__m128d _mm_cmplt_pd(__m128d, __m128d); 
#line 729
__m128 _mm_cmplt_ps(__m128, __m128); 
#line 730
__m128d _mm_cmplt_sd(__m128d, __m128d); 
#line 731
__m128 _mm_cmplt_ss(__m128, __m128); 
#line 732
__m128d _mm_cmpneq_pd(__m128d, __m128d); 
#line 733
__m128 _mm_cmpneq_ps(__m128, __m128); 
#line 734
__m128d _mm_cmpneq_sd(__m128d, __m128d); 
#line 735
__m128 _mm_cmpneq_ss(__m128, __m128); 
#line 736
__m128d _mm_cmpnge_pd(__m128d, __m128d); 
#line 737
__m128 _mm_cmpnge_ps(__m128, __m128); 
#line 738
__m128d _mm_cmpnge_sd(__m128d, __m128d); 
#line 739
__m128 _mm_cmpnge_ss(__m128, __m128); 
#line 740
__m128d _mm_cmpngt_pd(__m128d, __m128d); 
#line 741
__m128 _mm_cmpngt_ps(__m128, __m128); 
#line 742
__m128d _mm_cmpngt_sd(__m128d, __m128d); 
#line 743
__m128 _mm_cmpngt_ss(__m128, __m128); 
#line 744
__m128d _mm_cmpnle_pd(__m128d, __m128d); 
#line 745
__m128 _mm_cmpnle_ps(__m128, __m128); 
#line 746
__m128d _mm_cmpnle_sd(__m128d, __m128d); 
#line 747
__m128 _mm_cmpnle_ss(__m128, __m128); 
#line 748
__m128d _mm_cmpnlt_pd(__m128d, __m128d); 
#line 749
__m128 _mm_cmpnlt_ps(__m128, __m128); 
#line 750
__m128d _mm_cmpnlt_sd(__m128d, __m128d); 
#line 751
__m128 _mm_cmpnlt_ss(__m128, __m128); 
#line 752
__m128d _mm_cmpord_pd(__m128d, __m128d); 
#line 753
__m128 _mm_cmpord_ps(__m128, __m128); 
#line 754
__m128d _mm_cmpord_sd(__m128d, __m128d); 
#line 755
__m128 _mm_cmpord_ss(__m128, __m128); 
#line 756
__m128d _mm_cmpunord_pd(__m128d, __m128d); 
#line 757
__m128 _mm_cmpunord_ps(__m128, __m128); 
#line 758
__m128d _mm_cmpunord_sd(__m128d, __m128d); 
#line 759
__m128 _mm_cmpunord_ss(__m128, __m128); 
#line 760
int _mm_comieq_sd(__m128d, __m128d); 
#line 761
int _mm_comieq_ss(__m128, __m128); 
#line 762
int _mm_comige_sd(__m128d, __m128d); 
#line 763
int _mm_comige_ss(__m128, __m128); 
#line 764
int _mm_comigt_sd(__m128d, __m128d); 
#line 765
int _mm_comigt_ss(__m128, __m128); 
#line 766
int _mm_comile_sd(__m128d, __m128d); 
#line 767
int _mm_comile_ss(__m128, __m128); 
#line 768
int _mm_comilt_sd(__m128d, __m128d); 
#line 769
int _mm_comilt_ss(__m128, __m128); 
#line 770
int _mm_comineq_sd(__m128d, __m128d); 
#line 771
int _mm_comineq_ss(__m128, __m128); 
#line 772
unsigned _mm_crc32_u16(unsigned, unsigned short); 
#line 773
unsigned _mm_crc32_u32(unsigned, unsigned); 
#line 774
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64); 
#line 775
unsigned _mm_crc32_u8(unsigned, unsigned char); 
#line 778
__m128 _mm_cvt_si2ss(__m128, int); 
#line 779
int _mm_cvt_ss2si(__m128); 
#line 780
__m128i _mm_cvtepi16_epi32(__m128i); 
#line 781
__m128i _mm_cvtepi16_epi64(__m128i); 
#line 782
__m128i _mm_cvtepi32_epi64(__m128i); 
#line 783
__m128d _mm_cvtepi32_pd(__m128i); 
#line 784
__m128 _mm_cvtepi32_ps(__m128i); 
#line 785
__m128i _mm_cvtepi8_epi16(__m128i); 
#line 786
__m128i _mm_cvtepi8_epi32(__m128i); 
#line 787
__m128i _mm_cvtepi8_epi64(__m128i); 
#line 788
__m128i _mm_cvtepu16_epi32(__m128i); 
#line 789
__m128i _mm_cvtepu16_epi64(__m128i); 
#line 790
__m128i _mm_cvtepu32_epi64(__m128i); 
#line 791
__m128i _mm_cvtepu8_epi16(__m128i); 
#line 792
__m128i _mm_cvtepu8_epi32(__m128i); 
#line 793
__m128i _mm_cvtepu8_epi64(__m128i); 
#line 794
__m128i _mm_cvtpd_epi32(__m128d); 
#line 796
__m128 _mm_cvtpd_ps(__m128d); 
#line 798
__m128i _mm_cvtps_epi32(__m128); 
#line 799
__m128d _mm_cvtps_pd(__m128); 
#line 800
int _mm_cvtsd_si32(__m128d); 
#line 801
__int64 _mm_cvtsd_si64(__m128d); 
#line 802
__int64 _mm_cvtsd_si64x(__m128d); 
#line 803
__m128 _mm_cvtsd_ss(__m128, __m128d); 
#line 804
int _mm_cvtsi128_si32(__m128i); 
#line 805
__int64 _mm_cvtsi128_si64(__m128i); 
#line 806
__int64 _mm_cvtsi128_si64x(__m128i); 
#line 807
__m128d _mm_cvtsi32_sd(__m128d, int); 
#line 808
__m128i _mm_cvtsi32_si128(int); 
#line 809
__m128d _mm_cvtsi64_sd(__m128d, __int64); 
#line 810
__m128i _mm_cvtsi64_si128(__int64); 
#line 811
__m128 _mm_cvtsi64_ss(__m128, __int64); 
#line 812
__m128d _mm_cvtsi64x_sd(__m128d, __int64); 
#line 813
__m128i _mm_cvtsi64x_si128(__int64); 
#line 814
__m128 _mm_cvtsi64x_ss(__m128, __int64); 
#line 815
__m128d _mm_cvtss_sd(__m128d, __m128); 
#line 816
__int64 _mm_cvtss_si64(__m128); 
#line 817
__int64 _mm_cvtss_si64x(__m128); 
#line 819
int _mm_cvtt_ss2si(__m128); 
#line 820
__m128i _mm_cvttpd_epi32(__m128d); 
#line 822
__m128i _mm_cvttps_epi32(__m128); 
#line 823
int _mm_cvttsd_si32(__m128d); 
#line 824
__int64 _mm_cvttsd_si64(__m128d); 
#line 825
__int64 _mm_cvttsd_si64x(__m128d); 
#line 826
__int64 _mm_cvttss_si64(__m128); 
#line 827
__int64 _mm_cvttss_si64x(__m128); 
#line 828
__m128d _mm_div_pd(__m128d, __m128d); 
#line 829
__m128 _mm_div_ps(__m128, __m128); 
#line 830
__m128d _mm_div_sd(__m128d, __m128d); 
#line 831
__m128 _mm_div_ss(__m128, __m128); 
#line 832
__m128d _mm_dp_pd(__m128d, __m128d, int); 
#line 833
__m128 _mm_dp_ps(__m128, __m128, int); 
#line 834
int _mm_extract_epi16(__m128i, int); 
#line 835
int _mm_extract_epi32(__m128i, int); 
#line 836
__int64 _mm_extract_epi64(__m128i, int); 
#line 837
int _mm_extract_epi8(__m128i, int); 
#line 838
int _mm_extract_ps(__m128, int); 
#line 839
__m128i _mm_extract_si64(__m128i, __m128i); 
#line 840
__m128i _mm_extracti_si64(__m128i, int, int); 
#line 841
unsigned _mm_getcsr(); 
#line 842
__m128i _mm_hadd_epi16(__m128i, __m128i); 
#line 843
__m128i _mm_hadd_epi32(__m128i, __m128i); 
#line 844
__m128d _mm_hadd_pd(__m128d, __m128d); 
#line 847
__m128 _mm_hadd_ps(__m128, __m128); 
#line 848
__m128i _mm_hadds_epi16(__m128i, __m128i); 
#line 850
__m128i _mm_hsub_epi16(__m128i, __m128i); 
#line 851
__m128i _mm_hsub_epi32(__m128i, __m128i); 
#line 852
__m128d _mm_hsub_pd(__m128d, __m128d); 
#line 855
__m128 _mm_hsub_ps(__m128, __m128); 
#line 856
__m128i _mm_hsubs_epi16(__m128i, __m128i); 
#line 858
__m128i _mm_insert_epi16(__m128i, int, int); 
#line 859
__m128i _mm_insert_epi32(__m128i, int, int); 
#line 860
__m128i _mm_insert_epi64(__m128i, __int64, int); 
#line 861
__m128i _mm_insert_epi8(__m128i, int, int); 
#line 862
__m128 _mm_insert_ps(__m128, __m128, int); 
#line 863
__m128i _mm_insert_si64(__m128i, __m128i); 
#line 864
__m128i _mm_inserti_si64(__m128i, __m128i, int, int); 
#line 865
__m128i _mm_lddqu_si128(const __m128i *); 
#line 866
void _mm_lfence(); 
#line 867
__m128d _mm_load1_pd(const double *); 
#line 868
__m128d _mm_load_pd(const double *); 
#line 869
__m128 _mm_load_ps(const float *); 
#line 870
__m128 _mm_load_ps1(const float *); 
#line 871
__m128d _mm_load_sd(const double *); 
#line 872
__m128i _mm_load_si128(const __m128i *); 
#line 873
__m128 _mm_load_ss(const float *); 
#line 874
__m128d _mm_loaddup_pd(const double *); 
#line 875
__m128d _mm_loadh_pd(__m128d, const double *); 
#line 876
__m128 _mm_loadh_pi(__m128, const __m64 *); 
#line 877
__m128i _mm_loadl_epi64(const __m128i *); 
#line 878
__m128d _mm_loadl_pd(__m128d, const double *); 
#line 879
__m128 _mm_loadl_pi(__m128, const __m64 *); 
#line 880
__m128d _mm_loadr_pd(const double *); 
#line 881
__m128 _mm_loadr_ps(const float *); 
#line 882
__m128d _mm_loadu_pd(const double *); 
#line 883
__m128 _mm_loadu_ps(const float *); 
#line 884
__m128i _mm_loadu_si128(const __m128i *); 
#line 885
__m128i _mm_madd_epi16(__m128i, __m128i); 
#line 886
__m128i _mm_maddubs_epi16(__m128i, __m128i); 
#line 888
void _mm_maskmoveu_si128(__m128i, __m128i, char *); 
#line 889
__m128i _mm_max_epi16(__m128i, __m128i); 
#line 890
__m128i _mm_max_epi32(__m128i, __m128i); 
#line 891
__m128i _mm_max_epi8(__m128i, __m128i); 
#line 892
__m128i _mm_max_epu16(__m128i, __m128i); 
#line 893
__m128i _mm_max_epu32(__m128i, __m128i); 
#line 894
__m128i _mm_max_epu8(__m128i, __m128i); 
#line 895
__m128d _mm_max_pd(__m128d, __m128d); 
#line 896
__m128 _mm_max_ps(__m128, __m128); 
#line 897
__m128d _mm_max_sd(__m128d, __m128d); 
#line 898
__m128 _mm_max_ss(__m128, __m128); 
#line 899
void _mm_mfence(); 
#line 900
__m128i _mm_min_epi16(__m128i, __m128i); 
#line 901
__m128i _mm_min_epi32(__m128i, __m128i); 
#line 902
__m128i _mm_min_epi8(__m128i, __m128i); 
#line 903
__m128i _mm_min_epu16(__m128i, __m128i); 
#line 904
__m128i _mm_min_epu32(__m128i, __m128i); 
#line 905
__m128i _mm_min_epu8(__m128i, __m128i); 
#line 906
__m128d _mm_min_pd(__m128d, __m128d); 
#line 907
__m128 _mm_min_ps(__m128, __m128); 
#line 908
__m128d _mm_min_sd(__m128d, __m128d); 
#line 909
__m128 _mm_min_ss(__m128, __m128); 
#line 910
__m128i _mm_minpos_epu16(__m128i); 
#line 911
void _mm_monitor(const void *, unsigned, unsigned); 
#line 912
__m128i _mm_move_epi64(__m128i); 
#line 913
__m128d _mm_move_sd(__m128d, __m128d); 
#line 914
__m128 _mm_move_ss(__m128, __m128); 
#line 915
__m128d _mm_movedup_pd(__m128d); 
#line 916
__m128 _mm_movehdup_ps(__m128); 
#line 917
__m128 _mm_movehl_ps(__m128, __m128); 
#line 918
__m128 _mm_moveldup_ps(__m128); 
#line 919
__m128 _mm_movelh_ps(__m128, __m128); 
#line 920
int _mm_movemask_epi8(__m128i); 
#line 921
int _mm_movemask_pd(__m128d); 
#line 922
int _mm_movemask_ps(__m128); 
#line 925
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int); 
#line 926
__m128i _mm_mul_epi32(__m128i, __m128i); 
#line 927
__m128i _mm_mul_epu32(__m128i, __m128i); 
#line 928
__m128d _mm_mul_pd(__m128d, __m128d); 
#line 929
__m128 _mm_mul_ps(__m128, __m128); 
#line 930
__m128d _mm_mul_sd(__m128d, __m128d); 
#line 931
__m128 _mm_mul_ss(__m128, __m128); 
#line 933
__m128i _mm_mulhi_epi16(__m128i, __m128i); 
#line 934
__m128i _mm_mulhi_epu16(__m128i, __m128i); 
#line 935
__m128i _mm_mulhrs_epi16(__m128i, __m128i); 
#line 937
__m128i _mm_mullo_epi16(__m128i, __m128i); 
#line 938
__m128i _mm_mullo_epi32(__m128i, __m128i); 
#line 939
void _mm_mwait(unsigned, unsigned); 
#line 940
__m128d _mm_or_pd(__m128d, __m128d); 
#line 941
__m128 _mm_or_ps(__m128, __m128); 
#line 942
__m128i _mm_or_si128(__m128i, __m128i); 
#line 943
__m128i _mm_packs_epi16(__m128i, __m128i); 
#line 944
__m128i _mm_packs_epi32(__m128i, __m128i); 
#line 945
__m128i _mm_packus_epi16(__m128i, __m128i); 
#line 946
__m128i _mm_packus_epi32(__m128i, __m128i); 
#line 947
void _mm_pause(); 
#line 948
int _mm_popcnt_u32(unsigned); 
#line 949
__int64 _mm_popcnt_u64(unsigned __int64); 
#line 950
void _mm_prefetch(const char *, int); 
#line 951
__m128 _mm_rcp_ps(__m128); 
#line 952
__m128 _mm_rcp_ss(__m128); 
#line 953
__m128d _mm_round_pd(__m128d, int); 
#line 954
__m128 _mm_round_ps(__m128, int); 
#line 955
__m128d _mm_round_sd(__m128d, __m128d, int); 
#line 956
__m128 _mm_round_ss(__m128, __m128, int); 
#line 957
__m128 _mm_rsqrt_ps(__m128); 
#line 958
__m128 _mm_rsqrt_ss(__m128); 
#line 959
__m128i _mm_sad_epu8(__m128i, __m128i); 
#line 960
__m128i _mm_set1_epi16(short); 
#line 961
__m128i _mm_set1_epi32(int); 
#line 963
__m128i _mm_set1_epi64x(__int64); 
#line 964
__m128i _mm_set1_epi8(char); 
#line 965
__m128d _mm_set1_pd(double); 
#line 969
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short); 
#line 970
__m128i _mm_set_epi32(int, int, int, int); 
#line 972
__m128i _mm_set_epi64x(__int64, __int64); 
#line 973
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 974
__m128d _mm_set_pd(double, double); 
#line 978
__m128 _mm_set_ps(float, float, float, float); 
#line 979
__m128 _mm_set_ps1(float); 
#line 980
__m128d _mm_set_sd(double); 
#line 981
__m128 _mm_set_ss(float); 
#line 982
void _mm_setcsr(unsigned); 
#line 983
__m128i _mm_setl_epi64(__m128i); 
#line 984
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short); 
#line 985
__m128i _mm_setr_epi32(int, int, int, int); 
#line 987
__m128i _mm_setr_epi64x(__int64, __int64); 
#line 988
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); 
#line 989
__m128d _mm_setr_pd(double, double); 
#line 993
__m128 _mm_setr_ps(float, float, float, float); 
#line 994
__m128d _mm_setzero_pd(); 
#line 995
__m128 _mm_setzero_ps(); 
#line 996
__m128i _mm_setzero_si128(); 
#line 998
void _mm_sfence(); 
#line 999
__m128i _mm_shuffle_epi32(__m128i, int); 
#line 1000
__m128i _mm_shuffle_epi8(__m128i, __m128i); 
#line 1001
__m128d _mm_shuffle_pd(__m128d, __m128d, int); 
#line 1003
__m128 _mm_shuffle_ps(__m128, __m128, unsigned); 
#line 1004
__m128i _mm_shufflehi_epi16(__m128i, int); 
#line 1005
__m128i _mm_shufflelo_epi16(__m128i, int); 
#line 1006
__m128i _mm_sign_epi16(__m128i, __m128i); 
#line 1007
__m128i _mm_sign_epi32(__m128i, __m128i); 
#line 1008
__m128i _mm_sign_epi8(__m128i, __m128i); 
#line 1012
__m128i _mm_sll_epi16(__m128i, __m128i); 
#line 1013
__m128i _mm_sll_epi32(__m128i, __m128i); 
#line 1014
__m128i _mm_sll_epi64(__m128i, __m128i); 
#line 1015
__m128i _mm_slli_epi16(__m128i, int); 
#line 1016
__m128i _mm_slli_epi32(__m128i, int); 
#line 1017
__m128i _mm_slli_epi64(__m128i, int); 
#line 1018
__m128i _mm_slli_si128(__m128i, int); 
#line 1019
__m128d _mm_sqrt_pd(__m128d); 
#line 1020
__m128 _mm_sqrt_ps(__m128); 
#line 1021
__m128d _mm_sqrt_sd(__m128d, __m128d); 
#line 1022
__m128 _mm_sqrt_ss(__m128); 
#line 1023
__m128i _mm_sra_epi16(__m128i, __m128i); 
#line 1024
__m128i _mm_sra_epi32(__m128i, __m128i); 
#line 1025
__m128i _mm_srai_epi16(__m128i, int); 
#line 1026
__m128i _mm_srai_epi32(__m128i, int); 
#line 1027
__m128i _mm_srl_epi16(__m128i, __m128i); 
#line 1028
__m128i _mm_srl_epi32(__m128i, __m128i); 
#line 1029
__m128i _mm_srl_epi64(__m128i, __m128i); 
#line 1030
__m128i _mm_srli_epi16(__m128i, int); 
#line 1031
__m128i _mm_srli_epi32(__m128i, int); 
#line 1032
__m128i _mm_srli_epi64(__m128i, int); 
#line 1033
__m128i _mm_srli_si128(__m128i, int); 
#line 1034
void _mm_store1_pd(double *, __m128d); 
#line 1035
void _mm_store_pd(double *, __m128d); 
#line 1036
void _mm_store_ps(float *, __m128); 
#line 1037
void _mm_store_ps1(float *, __m128); 
#line 1038
void _mm_store_sd(double *, __m128d); 
#line 1039
void _mm_store_si128(__m128i *, __m128i); 
#line 1040
void _mm_store_ss(float *, __m128); 
#line 1041
void _mm_storeh_pd(double *, __m128d); 
#line 1042
void _mm_storeh_pi(__m64 *, __m128); 
#line 1043
void _mm_storel_epi64(__m128i *, __m128i); 
#line 1044
void _mm_storel_pd(double *, __m128d); 
#line 1045
void _mm_storel_pi(__m64 *, __m128); 
#line 1046
void _mm_storer_pd(double *, __m128d); 
#line 1047
void _mm_storer_ps(float *, __m128); 
#line 1048
void _mm_storeu_pd(double *, __m128d); 
#line 1049
void _mm_storeu_ps(float *, __m128); 
#line 1050
void _mm_storeu_si128(__m128i *, __m128i); 
#line 1051
__m128i _mm_stream_load_si128(const __m128i *); 
#line 1052
void _mm_stream_pd(double *, __m128d); 
#line 1054
void _mm_stream_ps(float *, __m128); 
#line 1055
void _mm_stream_sd(double *, __m128d); 
#line 1056
void _mm_stream_si128(__m128i *, __m128i); 
#line 1057
void _mm_stream_si32(int *, int); 
#line 1058
void _mm_stream_si64x(__int64 *, __int64); 
#line 1059
void _mm_stream_ss(float *, __m128); 
#line 1060
__m128i _mm_sub_epi16(__m128i, __m128i); 
#line 1061
__m128i _mm_sub_epi32(__m128i, __m128i); 
#line 1062
__m128i _mm_sub_epi64(__m128i, __m128i); 
#line 1063
__m128i _mm_sub_epi8(__m128i, __m128i); 
#line 1064
__m128d _mm_sub_pd(__m128d, __m128d); 
#line 1065
__m128 _mm_sub_ps(__m128, __m128); 
#line 1066
__m128d _mm_sub_sd(__m128d, __m128d); 
#line 1068
__m128 _mm_sub_ss(__m128, __m128); 
#line 1069
__m128i _mm_subs_epi16(__m128i, __m128i); 
#line 1070
__m128i _mm_subs_epi8(__m128i, __m128i); 
#line 1071
__m128i _mm_subs_epu16(__m128i, __m128i); 
#line 1072
__m128i _mm_subs_epu8(__m128i, __m128i); 
#line 1073
int _mm_testc_si128(__m128i, __m128i); 
#line 1074
int _mm_testnzc_si128(__m128i, __m128i); 
#line 1075
int _mm_testz_si128(__m128i, __m128i); 
#line 1076
int _mm_ucomieq_sd(__m128d, __m128d); 
#line 1077
int _mm_ucomieq_ss(__m128, __m128); 
#line 1078
int _mm_ucomige_sd(__m128d, __m128d); 
#line 1079
int _mm_ucomige_ss(__m128, __m128); 
#line 1080
int _mm_ucomigt_sd(__m128d, __m128d); 
#line 1081
int _mm_ucomigt_ss(__m128, __m128); 
#line 1082
int _mm_ucomile_sd(__m128d, __m128d); 
#line 1083
int _mm_ucomile_ss(__m128, __m128); 
#line 1084
int _mm_ucomilt_sd(__m128d, __m128d); 
#line 1085
int _mm_ucomilt_ss(__m128, __m128); 
#line 1086
int _mm_ucomineq_sd(__m128d, __m128d); 
#line 1087
int _mm_ucomineq_ss(__m128, __m128); 
#line 1088
__m128i _mm_unpackhi_epi16(__m128i, __m128i); 
#line 1089
__m128i _mm_unpackhi_epi32(__m128i, __m128i); 
#line 1090
__m128i _mm_unpackhi_epi64(__m128i, __m128i); 
#line 1091
__m128i _mm_unpackhi_epi8(__m128i, __m128i); 
#line 1092
__m128d _mm_unpackhi_pd(__m128d, __m128d); 
#line 1093
__m128 _mm_unpackhi_ps(__m128, __m128); 
#line 1094
__m128i _mm_unpacklo_epi16(__m128i, __m128i); 
#line 1095
__m128i _mm_unpacklo_epi32(__m128i, __m128i); 
#line 1096
__m128i _mm_unpacklo_epi64(__m128i, __m128i); 
#line 1097
__m128i _mm_unpacklo_epi8(__m128i, __m128i); 
#line 1098
__m128d _mm_unpacklo_pd(__m128d, __m128d); 
#line 1099
__m128 _mm_unpacklo_ps(__m128, __m128); 
#line 1100
__m128d _mm_xor_pd(__m128d, __m128d); 
#line 1101
__m128 _mm_xor_ps(__m128, __m128); 
#line 1102
__m128i _mm_xor_si128(__m128i, __m128i); 
#line 1103
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct); 
#line 1104
unsigned __cdecl _rotl(unsigned _Value, int _Shift); 
#line 1105
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift); 
#line 1106
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); 
#line 1107
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift); 
#line 1108
unsigned __cdecl _rotr(unsigned _Value, int _Shift); 
#line 1109
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift); 
#line 1110
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); 
#line 1111
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift); 
#line 1112
int __cdecl _setjmp(jmp_buf); 
#line 1113
int __cdecl _setjmpex(jmp_buf); 
#line 1114
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct); 
#line 1115
void _rsm(); 
#line 1116
void _lgdt(void *); 
#line 1117
void _sgdt(void *); 
#line 1118
void _clac(); 
#line 1119
void _stac(); 
#line 1120
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *); 
#line 1121
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *); 
#line 1122
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *); 
#line 1123
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *); 
#line 1124
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned, unsigned, unsigned *); 
#line 1125
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned, unsigned, unsigned *); 
#line 1126
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 1127
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *); 
#line 1128
void _mm_monitorx(const void *, unsigned, unsigned); 
#line 1129
void _mm_mwaitx(unsigned, unsigned, unsigned); 
#line 1132
}
#line 1168 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4700)
#line 1169 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory0"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 17
template < class _Ty > inline
 pair < _Ty *, ptrdiff_t >
  get_temporary_buffer ( ptrdiff_t _Count ) noexcept
 {
 _Ty * _Pbuf;

 if ( _Count < 0 )
  _Count = 0;
 else if ( ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) < _Count ) )
  _Xbad_alloc ( );
 for ( _Pbuf = 0; 0 < _Count; _Count /= 2 )
  if ( ( _Pbuf = ( _Ty * ) operator new (
   ( size_t ) _Count * sizeof ( _Ty ), nothrow ) ) != 0 )
   break;

 return ( pair < _Ty *, ptrdiff_t > ( _Pbuf, _Count ) );
 }
#line 36
template < class _Ty > inline
 void return_temporary_buffer ( _Ty * _Pbuf )
 {
 operator delete ( _Pbuf );
 }
#line 43
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_unchecked1 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _General_ptr_iterator_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  _Construct ( _Unfancy ( _Dest ), * _First );
 } catch ( ... ) {
 _Destroy_range ( _Next, _Dest );
 throw;
 }

 return ( _Dest );
 }
#line 61
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_unchecked1 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 69
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_unchecked ( _InIt _First, _InIt _Last,
  _FwdIt _Dest )
 {
 return ( _Uninitialized_copy_unchecked1 ( _First, _Last,
  _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 78
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy1 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, input_iterator_tag, forward_iterator_tag )
 {
 return ( _Rechecked ( _Dest,
  _Uninitialized_copy_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 87
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy1 ( _InIt _First, _InIt _Last,
  _FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Uninitialized_copy_unchecked ( _First, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 97
template < class _InIt,
 class _FwdIt > inline
 _FwdIt uninitialized_copy ( _InIt _First, _InIt _Last,
  _FwdIt _Dest )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::uninitialized_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed" " values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checke" "d Iterators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 103 );
 return ( _Uninitialized_copy1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Iter_cat_t < _InIt > ( ), _Iter_cat_t < _FwdIt > ( ) ) );
 }
#line 109
template < class _InIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * uninitialized_copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: uninitialized_copy ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory"
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n_unchecked1 ( _InIt _First, _Diff _Count,
  _FwdIt _Dest, _General_ptr_iterator_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 for (; 0 < _Count; -- _Count, ( void ) ++ _Dest, ++ _First )
  _Construct ( _Unfancy ( _Dest ), * _First );
 } catch ( ... ) {
 _Destroy_range ( _Next, _Dest );
 throw;
 }

 return ( _Dest );
 }
#line 141
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n_unchecked1 ( _InIt _First, _Diff _Count,
  _FwdIt _Dest, _Really_trivial_ptr_iterator_tag )
 {
 if ( 0 < _Count )
  return ( _Copy_memmove ( _First, _First + _Count, _Dest ) );
 return ( _Dest );
 }
#line 152
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n_unchecked ( _InIt _First, _Diff _Count,
  _FwdIt _Dest )
 {
 return ( _Uninitialized_copy_n_unchecked1 ( _First, _Count,
  _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 162
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _FwdIt _Dest )
 {

 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::uninitialized_copy_n\' with parameters that may be unsafe - this call relies on the caller to check that the pass" "ed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Chec" "ked Iterators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Rechecked ( _Dest,
  _Uninitialized_copy_n_unchecked ( _Unchecked_n ( _First, _Count ), _Count, _Unchecked_n ( _Dest, _Count ) ) ) );
 }
#line 175
template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _FwdIt > inline
 _FwdIt uninitialized_copy_n ( _InTy ( & _First ) [ _InSize ], _Diff _Count,
  _FwdIt _Dest )
 {

 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::uninitialized_copy_n\' with parameters that may be unsafe - this call relies on the caller to check that the pass" "ed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Chec" "ked Iterators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_array_size2 ( _First, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 184 );
 return ( _Rechecked ( _Dest,
  _Uninitialized_copy_n_unchecked ( _First, _Count, _Unchecked_n ( _Dest, _Count ) ) ) );
 }
#line 189
template < class _InIt,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * uninitialized_copy_n ( _InIt _First, _Diff _Count,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 _Debug_array_size2 ( _Dest, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 196 );
 return ( _Uninitialized_copy_n_unchecked ( _Unchecked_n ( _First, _Count ), _Count, _Dest ) );
 }
#line 200
template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * uninitialized_copy_n ( _InTy ( & _First ) [ _InSize ], _Diff _Count,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 _Debug_array_size2 ( _First, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 208 );
 _Debug_array_size2 ( _Dest, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 209 );
 return ( _Uninitialized_copy_n_unchecked ( _First, _Count, _Dest ) );
 }
#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory"
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_copy_al_unchecked1 ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc < _Alloc > & _Al, _General_ptr_iterator_tag, _Any_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  _Al . construct ( _Unfancy ( _Dest ), * _First );
 } catch ( ... ) {
 _Destroy_range ( _Next, _Dest, _Al );
 throw;
 }

 return ( _Dest );
 }
#line 234
template < class _Ty1,
 class _Ty2,
 class _Alloc > inline
 _Ty2 * _Uninitialized_copy_al_unchecked1 ( _Ty1 * _First, _Ty1 * _Last, _Ty2 * _Dest,
  _Wrap_alloc < _Alloc > &, _Really_trivial_ptr_iterator_tag, true_type )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 243
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_copy_al_unchecked ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc < _Alloc > & _Al )
 {
 return ( _Uninitialized_copy_al_unchecked1 ( _First, _Last, _Dest, _Al,
  _Ptr_copy_cat ( _First, _Dest ),
  _Uses_default_construct_t < _Alloc, decltype ( _Unfancy ( _Dest ) ), decltype ( * _First ) > ( ) ) );
 }
#line 254
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_copy ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc < _Alloc > & _Al )
 {


 return ( _Rechecked ( _Dest,
  _Uninitialized_copy_al_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ), _Al ) ) );
 }
#line 268
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_move_al_unchecked1 ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc < _Alloc > & _Al, _General_ptr_iterator_tag, _Any_tag )
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  _Al . construct ( _Unfancy ( _Dest ), :: std :: move ( * _First ) );
 } catch ( ... ) {
 _Destroy_range ( _Next, _Dest, _Al );
 throw;
 }

 return ( _Dest );
 }
#line 287
template < class _Ty1,
 class _Ty2,
 class _Alloc > inline
 _Ty2 * _Uninitialized_move_al_unchecked1 ( _Ty1 * _First, _Ty1 * _Last, _Ty2 * _Dest,
  _Wrap_alloc < _Alloc > &, _Really_trivial_ptr_iterator_tag, true_type )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 296
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_move_al_unchecked ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc < _Alloc > & _Al )
 {
 typedef decltype ( :: std :: move ( * _First ) ) _Src_type;
 return ( _Uninitialized_move_al_unchecked1 ( _First, _Last, _Dest, _Al,
  _Ptr_move_cat ( _First, _Dest ),
  _Uses_default_construct_t < _Alloc, decltype ( _Unfancy ( _Dest ) ), _Src_type > ( ) ) );
 }
#line 308
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_move ( _InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc < _Alloc > & _Al )
 {


 return ( _Rechecked ( _Dest,
  _Uninitialized_move_al_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ), _Al ) ) );
 }
#line 322
template < class _FwdIt,
 class _Tval > inline
 void _Uninitialized_fill_unchecked1 ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val, false_type )
 {
 _FwdIt _Next = _First;

 try {
 for (; _First != _Last; ++ _First )
  _Construct ( _Unfancy ( _First ), _Val );
 } catch ( ... ) {
 _Destroy_range ( _Next, _First );
 throw;
 }
 }
#line 337
template < class _FwdIt,
 class _Tval > inline
 void _Uninitialized_fill_unchecked1 ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val, true_type )
 {
 :: memset ( _First, _Val, _Last - _First );
 }
#line 344
template < class _FwdIt,
 class _Tval > inline
 void _Uninitialized_fill_unchecked ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val )
 {
 _Uninitialized_fill_unchecked1 ( _First, _Last, _Val, _Fill_memset_is_safe ( _First, _Val ) );
 }
#line 351
template < class _FwdIt,
 class _Tval > inline
 void uninitialized_fill ( _FwdIt _First, _FwdIt _Last, const _Tval & _Val )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 355 );
 _Uninitialized_fill_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val );
 }
#line 360
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt _Uninitialized_fill_n_unchecked1 ( _FwdIt _First, _Diff _Count, const _Tval & _Val, false_type )
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ( void ) ++ _First )
  _Construct ( _Unfancy ( _First ), _Val );
 } catch ( ... ) {
 _Destroy_range ( _Next, _First );
 throw;
 }

 return ( _First );
 }
#line 378
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt _Uninitialized_fill_n_unchecked1 ( _FwdIt _First, _Diff _Count, const _Tval & _Val, true_type )
 {
 if ( 0 < _Count )
  {
  :: memset ( _First, _Val, _Count );
  return ( _First + _Count );
  }

 return ( _First );
 }
#line 392
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt _Uninitialized_fill_n_unchecked ( _FwdIt _First, _Diff _Count, const _Tval & _Val )
 {
 return ( _Uninitialized_fill_n_unchecked1 ( _First, _Count, _Val, _Fill_memset_is_safe ( _First, _Val ) ) );
 }
#line 400
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Tval & _Val )
 {
 return ( _Rechecked ( _First,
  _Uninitialized_fill_n_unchecked ( _Unchecked_n ( _First, _Count ), _Count, _Val ) ) );
 }
#line 411
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 void _Uninit_alloc_fill_n1 ( _FwdIt _First, _Diff _Count, const _Iter_value_t < _FwdIt > * _Pval,
  _Wrap_alloc < _Alloc > & _Al, false_type )
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ( void ) ++ _First )
  _Al . construct ( _Unfancy ( _First ), * _Pval );
 } catch ( ... ) {
 _Destroy_range ( _Next, _First, _Al );
 throw;
 }
 }
#line 428
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 void _Uninit_alloc_fill_n1 ( _FwdIt _First, _Diff _Count, const _Iter_value_t < _FwdIt > * _Pval,
  _Wrap_alloc < _Alloc > &, true_type )
 {
 :: memset ( _First, * _Pval, _Count );
 }
#line 437
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 void _Uninitialized_fill_n ( _FwdIt _First, _Diff _Count,
  const _Iter_value_t < _FwdIt > * _Pval, _Wrap_alloc < _Alloc > & _Al )
 {
 _Uninit_alloc_fill_n1 ( _First, _Count, _Pval, _Al,
  typename conjunction < decltype ( _Fill_memset_is_safe ( _First, * _Pval ) ),
   _Uses_default_construct < _Alloc, decltype ( _Unfancy ( _First ) ), decltype ( * _Pval ) >> :: type ( ) );
 }
#line 448
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 void _Uninitialized_default_fill_n1 ( _FwdIt _First, _Diff _Count,
  _Wrap_alloc < _Alloc > & _Al, false_type )
 {
 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; -- _Count, ( void ) ++ _First )
  _Al . construct ( _Unfancy ( _First ) );
 } catch ( ... ) {
 _Destroy_range ( _Next, _First, _Al );
 throw;
 }
 }
#line 465
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 void _Uninitialized_default_fill_n1 ( _FwdIt _First, _Diff _Count,
  _Wrap_alloc < _Alloc > &, true_type )
 {
 :: memset ( _First, 0, _Count * sizeof ( _Iter_value_t < _FwdIt > ) );
 }
#line 474
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 void _Uninitialized_default_fill_n ( _FwdIt _First, _Diff _Count,
  _Wrap_alloc < _Alloc > & _Al )
 {
 typedef _Iter_value_t < _FwdIt > _Ty;
 _Uninitialized_default_fill_n1 ( _First, _Count, _Al,
  typename conjunction <
   is_pointer < _FwdIt >,
   is_scalar < _Ty >,
   negation < is_volatile < _Ty >>,
   negation < is_member_pointer < _Ty >>,
   _Uses_default_construct < _Alloc, decltype ( _Unfancy ( _First ) ) >> :: type ( ) );
 }
#line 491
template < class _OutIt,
 class _Ty >
 class raw_storage_iterator
  : public _Outit
 {
public :
 explicit raw_storage_iterator ( _OutIt _First )
  : _Next ( _First )
  {
  }

 raw_storage_iterator & operator * ( )
  {
  return ( * this );
  }

 raw_storage_iterator & operator = ( const _Ty & _Val )
  {
  _Construct ( _Unfancy ( _Next ), _Val );
  return ( * this );
  }

 raw_storage_iterator & operator = ( _Ty && _Val )
  {
  _Construct ( _Unfancy ( _Next ), :: std :: move ( _Val ) );
  return ( * this );
  }

 raw_storage_iterator & operator ++ ( )
  {
  ++ _Next;
  return ( * this );
  }

 raw_storage_iterator operator ++ ( int )
  {
  raw_storage_iterator _Ans = * this;
  ++ _Next;
  return ( _Ans );
  }

 _OutIt base ( ) const
  {
  return ( _Next );
  }

private :
 _OutIt _Next;
 };
#line 542
template < class _Ty >
 class _Temp_iterator
  : public _Outit
 {
public :
 typedef _Ty * _Pty;

 _Temp_iterator ( ptrdiff_t _Count = 0 )
  {
  _Buf . _Begin = 0;
  _Buf . _Current = 0;
  _Buf . _Hiwater = 0;
  _Buf . _Size = _Count;
  _Pbuf = & _Buf;
  }

 _Temp_iterator ( const _Temp_iterator & _Right )
  {
  _Buf . _Begin = 0;
  _Buf . _Current = 0;
  _Buf . _Hiwater = 0;
  _Buf . _Size = 0;
  * this = _Right;
  }

 ~ _Temp_iterator ( ) noexcept
  {
  if ( _Buf . _Begin != 0 )
   {
   for ( _Pty _Next = _Buf . _Begin;
    _Next != _Buf . _Hiwater; ++ _Next )
    _Destroy ( _Next );
   :: std :: return_temporary_buffer ( _Buf . _Begin );
   }
  }

 _Temp_iterator & operator = ( const _Temp_iterator & _Right )
  {
  _Pbuf = _Right . _Pbuf;
  return ( * this );
  }

 _Temp_iterator & operator = ( const _Ty & _Val )
  {
  if ( _Pbuf -> _Current < _Pbuf -> _Hiwater )
   * _Pbuf -> _Current ++ = _Val;
  else
   {
   _Pty _Ptr = _Pbuf -> _Current;
   _Construct ( _Ptr, _Val );
   _Pbuf -> _Hiwater = ++ _Pbuf -> _Current;
   }

  return ( * this );
  }

 _Temp_iterator & operator = ( _Ty && _Val )
  {
  if ( _Pbuf -> _Current < _Pbuf -> _Hiwater )
   * _Pbuf -> _Current ++ =
    :: std :: forward < _Ty > ( _Val );
  else
   {
   _Pty _Ptr = _Pbuf -> _Current;
   _Construct ( _Ptr, :: std :: forward < _Ty > ( _Val ) );
   _Pbuf -> _Hiwater = ++ _Pbuf -> _Current;
   }

  return ( * this );
  }

 _Temp_iterator & operator * ( )
  {
  return ( * this );
  }

 _Temp_iterator & operator ++ ( )
  {
  return ( * this );
  }

 _Temp_iterator & operator ++ ( int )
  {
  return ( * this );
  }

 _Temp_iterator & _Init ( )
  {
  _Pbuf -> _Current = _Pbuf -> _Begin;
  return ( * this );
  }

 _Pty _First ( ) const
  {
  return ( _Pbuf -> _Begin );
  }

 _Pty _Last ( ) const
  {
  return ( _Pbuf -> _Current );
  }

 ptrdiff_t _Maxlen ( )
  {
  if ( _Pbuf -> _Begin == 0 && 0 < _Pbuf -> _Size )
   {
   pair < _Pty, ptrdiff_t > _Pair =

    :: std :: get_temporary_buffer < _Ty > ( _Pbuf -> _Size );

   _Pbuf -> _Begin = _Pair . first;
   _Pbuf -> _Current = _Pair . first;
   _Pbuf -> _Hiwater = _Pair . first;
   _Pbuf -> _Size = _Pair . second;
   }

  return ( _Pbuf -> _Size );
  }

private :
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar * _Pbuf;
 };
#line 675
template < class _Ty >
 class auto_ptr;
#line 678
template < class _Ty >
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref ( _Ty * _Right )
  : _Ref ( _Right )
  {
  }

 _Ty * _Ref;
 };
#line 689
template < class _Ty >
 class auto_ptr
  {
public :
 typedef auto_ptr < _Ty > _Myt;
 typedef _Ty element_type;

 explicit auto_ptr ( _Ty * _Ptr = 0 ) noexcept
  : _Myptr ( _Ptr )
  {
  }

 auto_ptr ( _Myt & _Right ) noexcept
  : _Myptr ( _Right . release ( ) )
  {
  }

 auto_ptr ( auto_ptr_ref < _Ty > _Right ) noexcept
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  _Myptr = _Ptr;
  }

 template < class _Other >
  operator auto_ptr < _Other > ( ) noexcept
  {
  return ( auto_ptr < _Other > ( * this ) );
  }

 template < class _Other >
  operator auto_ptr_ref < _Other > ( ) noexcept
  {
  _Other * _Cvtptr = _Myptr;
  auto_ptr_ref < _Other > _Ans ( _Cvtptr );
  _Myptr = 0;
  return ( _Ans );
  }

 template < class _Other >
  _Myt & operator = ( auto_ptr < _Other > & _Right ) noexcept
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 template < class _Other >
  auto_ptr ( auto_ptr < _Other > & _Right ) noexcept
  : _Myptr ( _Right . release ( ) )
  {
  }

 _Myt & operator = ( _Myt & _Right ) noexcept
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 _Myt & operator = ( auto_ptr_ref < _Ty > _Right ) noexcept
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  reset ( _Ptr );
  return ( * this );
  }

 ~ auto_ptr ( ) noexcept
  {
  delete _Myptr;
  }

 _Ty & operator * ( ) const noexcept
  {

  if ( _Myptr == 0 )
   _Debug_message ( L"\x61\x75\x74\x6f\x5f\x70\x74\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 764 );


  return ( * get ( ) );
  }

 _Ty * operator -> ( ) const noexcept
  {

  if ( _Myptr == 0 )
   _Debug_message ( L"\x61\x75\x74\x6f\x5f\x70\x74\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x6d\x65\x6d\x6f\x72\x79", 774 );


  return ( get ( ) );
  }

 _Ty * get ( ) const noexcept
  {
  return ( _Myptr );
  }

 _Ty * release ( ) noexcept
  {
  _Ty * _Tmp = _Myptr;
  _Myptr = 0;
  return ( _Tmp );
  }

 void reset ( _Ty * _Ptr = 0 )
  {
  if ( _Ptr != _Myptr )
   delete _Myptr;
  _Myptr = _Ptr;
  }

private :
 _Ty * _Myptr;
 };
#line 803 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory"
}
#line 806
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
#pragma warning(push,3)
#line 12
#pragma warning(disable: 4244 28309 28285)
#line 807 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xmemory"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 16
const int _ISORT_MAX = 32; 
#line 18
template < class _Iter1,
 class _Iter2,
 class _UIter1,
 class _UIter2 > inline
 pair < _Iter1, _Iter2 >
  _Rechecked_both ( _Iter1 _Dest1, _Iter2 _Dest2, pair < _UIter1, _UIter2 > _Src )
 {
 return ( pair < _Iter1, _Iter2 > (
  _Rechecked ( _Dest1, _Src . first ),
  _Rechecked ( _Dest2, _Src . second )
  ) );
 }
#line 32
template < class _Iter1,
 class _Iter2 > inline
 pair < decltype ( _Unchecked ( :: std :: declval < _Iter1 > ( ) ) ), decltype ( _Unchecked ( :: std :: declval < _Iter2 > ( ) ) ) >
  _Unchecked_both ( pair < _Iter1, _Iter2 > _Src )
 {
 return ( pair < decltype ( _Unchecked ( :: std :: declval < _Iter1 > ( ) ) ), decltype ( _Unchecked ( :: std :: declval < _Iter2 > ( ) ) ) > (
  _Unchecked ( _Src . first ),
  _Unchecked ( _Src . second ) ) );
 }
#line 42
template < class _Iter1,
 class _Iter2 > inline
 pair < decltype ( _Unchecked ( :: std :: declval < _Iter1 > ( ) ) ), _Iter2 >
  _Unchecked_first ( pair < _Iter1, _Iter2 > _Src )
 {
 return ( pair < decltype ( _Unchecked ( :: std :: declval < _Iter1 > ( ) ) ), _Iter2 > (
  _Unchecked ( _Src . first ),
  _Src . second ) );
 }
#line 52
template < class _Iter1,
 class _Iter2 > inline
 pair < _Iter1, decltype ( _Unchecked ( :: std :: declval < _Iter2 > ( ) ) ) >
  _Unchecked_second ( pair < _Iter1, _Iter2 > _Src )
 {
 return ( pair < _Iter1, decltype ( _Unchecked ( :: std :: declval < _Iter2 > ( ) ) ) > (
  _Src . first,
  _Unchecked ( _Src . second ) ) );
 }
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _Fn1 > inline
 void _For_each_unchecked ( _InIt _First, _InIt _Last, _Fn1 & _Func )
 {
 for (; _First != _Last; ++ _First )
  _Func ( * _First );
 }
#line 72
template < class _InIt,
 class _Fn1 > inline
 _Fn1 for_each ( _InIt _First, _InIt _Last, _Fn1 _Func )
 {
 _Debug_range_ptr ( _First, _Last, _Func, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 76 );
 _For_each_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Func );
 return ( _Func );
 }
#line 82
template < class _InIt,
 class _Pr > inline
 _InIt _Find_if_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   break;
 return ( _First );
 }
#line 92
template < class _InIt,
 class _Pr > inline
 _InIt find_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 96 );
 return ( _Rechecked ( _First,
  _Find_if_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 102
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Adjacent_find_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 if ( _First != _Last )
  for ( _FwdIt _Firstb; ( void ) ( _Firstb = _First ), ++ _First != _Last; )
   if ( _Pred ( * _Firstb, * _First ) )
    return ( _Firstb );
 return ( _Last );
 }
#line 113
template < class _FwdIt,
 class _Pr > inline
 _FwdIt adjacent_find ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 117 );
 _Debug_pointer_if ( _First != _Last && :: std :: next ( _First ) != _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 118 );
 return ( _Rechecked ( _First,
  _Adjacent_find_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 124
template < class _FwdIt > inline
 _FwdIt adjacent_find ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: adjacent_find ( _First, _Last, equal_to < > ( ) ) );
 }
#line 131
template < class _InIt,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count_if_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 typename iterator_traits < _InIt > :: difference_type _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   ++ _Count;
 return ( _Count );
 }
#line 144
template < class _InIt,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  count_if ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 149 );
 return ( _Count_if_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 154
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  _Mismatch_unchecked ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _Pred ( * _First1, * _First2 ); )
  {
  ++ _First1;
  ++ _First2;
  }

 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 170
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 auto _Mismatch_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr & _Pred, input_iterator_tag, input_iterator_tag )
   -> pair < _InIt1, decltype ( _Unchecked_idl0 ( _First2 ) ) >
 {
 return ( _Mismatch_unchecked ( _First1, _Last1,
  _Unchecked_idl0 ( _First2 ), _Pred ) );
 }
#line 181
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, decltype ( _Unchecked ( :: std :: declval < _InIt2 > ( ) ) ) >
  _Mismatch_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr & _Pred, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _First2 ) + ( ( _Last1 ) - ( _First1 ) ) );
 return ( _Mismatch_unchecked ( _First1, _Last1, _Unchecked ( _First2 ), _Pred ) );
 }
#line 192
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  _Mismatch_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr & _Pred )
 {
 _Debug_range_ptr ( _First1, _Last1, _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 199 );
 _Debug_pointer_if ( _First1 != _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 200 );
 return ( _Rechecked_both ( _First1, _First2,
  _Mismatch_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _First2, _Pred, _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _InIt2 > ( ) ) ) );
 }
#line 206
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::mismatch\' with parameters that may be unsafe - this call relies on the caller to check that the passed values ar" "e correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterator" "s\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _First2 ) ) );
 return ( _Mismatch_no_deprecate ( _First1, _Last1, _First2, _Pred ) );
 }
#line 218
template < class _InIt1,
 class _InTy,
 size_t _InSize,
 class _Pr,
 class = enable_if_t < ! is_same < _InTy *, _Pr > :: value > > inline
 pair < _InIt1, _InTy * >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InTy ( & _First2 ) [ _InSize ], _Pr _Pred )
 {
 return ( _Unchecked_second ( _Mismatch_no_deprecate ( _First1, _Last1,
  _Array_iterator < _InTy, _InSize > ( _First2 ), _Pred ) ) );
 }
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2 )
 {
 return ( :: std :: mismatch ( _First1, _Last1, _First2,
  equal_to < > ( ) ) );
 }
#line 244
template < class _InIt1,
 class _InTy,
 size_t _InSize > inline
 pair < _InIt1, _InTy * >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InTy ( & _First2 ) [ _InSize ] )
 {
 return ( :: std :: mismatch ( _First1, _Last1, _First2,
  equal_to < > ( ) ) );
 }
#line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  _Mismatch_unchecked ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2
  && _Pred ( * _First1, * _First2 ); )
  {
  ++ _First1;
  ++ _First2;
  }

 return ( pair < _InIt1, _InIt2 > ( _First1, _First2 ) );
 }
#line 274
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 281 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 282 );
 _Debug_pointer_if ( _First1 != _Last1 && _First2 != _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 283 );
 return ( _Rechecked_both ( _First1, _First2,
  _Mismatch_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) ) );
 }
#line 290
template < class _InIt1,
 class _InIt2 > inline
 pair < _InIt1, _InIt2 >
  mismatch ( _InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _InIt2 _Last2 )
 {
 return ( :: std :: mismatch ( _First1, _Last1, _First2, _Last2,
  equal_to < > ( ) ) );
 }
#line 301
template < class _InIt,
 class _Pr > inline
 bool _All_of_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   return ( false );
 return ( true );
 }
#line 311
template < class _InIt,
 class _Pr > inline
 bool all_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 315 );
 return ( _All_of_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 320
template < class _InIt,
 class _Pr > inline
 bool _Any_of_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   return ( true );
 return ( false );
 }
#line 330
template < class _InIt,
 class _Pr > inline
 bool any_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 334 );
 return ( _Any_of_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 339
template < class _InIt,
 class _Pr > inline
 bool _None_of_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   return ( false );
 return ( true );
 }
#line 349
template < class _InIt,
 class _Pr > inline
 bool none_of ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 353 );
 return ( _None_of_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 358
template < class _InIt,
 class _Pr > inline
 _InIt _Find_if_not_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   break;
 return ( _First );
 }
#line 368
template < class _InIt,
 class _Pr > inline
 _InIt find_if_not ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 372 );
 return ( _Rechecked ( _First,
  _Find_if_not_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 378
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Copy_if_unchecked ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 387 );
   * _Dest ++ = * _First;
   }

 return ( _Dest );
 }
#line 394
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Copy_if_no_deprecate ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr & _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 400 );
 return ( _Rechecked ( _Dest,
  _Copy_if_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 406
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt copy_if ( _InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::copy_if\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are" " correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators" "\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Copy_if_no_deprecate ( _First, _Last, _Dest, _Pred ) );
 }
#line 417
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * copy_if ( _InIt _First, _InIt _Last, _OutTy ( & _Dest ) [ _OutSize ],
  _Pr _Pred )
 {
 return ( _Unchecked (
  _Copy_if_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 431 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr > inline
 pair < _OutIt1, _OutIt2 >
  _Partition_copy_unchecked ( _InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   {
   _Debug_pointer ( _Dest1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 442 );
   * _Dest1 ++ = * _First;
   }
  else
   {
   _Debug_pointer ( _Dest2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 447 );
   * _Dest2 ++ = * _First;
   }

 return ( pair < _OutIt1, _OutIt2 > ( _Dest1, _Dest2 ) );
 }
#line 454
template < class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr > inline
 pair < _OutIt1, _OutIt2 >
  _Partition_copy_no_deprecate ( _InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr & _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 462 );
 return ( _Rechecked_both ( _Dest1, _Dest2,
  _Partition_copy_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Unchecked_idl0 ( _Dest1 ), _Unchecked_idl0 ( _Dest2 ), _Pred ) ) );
 }
#line 468
template < class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr > inline
 pair < _OutIt1, _OutIt2 >
  partition_copy ( _InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::partition_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed val" "ues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked It" "erators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } };
 ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest1 ) ) );
 ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest2 ) ) );
 return ( _Partition_copy_no_deprecate ( _First, _Last, _Dest1, _Dest2, _Pred ) );
 }
#line 483
template < class _InIt,
 class _OutTy1,
 size_t _OutSize1,
 class _OutIt2,
 class _Pr > inline
 pair < _OutTy1 *, _OutIt2 >
  partition_copy ( _InIt _First, _InIt _Last,
   _OutTy1 ( & _Dest1 ) [ _OutSize1 ], _OutIt2 _Dest2, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::partition_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed val" "ues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked It" "erators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest2 ) ) );
 return ( _Unchecked_first (
  _Partition_copy_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy1, _OutSize1 > ( _Dest1 ), _Dest2, _Pred ) ) );
 }
#line 498
template < class _InIt,
 class _OutIt1,
 class _OutTy2,
 size_t _OutSize2,
 class _Pr > inline
 pair < _OutIt1, _OutTy2 * >
  partition_copy ( _InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutTy2 ( & _Dest2 ) [ _OutSize2 ], _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::partition_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed val" "ues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked It" "erators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest1 ) ) );
 return ( _Unchecked_second (
  _Partition_copy_no_deprecate ( _First, _Last,
   _Dest1, _Array_iterator < _OutTy2, _OutSize2 > ( _Dest2 ), _Pred ) ) );
 }
#line 513
template < class _InIt,
 class _OutTy1,
 size_t _OutSize1,
 class _OutTy2,
 size_t _OutSize2,
 class _Pr > inline
 pair < _OutTy1 *, _OutTy2 * >
  partition_copy ( _InIt _First, _InIt _Last,
   _OutTy1 ( & _Dest1 ) [ _OutSize1 ], _OutTy2 ( & _Dest2 ) [ _OutSize2 ],
   _Pr _Pred )
 {
 return ( _Unchecked_both (
  _Partition_copy_no_deprecate ( _First, _Last,
    _Array_iterator < _OutTy1, _OutSize1 > ( _Dest1 ),
    _Array_iterator < _OutTy2, _OutSize2 > ( _Dest2 ), _Pred ) ) );
 }
#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _Pr > inline
 bool _Is_partitioned_unchecked ( _InIt _First, _InIt _Last, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   break;
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   return ( false );
 return ( true );
 }
#line 545
template < class _InIt,
 class _Pr > inline
 bool is_partitioned ( _InIt _First, _InIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 549 );
 return ( _Is_partitioned_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Pred ) );
 }
#line 555
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Partition_point_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _First, _Last );
 while ( 0 < _Count )
  {
  _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Pred ( * _Mid ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }

 return ( _First );
 }
#line 578
template < class _FwdIt,
 class _Pr > inline
 _FwdIt partition_point ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 582 );
 return ( _Rechecked ( _First,
  _Partition_point_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 588
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 _Search_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred,
  forward_iterator_tag, forward_iterator_tag )
 {
 for (;; ++ _First1 )
  {
  _FwdIt1 _Mid1 = _First1;
  for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1, ( void ) ++ _Mid2 )
   if ( _Mid2 == _Last2 )
    return ( _First1 );
   else if ( _Mid1 == _Last1 )
    return ( _Last1 );
   else if ( ! _Pred ( * _Mid1, * _Mid2 ) )
    break;
  }
 }
#line 608
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 _Search_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 _Iter_diff_t < _FwdIt1 > _Count1 = _Last1 - _First1;
 _Iter_diff_t < _FwdIt2 > _Count2 = _Last2 - _First2;

 for (; _Count2 <= _Count1; ++ _First1, ( void ) -- _Count1 )
  {
  _FwdIt1 _Mid1 = _First1;
  for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1, ( void ) ++ _Mid2 )
   if ( _Mid2 == _Last2 )
    return ( _First1 );
   else if ( ! _Pred ( * _Mid1, * _Mid2 ) )
    break;
  }

 return ( _Last1 );
 }
#line 631
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 637 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 638 );
 _Debug_pointer_if ( _First1 != _Last1 && _First2 != _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 639 );
 return ( _Rechecked ( _First1,
  _Search_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred,
   _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) ) ) );
 }
#line 647
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 search ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 return ( :: std :: search ( _First1, _Last1, _First2, _Last2,
  equal_to < > ( ) ) );
 }
#line 657
template < class _FwdIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 _FwdIt _Search_n_unchecked ( _FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty & _Val, _Pr & _Pred, forward_iterator_tag )
 {
 if ( _Count <= 0 )
  return ( _First );

 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First, _Val ) )
   {
   _FwdIt _Mid = _First;

   for ( _Diff _Count1 = _Count;; )
    if ( -- _Count1 == 0 )
     return ( _First );
    else if ( ++ _Mid == _Last )
     return ( _Last );
    else if ( ! _Pred ( * _Mid, _Val ) )
     {
     break;
     }

   _First = _Mid;
   }

 return ( _Last );
 }
#line 688
template < class _FwdIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 _FwdIt _Search_n_unchecked ( _FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty & _Val, _Pr & _Pred, random_access_iterator_tag )
 {
 if ( _Count <= 0 )
  return ( _First );

 _FwdIt _Oldfirst = _First;
 for ( _Diff _Inc = 0; _Count <= _Last - _Oldfirst; )
  {
  _First = _Oldfirst + _Inc;
  if ( _Pred ( * _First, _Val ) )
   {
   _Diff _Count1 = _Count;
   _FwdIt _Mid = _First;

   for (; _Oldfirst != _First && _Pred ( _First [ - 1 ], _Val );
    -- _First )
    -- _Count1;

   if ( _Count1 <= _Last - _Mid )
    for (;; )
     {
     if ( -- _Count1 == 0 )
      return ( _First );
     else if ( ! _Pred ( * ++ _Mid, _Val ) )
      {
      break;
      }
     }
   _Oldfirst = ++ _Mid;
   _Inc = 0;
   }
  else
   {
   _Oldfirst = _First + 1;
   _Inc = _Count - 1;
   }
  }

 return ( _Last );
 }
#line 734
template < class _FwdIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 _FwdIt search_n ( _FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty & _Val, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 741 );
 return ( _Rechecked ( _First,
  _Search_n_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Count, _Val,
   _Pred, _Iter_cat_t < _FwdIt > ( ) ) ) );
 }
#line 748
template < class _FwdIt,
 class _Diff,
 class _Ty > inline
 _FwdIt search_n ( _FwdIt _First, _FwdIt _Last,
  _Diff _Count, const _Ty & _Val )
 {
 return ( :: std :: search_n ( _First, _Last, _Count, _Val,
  equal_to < > ( ) ) );
 }
#line 759
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 _Find_end_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred )
 {
 _Iter_diff_t < _FwdIt1 > _Count1 = :: std :: distance ( _First1, _Last1 );
 _Iter_diff_t < _FwdIt2 > _Count2 = :: std :: distance ( _First2, _Last2 );
 _FwdIt1 _Ans = _Last1;

 if ( 0 < _Count2 )
  {
  _Debug_pointer_if ( _Count2 <= _Count1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 771 );
  for (; _Count2 <= _Count1; ++ _First1, ( void ) -- _Count1 )
   {
   _FwdIt1 _Mid1 = _First1;
   for ( _FwdIt2 _Mid2 = _First2;; ++ _Mid1 )
    if ( ! _Pred ( * _Mid1, * _Mid2 ) )
     break;
    else if ( ++ _Mid2 == _Last2 )
     {
     _Ans = _First1;
     break;
     }
   }
  }

 return ( _Ans );
 }
#line 789
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 795 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 796 );
 return ( _Rechecked ( _First1,
  _Find_end_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) ) );
 }
#line 803
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 find_end ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 return ( :: std :: find_end ( _First1, _Last1, _First2, _Last2,
  equal_to < > ( ) ) );
 }
#line 813
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 _Find_first_of_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr & _Pred )
 {
 for (; _First1 != _Last1; ++ _First1 )
  for ( _FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++ _Mid2 )
   if ( _Pred ( * _First1, * _Mid2 ) )
    return ( _First1 );
 return ( _First1 );
 }
#line 826
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 _FwdIt1 find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 832 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 833 );
 _Debug_pointer_if ( _First1 != _Last1 && _First2 != _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 834 );
 return ( _Rechecked ( _First1,
  _Find_first_of_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) ) );
 }
#line 841
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt1 find_first_of ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 return ( :: std :: find_first_of ( _First1, _Last1, _First2, _Last2,
  equal_to < > ( ) ) );
 }
#line 851
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt2 _Swap_ranges_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest )
 {
 for (; _First1 != _Last1; ++ _First1, ( void ) ++ _Dest )
  :: std :: iter_swap ( _First1, _Dest );
 return ( _Dest );
 }
#line 861
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt2 _Swap_ranges1 ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest,
  forward_iterator_tag, forward_iterator_tag )
 {
 return ( _Rechecked ( _Dest,
  _Swap_ranges_unchecked ( _First1, _Last1, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 871
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt2 _Swap_ranges1 ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last1 ) - ( _First1 ) ) );
 return ( _Rechecked ( _Dest,
  _Swap_ranges_unchecked ( _First1, _Last1, _Unchecked ( _Dest ) ) ) );
 }
#line 882
template < class _FwdIt1,
 class _FwdIt2 > inline
 _FwdIt2 swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::swap_ranges\' with parameters that may be unsafe - this call relies on the caller to check that the passed values" " are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Itera" "tors\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range_ptr ( _First1, _Last1, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 888 );
 return ( _Swap_ranges1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Dest, _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) ) );
 }
#line 894
template < class _FwdIt1,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * swap_ranges ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: swap_ranges ( _First1, _Last1,
  _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }
#line 907 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt _Transform_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 & _Func )
 {
 for (; _First != _Last; ++ _First, ( void ) ++ _Dest )
  * _Dest = _Func ( * _First );
 return ( _Dest );
 }
#line 918
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt _Transform_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 & _Func,
  input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Transform_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ), _Func ) ) );
 }
#line 929
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt _Transform_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 & _Func,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Transform_unchecked ( _First, _Last, _Unchecked ( _Dest ), _Func ) ) );
 }
#line 941
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt _Transform_no_deprecate ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 & _Func )
 {
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 947 );
 _Debug_pointer_if ( _First != _Last, _Func, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 948 );
 return ( _Transform_no_deprecate1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Func, _Iter_cat_t < _InIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 953
template < class _InIt,
 class _OutIt,
 class _Fn1 > inline
 _OutIt transform ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 _Func )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::transform\' with parameters that may be unsafe - this call relies on the caller to check that the passed values a" "re correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterato" "rs\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Transform_no_deprecate ( _First, _Last, _Dest, _Func ) );
 }
#line 964
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Fn1 > inline
 _OutTy * transform ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ], _Fn1 _Func )
 {
 return ( _Unchecked (
  _Transform_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Func ) ) );
 }
#line 978 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 & _Func )
 {
 for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2, ++ _Dest )
  * _Dest = _Func ( * _First1, * _First2 );
 return ( _Dest );
 }
#line 990
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform_no_deprecate2 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 & _Func,
  input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Transform_unchecked ( _First1, _Last1, _First2, _Unchecked_idl0 ( _Dest ), _Func ) ) );
 }
#line 1002
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform_no_deprecate2 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 & _Func,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last1 ) - ( _First1 ) ) );
 return ( _Rechecked ( _Dest,
  _Transform_unchecked ( _First1, _Last1, _First2, _Unchecked ( _Dest ), _Func ) ) );
 }
#line 1015
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 & _Func,
  input_iterator_tag, input_iterator_tag )
 {
 return ( _Transform_no_deprecate2 ( _First1, _Last1,
  _Unchecked_idl0 ( _First2 ), _Dest, _Func,
  _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 1028
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 & _Func,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _First2 ) + ( ( _Last1 ) - ( _First1 ) ) );
 return ( _Transform_no_deprecate2 ( _First1, _Last1,
  _Unchecked ( _First2 ), _Dest, _Func,
  _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 1042
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt _Transform_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 & _Func )
 {
 _Debug_range_ptr ( _First1, _Last1, _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1049 );
 _Debug_pointer_if ( _First1 != _Last1, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1050 );
 _Debug_pointer_if ( _First1 != _Last1, _Func, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1051 );
 return ( _Transform_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _First2, _Dest, _Func,
  _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _InIt2 > ( ) ) );
 }
#line 1057
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2 > inline
 _OutIt transform ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 _Func )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::transform\' with parameters that may be unsafe - this call relies on the caller to check that the passed values a" "re correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterato" "rs\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } };
 ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _First2 ) ) );
 ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Transform_no_deprecate ( _First1, _Last1, _First2, _Dest, _Func ) );
 }
#line 1071
template < class _InIt1,
 class _InTy,
 size_t _InSize,
 class _OutIt,
 class _Fn2 > inline
 _OutIt transform ( _InIt1 _First1, _InIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ], _OutIt _Dest, _Fn2 _Func )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::transform\' with parameters that may be unsafe - this call relies on the caller to check that the passed values a" "re correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterato" "rs\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Transform_no_deprecate ( _First1, _Last1,
  _Array_iterator < _InTy, _InSize > ( _First2 ), _Dest, _Func ) );
 }
#line 1084
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize,
 class _Fn2 > inline
 _OutTy * transform ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutTy ( & _Dest ) [ _OutSize ], _Fn2 _Func )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::transform\' with parameters that may be unsafe - this call relies on the caller to check that the passed values a" "re correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterato" "rs\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _First2 ) ) );
 return ( _Unchecked (
  _Transform_no_deprecate ( _First1, _Last1,
   _First2, _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Func ) ) );
 }
#line 1098
template < class _InIt1,
 class _InTy,
 size_t _InSize,
 class _OutTy,
 size_t _OutSize,
 class _Fn2 > inline
 _OutTy * transform ( _InIt1 _First1, _InIt1 _Last1,
  _InTy ( & _First2 ) [ _InSize ], _OutTy ( & _Dest ) [ _OutSize ], _Fn2 _Func )
 {
 return ( _Unchecked (
  _Transform_no_deprecate ( _First1, _Last1,
   _Array_iterator < _InTy, _InSize > ( _First2 ),
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Func ) ) );
 }
#line 1115 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Ty > inline
 void _Replace_unchecked ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 for (; _First != _Last; ++ _First )
  if ( * _First == _Oldval )
   * _First = _Newval;
 }
#line 1125
template < class _FwdIt,
 class _Ty > inline
 void replace ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Oldval, const _Ty & _Newval )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1130 );
 _Replace_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Oldval, _Newval );
 }
#line 1136
template < class _FwdIt,
 class _Pr,
 class _Ty > inline
 void _Replace_if_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First ) )
   * _First = _Val;
 }
#line 1146
template < class _FwdIt,
 class _Pr,
 class _Ty > inline
 void replace_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty & _Val )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1151 );
 _Replace_if_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Pred, _Val );
 }
#line 1157
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Replace_copy_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval )
 {
 for (; _First != _Last; ++ _First, ( void ) ++ _Dest )
  * _Dest = * _First == _Oldval ? _Newval : * _First;
 return ( _Dest );
 }
#line 1168
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Replace_copy1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval,
  input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Replace_copy_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ),
  _Oldval, _Newval ) ) );
 }
#line 1180
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Replace_copy1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Replace_copy_unchecked ( _First, _Last, _Unchecked ( _Dest ),
  _Oldval, _Newval ) ) );
 }
#line 1193
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt replace_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Oldval, const _Ty & _Newval )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::replace_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed value" "s are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iter" "ators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1200 );
 return ( _Replace_copy1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Oldval, _Newval,
  _Iter_cat_t < _InIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 1207
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Ty > inline
 _OutTy * replace_copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ], const _Ty & _Oldval, const _Ty & _Newval )
 {
 return ( _Unchecked (
  :: std :: replace_copy ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Oldval, _Newval ) ) );
 }
#line 1221 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt _Replace_copy_if_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First, ( void ) ++ _Dest )
  * _Dest = _Pred ( * _First ) ? _Val : * _First;
 return ( _Dest );
 }
#line 1233
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt _Replace_copy_if_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred, const _Ty & _Val,
  input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Replace_copy_if_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ), _Pred, _Val ) ) );
 }
#line 1245
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt _Replace_copy_if_no_deprecate1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred, const _Ty & _Val,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Replace_copy_if_unchecked ( _First, _Last, _Unchecked ( _Dest ), _Pred, _Val ) ) );
 }
#line 1258
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt _Replace_copy_if_no_deprecate ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred, const _Ty & _Val )
 {
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1265 );
 _Debug_pointer_if ( _First != _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1266 );
 return ( _Replace_copy_if_no_deprecate1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Pred, _Val,
  _Iter_cat_t < _InIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 1272
template < class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty > inline
 _OutIt replace_copy_if ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, const _Ty & _Val )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::replace_copy_if\' with parameters that may be unsafe - this call relies on the caller to check that the passed va" "lues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked I" "terators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Replace_copy_if_no_deprecate ( _First, _Last, _Dest, _Pred, _Val ) );
 }
#line 1284
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Pr,
 class _Ty > inline
 _OutTy * replace_copy_if ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred, const _Ty & _Val )
 {
 return ( _Unchecked (
  _Replace_copy_if_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred, _Val ) ) );
 }
#line 1299 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Fn0 > inline
 void _Generate_unchecked ( _FwdIt _First, _FwdIt _Last, _Fn0 & _Func )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Func ( );
 }
#line 1307
template < class _FwdIt,
 class _Fn0 > inline
 void generate ( _FwdIt _First, _FwdIt _Last, _Fn0 _Func )
 {
 _Debug_range_ptr ( _First, _Last, _Func, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1311 );
 _Generate_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Func );
 }
#line 1316
template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
 _OutIt _Generate_n_unchecked ( _OutIt _Dest, _Diff _Count, _Fn0 & _Func )
 {
 for (; 0 < _Count; -- _Count, ( void ) ++ _Dest )
  * _Dest = _Func ( );
 return ( _Dest );
 }
#line 1326
template < class _OutIt,
 class _Diff,
 class _Fn0 > inline
 _OutIt generate_n ( _OutIt _Dest, _Diff _Count, _Fn0 _Func )
 {
 return ( _Rechecked ( _Dest,
  _Generate_n_unchecked ( _Unchecked_n ( _Dest, _Count ), _Count, _Func ) ) );
 }
#line 1336
template < class _OutTy,
 size_t _OutSize,
 class _Diff,
 class _Fn0 > inline
 _OutTy * generate_n ( _OutTy ( & _Dest ) [ _OutSize ], _Diff _Count, _Fn0 _Func )
 {
 _Debug_array_size2 ( _Dest, _Count, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1342 );
 return ( _Generate_n_unchecked ( _Dest, _Count, _Func ) );
 }
#line 1348 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt _Remove_copy_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  if ( ! ( * _First == _Val ) )
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1357 );
   * _Dest ++ = * _First;
   }

 return ( _Dest );
 }
#line 1364
template < class _InIt,
 class _OutIt,
 class _Ty > inline
 _OutIt remove_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty & _Val )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::remove_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed values" " are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Itera" "tors\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1371 );
 return ( _Rechecked ( _Dest,
  _Remove_copy_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Unchecked_idl0 ( _Dest ), _Val ) ) );
 }
#line 1378
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Ty > inline
 _OutTy * remove_copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ], const _Ty & _Val )
 {
 return ( _Unchecked (
  :: std :: remove_copy ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Val ) ) );
 }
#line 1392 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Remove_copy_if_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1401 );
   * _Dest ++ = * _First;
   }

 return ( _Dest );
 }
#line 1408
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Remove_copy_if_no_deprecate ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1414 );
 return ( _Rechecked ( _Dest,
  _Remove_copy_if_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 1420
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt remove_copy_if ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::remove_copy_if\' with parameters that may be unsafe - this call relies on the caller to check that the passed val" "ues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked It" "erators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Remove_copy_if_no_deprecate ( _First, _Last, _Dest, _Pred ) );
 }
#line 1431
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * remove_copy_if ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Remove_copy_if_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 1445 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Ty > inline
 _FwdIt _Remove_unchecked ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _First = _Find_unchecked ( _First, _Last, _Val );
 _FwdIt _Next = _First;
 if ( _First != _Last )
  {
  for ( ++ _First; _First != _Last; ++ _First )
   if ( ! ( * _First == _Val ) )
    * _Next ++ = :: std :: move ( * _First );
  }

 return ( _Next );
 }
#line 1461
template < class _FwdIt,
 class _Ty > inline
 _FwdIt remove ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1465 );
 return ( _Rechecked ( _First,
  _Remove_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) ) );
 }
#line 1471
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Remove_if_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 _First = _Find_if_unchecked ( _First, _Last, _Pred );
 _FwdIt _Next = _First;
 if ( _First != _Last )
  {
  for ( ++ _First; _First != _Last; ++ _First )
  if ( ! _Pred ( * _First ) )
   * _Next ++ = :: std :: move ( * _First );
  }

 return ( _Next );
 }
#line 1487
template < class _FwdIt,
 class _Pr > inline
 _FwdIt remove_if ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1491 );
 return ( _Rechecked ( _First,
  _Remove_if_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 1497
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Unique_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 if ( _First != _Last )
  for ( _FwdIt _Firstb; ( void ) ( _Firstb = _First ), ++ _First != _Last; )
   if ( _Pred ( * _Firstb, * _First ) )
    {
    for (; ++ _First != _Last; )
     if ( ! _Pred ( * _Firstb, * _First ) )
      * ++ _Firstb = :: std :: move ( * _First );
    return ( ++ _Firstb );
    }

 return ( _Last );
 }
#line 1514
template < class _FwdIt,
 class _Pr > inline
 _FwdIt unique ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1518 );
 _Debug_pointer_if ( _First != _Last && :: std :: next ( _First ) != _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1519 );
 return ( _Rechecked ( _First,
  _Unique_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 1525
template < class _FwdIt > inline
 _FwdIt unique ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: unique ( _First, _Last, equal_to < > ( ) ) );
 }
#line 1532
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred, input_iterator_tag )
 {
 if ( _First != _Last )
  {
  _Iter_value_t < _InIt > _Val = * _First;

  for ( * _Dest ++ = _Val; ++ _First != _Last; )
   if ( ! _Pred ( _Val, * _First ) )
    {
    _Val = * _First;
    * _Dest ++ = _Val;
    }
  }

 return ( _Dest );
 }
#line 1553
template < class _FwdIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy_unchecked ( _FwdIt _First, _FwdIt _Last,
  _OutIt _Dest, _Pr & _Pred, forward_iterator_tag )
 {
 if ( _First != _Last )
  {
  _FwdIt _Firstb = _First;

  for ( * _Dest ++ = * _Firstb; ++ _First != _Last; )
   if ( ! _Pred ( * _Firstb, * _First ) )
    {
    _Firstb = _First;
    * _Dest ++ = * _Firstb;
    }
  }

 return ( _Dest );
 }
#line 1574
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt _Unique_copy_no_deprecate ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1580 );
 _Debug_pointer_if ( _First != _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1581 );
 return ( _Rechecked ( _Dest,
  _Unique_copy_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked_idl0 ( _Dest ), _Pred, _Iter_cat_t < _InIt > ( ) ) ) );
 }
#line 1587
template < class _InIt,
 class _OutIt,
 class _Pr > inline
 _OutIt unique_copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::unique_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed values" " are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Itera" "tors\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Unique_copy_no_deprecate ( _First, _Last, _Dest, _Pred ) );
 }
#line 1598
template < class _InIt,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * unique_copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Unique_copy_no_deprecate ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 1612 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt,
 class _OutIt > inline
 _OutIt unique_copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 return ( :: std :: unique_copy ( _First, _Last, _Dest,
  equal_to < > ( ) ) );
 }
#line 1621
template < class _InIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * unique_copy ( _InIt _First, _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: unique_copy ( _First, _Last, _Dest,
  equal_to < > ( ) ) );
 }
#line 1633 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _BidIt,
 class _OutIt > inline
 _OutIt _Reverse_copy_unchecked ( _BidIt _First, _BidIt _Last,
  _OutIt _Dest )
 {
 for (; _First != _Last; ++ _Dest )
  * _Dest = * -- _Last;
 return ( _Dest );
 }
#line 1643
template < class _BidIt,
 class _OutIt > inline
 _OutIt _Reverse_copy1 ( _BidIt _First, _BidIt _Last,
  _OutIt _Dest,
  bidirectional_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Reverse_copy_unchecked ( _First, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 1653
template < class _BidIt,
 class _OutIt > inline
 _OutIt _Reverse_copy1 ( _BidIt _First, _BidIt _Last,
  _OutIt _Dest,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Reverse_copy_unchecked ( _First, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 1664
template < class _BidIt,
 class _OutIt > inline
 _OutIt reverse_copy ( _BidIt _First, _BidIt _Last,
  _OutIt _Dest )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::reverse_copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed value" "s are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iter" "ators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 _Debug_range_ptr ( _First, _Last, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1670 );
 return ( _Reverse_copy1 ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Dest, _Iter_cat_t < _BidIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 1676
template < class _BidIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * reverse_copy ( _BidIt _First, _BidIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( _Unchecked (
  :: std :: reverse_copy ( _First, _Last,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) ) );
 }
#line 1689 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _OutIt > inline
 _OutIt _Rotate_copy_unchecked ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest )
 {
 _Dest = _Copy_unchecked ( _Mid, _Last, _Dest );
 return ( _Copy_unchecked ( _First, _Mid, _Dest ) );
 }
#line 1698
template < class _FwdIt,
 class _OutIt > inline
 _OutIt _Rotate_copy1 ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest, forward_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Rotate_copy_unchecked ( _First, _Mid, _Last, _Unchecked_idl0 ( _Dest ) ) ) );
 }
#line 1707
template < class _FwdIt,
 class _OutIt > inline
 _OutIt _Rotate_copy1 ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last ) - ( _First ) ) );
 return ( _Rechecked ( _Dest,
  _Rotate_copy_unchecked ( _First, _Mid, _Last, _Unchecked ( _Dest ) ) ) );
 }
#line 1717
template < class _FwdIt,
 class _OutIt > inline
 _OutIt rotate_copy ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest )
 {
 _Debug_range ( _First, _Mid, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1722 );
 _Debug_range ( _Mid, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1723 );
 return ( _Rotate_copy1 ( _Unchecked ( _First ), _Unchecked ( _Mid ),
  _Unchecked ( _Last ), _Dest, _Iter_cat_t < _FwdIt > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 1729
template < class _RanIt,
 class _Fn1 > inline
 void _Random_shuffle_unchecked ( _RanIt _First, _RanIt _Last, _Fn1 & _Func )
 {
 if ( _Last - _First < 2 )
  return;

 _RanIt _Next = _First;
 for ( _Iter_diff_t < _RanIt > _Index = 2; ++ _Next != _Last; ++ _Index )
  {
  _Iter_diff_t < _RanIt > _Off = _Func ( _Index );


  if ( _Off < 0 || _Index <= _Off )
   {
   _Debug_message ( L"\x72\x61\x6e\x64\x6f\x6d\x20\x76\x61\x6c\x75\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1744 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1745, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1745, 0 ); };
   }





  :: std :: iter_swap ( _Next, _First + _Off );
  }
 }
#line 1756 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _RanIt,
 class _Fn1 > inline
 void _Random_shuffle1 ( _RanIt _First, _RanIt _Last, _Fn1 & _Func )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1760 );
 _Random_shuffle_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Func );
 }
#line 1764
template < class _RanIt,
 class _Urng > inline
 void shuffle ( _RanIt _First, _RanIt _Last, _Urng && _Func )
 {
 typedef typename iterator_traits < _RanIt > :: difference_type _Diff;
 typedef typename remove_reference < _Urng > :: type _Urng0;
 _Rng_from_urng < _Diff, _Urng0 > _Rng ( _Func );
 _Random_shuffle1 ( _First, _Last, _Rng );
 }
#line 1776
template < class _RanIt,
 class _Fn1 > inline
 void random_shuffle ( _RanIt _First, _RanIt _Last, _Fn1 && _Func )
 {
 _Random_shuffle1 ( _First, _Last, _Func );
 }
#line 1784
struct _Rand_urng_from_func { 
#line 1786
typedef unsigned result_type; 
#line 1788
static result_type min() 
#line 1789
{ 
#line 1790
return 0; 
#line 1791
} 
#line 1793
static result_type max() 
#line 1794
{ 
#line 1795
return 32767; 
#line 1796
} 
#line 1798
result_type operator()() 
#line 1799
{ 
#line 1800
return ::rand(); 
#line 1801
} 
#line 1802
}; 
#line 1805
template < class _RanIt > inline
 void random_shuffle ( _RanIt _First, _RanIt _Last )
 {
 _Rand_urng_from_func _Func;
 :: std :: shuffle ( _First, _Last, _Func );
 }
#line 1814 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Partition_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred,
  forward_iterator_tag )
 {
 while ( _First != _Last && _Pred ( * _First ) )
  ++ _First;

 if ( _First == _Last )
  return ( _First );

 for ( _FwdIt _Next = :: std :: next ( _First ); _Next != _Last; ++ _Next )
  if ( _Pred ( * _Next ) )
   :: std :: iter_swap ( _First ++, _Next );

 return ( _First );
 }
#line 1832
template < class _BidIt,
 class _Pr > inline
 _BidIt _Partition_unchecked ( _BidIt _First, _BidIt _Last, _Pr & _Pred,
  bidirectional_iterator_tag )
 {
 for (;; ++ _First )
  {
  for (; _First != _Last && _Pred ( * _First ); ++ _First )
   ;
  if ( _First == _Last )
   break;

  for (; _First != -- _Last && ! _Pred ( * _Last ); )
   ;
  if ( _First == _Last )
   break;

  :: std :: iter_swap ( _First, _Last );
  }

 return ( _First );
 }
#line 1855
template < class _FwdIt,
 class _Pr > inline
 _FwdIt partition ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1859 );
 return ( _Rechecked ( _First,
  _Partition_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred,
   _Iter_cat_t < _FwdIt > ( ) ) ) );
 }
#line 1866
template < class _BidIt,
 class _Diff,
 class _Ty > inline
 _BidIt _Buffered_rotate_unchecked ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2, _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count1 == 0 || _Count2 == 0 )
  {
  :: std :: advance ( _First, _Count2 );
  return ( _First );
  }
 else if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move_unchecked ( _First, _Mid, _Tempbuf . _Init ( ) );
  _Move_unchecked ( _Mid, _Last, _First );
  return ( _Move_backward_unchecked ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Last ) );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move_unchecked ( _Mid, _Last, _Tempbuf . _Init ( ) );
  _Move_backward_unchecked ( _First, _Mid, _Last );
  return ( _Move_unchecked ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First ) );
  }
 else
  {
  return ( _Rotate_unchecked ( _First, _Mid, _Last ) );
  }
 }
#line 1896
template < class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty > inline
 _BidIt _Stable_partition_unchecked1 ( _BidIt _First, _BidIt _Last, _Pr & _Pred,
  _Diff _Count, _Temp_iterator < _Ty > & _Tempbuf )
 {
 if ( _Count == 0 )
  return ( _First );
 else if ( _Count == 1 )
  return ( _Pred ( * _First ) ? _Last : _First );
 else if ( _Count <= _Tempbuf . _Maxlen ( ) )
  {
  _BidIt _Next = _First;
  for ( _Tempbuf . _Init ( ); _First != _Last; ++ _First )
   if ( _Pred ( * _First ) )
    * _Next ++ = :: std :: move ( * _First );
   else
    * _Tempbuf ++ = :: std :: move ( * _First );

  _Move_unchecked ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Next );
  return ( _Next );
  }
 else
  {
  _BidIt _Mid = _First;
  :: std :: advance ( _Mid, _Count / 2 );

  _BidIt _Left = _Stable_partition_unchecked1 ( _First, _Mid, _Pred,
   _Count / 2, _Tempbuf );
  _BidIt _Right = _Stable_partition_unchecked1 ( _Mid, _Last, _Pred,
   _Count - _Count / 2, _Tempbuf );

  _Diff _Count1 = :: std :: distance ( _Left, _Mid );
  _Diff _Count2 = :: std :: distance ( _Mid, _Right );

  return ( _Buffered_rotate_unchecked ( _Left, _Mid, _Right,
   _Count1, _Count2, _Tempbuf ) );
  }
 }
#line 1937
template < class _BidIt,
 class _Pr > inline
 _BidIt _Stable_partition_unchecked ( _BidIt _First, _BidIt _Last, _Pr & _Pred )
 {
 if ( _First == _Last )
  return ( _First );
 _Iter_diff_t < _BidIt > _Count = :: std :: distance ( _First, _Last );
 _Temp_iterator < _Iter_value_t < _BidIt >> _Tempbuf ( _Count );
 return ( _Stable_partition_unchecked1 ( _First, _Last, _Pred, _Count, _Tempbuf ) );
 }
#line 1948
template < class _BidIt,
 class _Pr > inline
 _BidIt stable_partition ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1952 );
 return ( _Rechecked ( _First,
  _Stable_partition_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 1959
template < class _RanIt,
 class _Pr > inline
 void _Debug_heap ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 if ( _First != _Last )
  for ( _RanIt _Root = _First; ++ _First != _Last; ++ _Root )
   {
   if ( _Debug_lt_pred ( _Pred, * _Root, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1966 ) )
    _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x68\x65\x61\x70", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1967 );
   else if ( ++ _First == _Last )
    break;
   else if ( _Debug_lt_pred ( _Pred, * _Root, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1970 ) )
    _Debug_message ( L"\x69\x6e\x76\x61\x6c\x69\x64\x20\x68\x65\x61\x70", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1971 );
   }
 }
#line 1983 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Push_heap_by_index ( _RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty && _Val, _Pr & _Pred )
 {
 for ( _Diff _Idx = ( _Hole - 1 ) / 2;
  _Top < _Hole && _Debug_lt_pred ( _Pred, * ( _First + _Idx ), _Val, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 1991 );
  _Idx = ( _Hole - 1 ) / 2 )
  {
  * ( _First + _Hole ) = :: std :: move ( * ( _First + _Idx ) );
  _Hole = _Idx;
  }

 * ( _First + _Hole ) = :: std :: move ( _Val );
 }
#line 2001
template < class _RanIt,
 class _Pr > inline
 void _Push_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 typedef _Iter_diff_t < _RanIt > _Diff;
 _Diff _Count = _Last - _First;
 if ( 2 <= _Count )
  {
  _Iter_value_t < _RanIt > _Val = :: std :: move ( * -- _Last );
  _Push_heap_by_index ( _First, -- _Count, _Diff ( 0 ), :: std :: move ( _Val ), _Pred );
  }
 }
#line 2014
template < class _RanIt,
 class _Pr > inline
 void push_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2018 );
 _Push_heap_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2023
template < class _RanIt > inline
 void push_heap ( _RanIt _First, _RanIt _Last )
 {
 :: std :: push_heap ( _First, _Last, less < > ( ) );
 }
#line 2030
template < class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Pop_heap_hole_by_index ( _RanIt _First, _Diff _Hole, _Diff _Bottom,
  _Ty && _Val, _Pr & _Pred )
 {

 const _Diff _Top = _Hole;
 _Diff _Idx = _Hole;



 const _Diff _Max_sequence_non_leaf = ( _Bottom - 1 ) / 2;
 while ( _Idx < _Max_sequence_non_leaf )
  {
  _Idx = 2 * _Idx + 2;
  if ( _Debug_lt_pred ( _Pred, * ( _First + _Idx ), * ( _First + ( _Idx - 1 ) ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2047 ) )
   -- _Idx;
  * ( _First + _Hole ) = :: std :: move ( * ( _First + _Idx ) );
  _Hole = _Idx;
  }

 if ( _Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0 )
  {
  * ( _First + _Hole ) = :: std :: move ( * ( _First + ( _Bottom - 1 ) ) );
  _Hole = _Bottom - 1;
  }

 _Push_heap_by_index ( _First, _Hole, _Top, :: std :: move ( _Val ), _Pred );
 }
#line 2062
template < class _RanIt,
 class _Ty,
 class _Pr > inline
 void _Pop_heap_hole_unchecked ( _RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty && _Val, _Pr & _Pred )
 {


 * _Dest = :: std :: move ( * _First );
 _Pop_heap_hole_by_index ( _First, _Iter_diff_t < _RanIt > ( 0 ), _Iter_diff_t < _RanIt > ( _Last - _First ),
  :: std :: move ( _Val ), _Pred );
 }
#line 2075
template < class _RanIt,
 class _Pr > inline
 void _Pop_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 if ( 2 <= _Last - _First )
  {
  -- _Last;
  _Iter_value_t < _RanIt > _Val = :: std :: move ( * _Last );
  _Pop_heap_hole_unchecked ( _First, _Last, _Last,
   :: std :: move ( _Val ), _Pred );
  }
 }
#line 2088
template < class _RanIt,
 class _Pr > inline
 void pop_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2092 );
 _Debug_heap ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 _Pop_heap_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2098
template < class _RanIt > inline
 void pop_heap ( _RanIt _First, _RanIt _Last )
 {
 :: std :: pop_heap ( _First, _Last, less < > ( ) );
 }
#line 2105
template < class _RanIt,
 class _Pr > inline
 void _Make_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 _Iter_diff_t < _RanIt > _Bottom = _Last - _First;
 if ( 2 <= _Bottom )
  {
  for ( _Iter_diff_t < _RanIt > _Hole = _Bottom / 2; 0 < _Hole; )
   {
   -- _Hole;
   _Iter_value_t < _RanIt > _Val = :: std :: move ( * ( _First + _Hole ) );
   _Pop_heap_hole_by_index ( _First, _Hole, _Bottom,
    :: std :: move ( _Val ), _Pred );
   }
  }
 }
#line 2122
template < class _RanIt,
 class _Pr > inline
 void make_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2126 );
 _Make_heap_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2131
template < class _RanIt > inline
 void make_heap ( _RanIt _First, _RanIt _Last )
 {
 :: std :: make_heap ( _First, _Last, less < > ( ) );
 }
#line 2138
template < class _RanIt,
 class _Pr > inline
 void _Sort_heap_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 for (; 2 <= _Last - _First; -- _Last )
  _Pop_heap_unchecked ( _First, _Last, _Pred );
 }
#line 2146
template < class _RanIt,
 class _Pr > inline
 void sort_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2150 );
 _Debug_pointer_if ( 2 <= _Last - _First, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2151 );
 _Debug_heap ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 _Sort_heap_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2157
template < class _RanIt > inline
 void sort_heap ( _RanIt _First, _RanIt _Last )
 {
 :: std :: sort_heap ( _First, _Last, less < > ( ) );
 }
#line 2164
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt _Lower_bound_unchecked ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr & _Pred )
 {
 _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _First, _Last );

 while ( 0 < _Count )
  {
  _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Pred ( * _Mid, _Val ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }

 return ( _First );
 }
#line 2190
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2196 );
 return ( _Rechecked ( _First,
  _Lower_bound_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val, _Pred ) ) );
 }
#line 2202
template < class _FwdIt,
 class _Ty > inline
 _FwdIt lower_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 return ( :: std :: lower_bound ( _First, _Last, _Val, less < > ( ) ) );
 }
#line 2210
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt _Upper_bound_unchecked ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr & _Pred )
 {
 _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _First, _Last );

 while ( 0 < _Count )
  {
  _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( ! _Pred ( _Val, * _Mid ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }

 return ( _First );
 }
#line 2236
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2242 );
 return ( _Rechecked ( _First,
  _Upper_bound_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val, _Pred ) ) );
 }
#line 2248
template < class _FwdIt,
 class _Ty > inline
 _FwdIt upper_bound ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 return ( :: std :: upper_bound ( _First, _Last, _Val, less < > ( ) ) );
 }
#line 2256
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 pair < _FwdIt, _FwdIt >
  _Equal_range_unchecked ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val, _Pr & _Pred )
 {
 _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _First, _Last );

 while ( 0 < _Count )
  {
  _Iter_diff_t < _FwdIt > _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Debug_lt_pred ( _Pred, * _Mid, _Val, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2271 ) )
   {
   _First = ++ _Mid;
   _Count -= _Count2 + 1;
   }
  else if ( _Pred ( _Val, * _Mid ) )
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = _Lower_bound_unchecked ( _First, _Mid, _Val, _Pred );
   :: std :: advance ( _First, _Count );
   _FwdIt _Last2 = _Upper_bound_unchecked ( ++ _Mid, _First, _Val, _Pred );
   return ( pair < _FwdIt, _FwdIt > ( _First2, _Last2 ) );
   }
  }

 return ( pair < _FwdIt, _FwdIt > ( _First, _First ) );
 }
#line 2290
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 pair < _FwdIt, _FwdIt >
  equal_range ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2297 );
 return ( _Rechecked_both ( _First, _Last,
  _Equal_range_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val, _Pred ) ) );
 }
#line 2303
template < class _FwdIt,
 class _Ty > inline
 pair < _FwdIt, _FwdIt >
  equal_range ( _FwdIt _First, _FwdIt _Last,
   const _Ty & _Val )
 {
 return ( :: std :: equal_range ( _First, _Last, _Val, less < > ( ) ) );
 }
#line 2313
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 bool _Binary_search_unchecked ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr & _Pred )
 {
 _First = _Lower_bound_unchecked ( _First, _Last, _Val, _Pred );
 return ( _First != _Last && ! _Pred ( _Val, * _First ) );
 }
#line 2323
template < class _FwdIt,
 class _Ty,
 class _Pr > inline
 bool binary_search ( _FwdIt _First, _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2329 );
 return ( _Binary_search_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ),
  _Val, _Pred ) );
 }
#line 2335
template < class _FwdIt,
 class _Ty > inline
 bool binary_search ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 return ( :: std :: binary_search ( _First, _Last, _Val, less < > ( ) ) );
 }
#line 2343
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Merge_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred )
 {
 if ( _First1 != _Last1 && _First2 != _Last2 )
  for (;; )
   {
   if ( _Debug_lt_pred ( _Pred, * _First2, * _First1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2354 ) )
    {
    * _Dest ++ = * _First2 ++;
    if ( _First2 == _Last2 )
     break;
    }
   else
    {
    * _Dest ++ = * _First1 ++;
    if ( _First1 == _Last1 )
     break;
    }
   }

 _Dest = _Copy_unchecked ( _First1, _Last1, _Dest );
 return ( _Copy_unchecked ( _First2, _Last2, _Dest ) );
 }
#line 2372
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Merge_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred, input_iterator_tag,
  input_iterator_tag, _Any_tag )
 {
 return ( _Rechecked ( _Dest,
  _Merge_unchecked ( _First1, _Last1, _First2, _Last2, _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 2385
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Merge_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred, random_access_iterator_tag,
  random_access_iterator_tag, random_access_iterator_tag )
 {
 static_cast < void > ( ( _Dest ) + ( ( _Last1 - _First1 ) + ( _Last2 - _First2 ) ) );
 return ( _Rechecked ( _Dest,
  _Merge_unchecked ( _First1, _Last1, _First2, _Last2, _Unchecked ( _Dest ), _Pred ) ) );
 }
#line 2399
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Merge_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_order ( _First1, _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2407 );
 _Debug_order ( _First2, _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2408 );
 _Debug_pointer_if ( _First1 != _Last1 || _First2 != _Last2, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2409 );
 return ( _Merge_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Dest, _Pred,
  _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _InIt2 > ( ), _Iter_cat_t < _OutIt > ( ) ) );
 }
#line 2416
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::merge\' with parameters that may be unsafe - this call relies on the caller to check that the passed values are c" "orrect. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterators\'" "" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Merge_no_deprecate ( _First1, _Last1, _First2, _Last2, _Dest, _Pred ) );
 }
#line 2429
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Merge_no_deprecate ( _First1, _Last1,
   _First2, _Last2,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 2446 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( :: std :: merge ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 2458
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * merge ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: merge ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 2472 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _BidIt1,
 class _BidIt2,
 class _BidIt3,
 class _Pr > inline
 _BidIt3 _Buffered_merge_backward_unchecked ( _BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr & _Pred,
  bool _In_place = false )
 {
 if ( _First1 != _Last1 && _First2 != _Last2 )
  for (;; )
   {
   if ( _Debug_lt_pred ( _Pred, * -- _Last2, * -- _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2483 ) )
    {
    * -- _Dest = :: std :: move ( * _Last1 );
    ++ _Last2;
    if ( _First1 == _Last1 )
     break;
    }
   else
    {
    * -- _Dest = :: std :: move ( * _Last2 );
    ++ _Last1;
    if ( _First2 == _Last2 )
     break;
    }
   }

 _Dest = _Move_backward_unchecked ( _First2, _Last2, _Dest );
 if ( ! _In_place )
  _Dest = _Move_backward_unchecked ( _First1, _Last1, _Dest );
 return ( _Dest );
 }
#line 2505
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Buffered_merge_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred, bool _In_place = false )
 {
 if ( _First1 != _Last1 && _First2 != _Last2 )
  for (;; )
   {
   if ( _Debug_lt_pred ( _Pred, * _First2, * _First1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2516 ) )
    {
    * _Dest ++ = :: std :: move ( * _First2 ++ );
    if ( _First2 == _Last2 )
     break;
    }
   else
    {
    * _Dest ++ = :: std :: move ( * _First1 ++ );
    if ( _First1 == _Last1 )
     break;
    }
   }

 _Dest = _Move_unchecked ( _First1, _Last1, _Dest );
 if ( ! _In_place )
  _Dest = _Move_unchecked ( _First2, _Last2, _Dest );
 return ( _Dest );
 }
#line 2536
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Buffered_merge_unchecked ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator < _Ty > & _Tempbuf, _Pr & _Pred )
 {
 if ( _Count1 == 0 || _Count2 == 0 )
  ;
 else if ( _Count1 + _Count2 == 2 )
  {
  if ( _Debug_lt_pred ( _Pred, * _Mid, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2548 ) )
   :: std :: iter_swap ( _First, _Mid );
  }
 else if ( _Count1 <= _Count2 && _Count1 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move_unchecked ( _First, _Mid, _Tempbuf . _Init ( ) );
  _Buffered_merge_unchecked ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ),
   _Mid, _Last, _First, _Pred, true );
  }
 else if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
  {
  _Move_unchecked ( _Mid, _Last, _Tempbuf . _Init ( ) );
  _Buffered_merge_backward_unchecked ( _First, _Mid,
   _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _Last, _Pred, true );
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;
  if ( _Count2 < _Count1 )
   {
   _Count1n = _Count1 / 2;
   _Firstn = _First;
   :: std :: advance ( _Firstn, _Count1n );
   _Lastn = _Lower_bound_unchecked ( _Mid, _Last, * _Firstn, _Pred );
   _Count2n = :: std :: distance ( _Mid, _Lastn );
   }
  else
   {
   _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   :: std :: advance ( _Lastn, _Count2n );
   _Firstn = _Upper_bound_unchecked ( _First, _Mid, * _Lastn, _Pred );
   _Count1n = :: std :: distance ( _First, _Firstn );
   }
  _BidIt _Midn = _Buffered_rotate_unchecked ( _Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf );
  _Buffered_merge_unchecked ( _First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf, _Pred );
  _Buffered_merge_unchecked ( _Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred );
  }
 }
#line 2592
template < class _BidIt,
 class _Pr > inline
 void _Inplace_merge_unchecked ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr & _Pred )
 {
 if ( _First != _Mid && _Mid != _Last )
  {
  _Iter_diff_t < _BidIt > _Count1 = :: std :: distance ( _First, _Mid );
  _Iter_diff_t < _BidIt > _Count2 = :: std :: distance ( _Mid, _Last );
  _Temp_iterator < _Iter_value_t < _BidIt >> _Tempbuf ( _Count1 < _Count2 ? _Count1 : _Count2 );
  _Buffered_merge_unchecked ( _First, _Mid, _Last,
   _Count1, _Count2, _Tempbuf, _Pred );
  }
 }
#line 2606
template < class _BidIt,
 class _Pr > inline
 void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred )
 {
 _Debug_order ( _First, _Mid, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2610 );
 _Debug_order ( _Mid, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2611 );
 _Inplace_merge_unchecked (
  _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ), _Pred );
 }
#line 2617
template < class _BidIt > inline
 void inplace_merge ( _BidIt _First, _BidIt _Mid, _BidIt _Last )
 {
 :: std :: inplace_merge ( _First, _Mid, _Last, less < > ( ) );
 }
#line 2624
template < class _BidIt,
 class _Pr > inline
 void _Insertion_sort_unchecked ( _BidIt _First, _BidIt _Last, _Pr & _Pred )
 {
 if ( _First != _Last )
  for ( _BidIt _Next = _First; ++ _Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Iter_value_t < _BidIt > _Val = :: std :: move ( * _Next );

   if ( _Debug_lt_pred ( _Pred, _Val, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2634 ) )
    {
    _Move_backward_unchecked ( _First, _Next, ++ _Next1 );
    * _First = :: std :: move ( _Val );
    }
   else
    {
    for ( _BidIt _First1 = _Next1;
     _Debug_lt_pred ( _Pred, _Val, * -- _First1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2642 );
     _Next1 = _First1 )
     * _Next1 = :: std :: move ( * _First1 );
    * _Next1 = :: std :: move ( _Val );
    }
   }
 }
#line 2650
template < class _RanIt,
 class _Pr > inline
 void _Med3_unchecked ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr & _Pred )
 {
 if ( _Debug_lt_pred ( _Pred, * _Mid, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2654 ) )
  :: std :: iter_swap ( _Mid, _First );
 if ( _Debug_lt_pred ( _Pred, * _Last, * _Mid, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2656 ) )
  {
  :: std :: iter_swap ( _Last, _Mid );
  if ( _Debug_lt_pred ( _Pred, * _Mid, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2659 ) )
   :: std :: iter_swap ( _Mid, _First );
  }
 }
#line 2664
template < class _RanIt,
 class _Pr > inline
 void _Guess_median_unchecked ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr & _Pred )
 {
 if ( 40 < _Last - _First )
  {
  size_t _Step = ( _Last - _First + 1 ) / 8;
  _Med3_unchecked ( _First, _First + _Step, _First + 2 * _Step, _Pred );
  _Med3_unchecked ( _Mid - _Step, _Mid, _Mid + _Step, _Pred );
  _Med3_unchecked ( _Last - 2 * _Step, _Last - _Step, _Last, _Pred );
  _Med3_unchecked ( _First + _Step, _Mid, _Last - _Step, _Pred );
  }
 else
  _Med3_unchecked ( _First, _Mid, _Last, _Pred );
 }
#line 2680
template < class _RanIt,
 class _Pr > inline
 pair < _RanIt, _RanIt >
  _Partition_by_median_guess_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 _RanIt _Mid = _First + ( _Last - _First ) / 2;
 _Guess_median_unchecked ( _First, _Mid, _Last - 1, _Pred );
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while ( _First < _Pfirst
  && ! _Debug_lt_pred ( _Pred, * ( _Pfirst - 1 ), * _Pfirst, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2691 )
  && ! _Pred ( * _Pfirst, * ( _Pfirst - 1 ) ) )
  -- _Pfirst;
 while ( _Plast < _Last
  && ! _Debug_lt_pred ( _Pred, * _Plast, * _Pfirst, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2695 )
  && ! _Pred ( * _Pfirst, * _Plast ) )
  ++ _Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (;; )
  {
  for (; _Gfirst < _Last; ++ _Gfirst )
   if ( _Debug_lt_pred ( _Pred, * _Pfirst, * _Gfirst, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2705 ) )
    ;
   else if ( _Pred ( * _Gfirst, * _Pfirst ) )
    break;
   else if ( _Plast ++ != _Gfirst )
    :: std :: iter_swap ( _Plast - 1, _Gfirst );
  for (; _First < _Glast; -- _Glast )
   if ( _Debug_lt_pred ( _Pred, * ( _Glast - 1 ), * _Pfirst, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2712 ) )
    ;
   else if ( _Pred ( * _Pfirst, * ( _Glast - 1 ) ) )
    break;
   else if ( -- _Pfirst != _Glast - 1 )
    :: std :: iter_swap ( _Pfirst, _Glast - 1 );
  if ( _Glast == _First && _Gfirst == _Last )
   return ( pair < _RanIt, _RanIt > ( _Pfirst, _Plast ) );

  if ( _Glast == _First )
   {
   if ( _Plast != _Gfirst )
    :: std :: iter_swap ( _Pfirst, _Plast );
   ++ _Plast;
   :: std :: iter_swap ( _Pfirst ++, _Gfirst ++ );
   }
  else if ( _Gfirst == _Last )
   {
   if ( -- _Glast != -- _Pfirst )
    :: std :: iter_swap ( _Glast, _Pfirst );
   :: std :: iter_swap ( _Pfirst, -- _Plast );
   }
  else
   :: std :: iter_swap ( _Gfirst ++, -- _Glast );
  }
 }
#line 2739
template < class _RanIt,
 class _Diff,
 class _Pr > inline
 void _Sort_unchecked1 ( _RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr & _Pred )
 {
 _Diff _Count;
 while ( _ISORT_MAX < ( _Count = _Last - _First ) && 0 < _Ideal )
  {
  pair < _RanIt, _RanIt > _Mid =
   _Partition_by_median_guess_unchecked ( _First, _Last, _Pred );
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if ( _Mid . first - _First < _Last - _Mid . second )
   {
   _Sort_unchecked1 ( _First, _Mid . first, _Ideal, _Pred );
   _First = _Mid . second;
   }
  else
   {
   _Sort_unchecked1 ( _Mid . second, _Last, _Ideal, _Pred );
   _Last = _Mid . first;
   }
  }

 if ( _ISORT_MAX < _Count )
  {
  _Make_heap_unchecked ( _First, _Last, _Pred );
  _Sort_heap_unchecked ( _First, _Last, _Pred );
  }
 else if ( 2 <= _Count )
  _Insertion_sort_unchecked ( _First, _Last, _Pred );
 }
#line 2772
template < class _RanIt,
 class _Pr > inline
 void _Sort_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 _Sort_unchecked1 ( _First, _Last, _Last - _First, _Pred );
 }
#line 2779
template < class _RanIt,
 class _Pr > inline
 void sort ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2783 );
 _Sort_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2788
template < class _RanIt > inline
 void sort ( _RanIt _First, _RanIt _Last )
 {
 :: std :: sort ( _First, _Last, less < > ( ) );
 }
#line 2795
template < class _BidIt,
 class _OutIt,
 class _Diff,
 class _Pr > inline
 void _Chunked_merge_unchecked ( _BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr & _Pred )
 {
 for ( _Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2 )
  {
  _BidIt _Mid1 = _First;
  :: std :: advance ( _Mid1, _Chunk );
  _BidIt _Mid2 = _Mid1;
  :: std :: advance ( _Mid2, _Chunk );

  _Dest = _Buffered_merge_unchecked ( _First, _Mid1, _Mid1, _Mid2, _Dest, _Pred );
  _First = _Mid2;
  }

 if ( _Count <= _Chunk )
  _Move_unchecked ( _First, _Last, _Dest );
 else
  {
  _BidIt _Mid1 = _First;
  :: std :: advance ( _Mid1, _Chunk );

  _Buffered_merge_unchecked ( _First, _Mid1, _Mid1, _Last, _Dest, _Pred );
  }
 }
#line 2824
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Buffered_merge_sort_unchecked ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf, _Pr & _Pred )
 {
 _BidIt _Mid = _First;
 for ( _Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX )
  {
  _BidIt _Midn = _Mid;
  :: std :: advance ( _Midn, ( int ) _ISORT_MAX );

  _Insertion_sort_unchecked ( _Mid, _Midn, _Pred );
  _Mid = _Midn;
  }
 _Insertion_sort_unchecked ( _Mid, _Last, _Pred );

 for ( _Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2 )
  {
  _Chunked_merge_unchecked ( _First, _Last, _Tempbuf . _Init ( ),
   _Chunk, _Count, _Pred );
  _Chunked_merge_unchecked ( _Tempbuf . _First ( ), _Tempbuf . _Last ( ), _First,
   _Chunk *= 2, _Count, _Pred );
  }
 }
#line 2851
template < class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr > inline
 void _Stable_sort_unchecked1 ( _BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator < _Ty > & _Tempbuf, _Pr & _Pred )
 {
 if ( _Count <= _ISORT_MAX )
  _Insertion_sort_unchecked ( _First, _Last, _Pred );
 else
  {
  _Diff _Count2 = ( _Count + 1 ) / 2;
  _BidIt _Mid = _First;
  :: std :: advance ( _Mid, _Count2 );

  if ( _Count2 <= _Tempbuf . _Maxlen ( ) )
   {
   _Buffered_merge_sort_unchecked ( _First, _Mid, _Count2, _Tempbuf, _Pred );
   _Buffered_merge_sort_unchecked ( _Mid, _Last, _Count - _Count2,
    _Tempbuf, _Pred );
   }
  else
   {
   _Stable_sort_unchecked1 ( _First, _Mid, _Count2, _Tempbuf, _Pred );
   _Stable_sort_unchecked1 ( _Mid, _Last, _Count - _Count2, _Tempbuf, _Pred );
   }

  _Buffered_merge_unchecked ( _First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf, _Pred );
  }
 }
#line 2883
template < class _BidIt,
 class _Pr > inline
 void _Stable_sort_unchecked ( _BidIt _First, _BidIt _Last, _Pr & _Pred )
 {
 if ( _First != _Last )
  {
  _Iter_diff_t < _BidIt > _Count = :: std :: distance ( _First, _Last );
  _Temp_iterator < _Iter_value_t < _BidIt >> _Tempbuf ( ( _Count + 1 ) / 2 );
  _Stable_sort_unchecked1 ( _First, _Last, _Count, _Tempbuf, _Pred );
  }
 }
#line 2895
template < class _BidIt,
 class _Pr > inline
 void stable_sort ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2899 );
 _Stable_sort_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred );
 }
#line 2904
template < class _BidIt > inline
 void stable_sort ( _BidIt _First, _BidIt _Last )
 {
 :: std :: stable_sort ( _First, _Last, less < > ( ) );
 }
#line 2911
template < class _RanIt,
 class _Pr > inline
 void _Partial_sort_unchecked ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  _Pr & _Pred )
 {
 if ( _First == _Mid )
  return;
 _Make_heap_unchecked ( _First, _Mid, _Pred );
 for ( _RanIt _Next = _Mid; _Next < _Last; ++ _Next )
  if ( _Debug_lt_pred ( _Pred, * _Next, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2920 ) )
   {
   _Iter_value_t < _RanIt > _Val = :: std :: move ( * _Next );
   _Pop_heap_hole_unchecked ( _First, _Mid, _Next, :: std :: move ( _Val ), _Pred );
   }
 _Sort_heap_unchecked ( _First, _Mid, _Pred );
 }
#line 2928
template < class _RanIt,
 class _Pr > inline
 void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Mid, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2932 );
 _Debug_range ( _Mid, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2933 );
 _Debug_pointer_if ( 2 <= _Last - _First, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2934 );
 _Partial_sort_unchecked (
  _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ), _Pred );
 }
#line 2940
template < class _RanIt > inline
 void partial_sort ( _RanIt _First, _RanIt _Mid, _RanIt _Last )
 {
 :: std :: partial_sort ( _First, _Mid, _Last, less < > ( ) );
 }
#line 2947
template < class _InIt,
 class _RanIt,
 class _Pr > inline
 _RanIt _Partial_sort_copy_unchecked ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr & _Pred )
 {
 _RanIt _Mid2 = _First2;
 if ( _First1 != _Last1 && _First2 != _Last2 )
  {
  for (; _First1 != _Last1 && _Mid2 != _Last2; ++ _First1, ( void ) ++ _Mid2 )
   * _Mid2 = * _First1;
  _Make_heap_unchecked ( _First2, _Mid2, _Pred );

  for (; _First1 != _Last1; ++ _First1 )
   if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2961 ) )
    _Pop_heap_hole_by_index ( _First2, _Iter_diff_t < _RanIt > ( 0 ), _Iter_diff_t < _RanIt > ( _Mid2 - _First2 ),
     _Iter_value_t < _InIt > ( * _First1 ), _Pred );

  _Sort_heap_unchecked ( _First2, _Mid2, _Pred );
  }

 return ( _Mid2 );
 }
#line 2971
template < class _InIt,
 class _RanIt,
 class _Pr > inline
 _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred )
 {
 _Debug_range ( _First1, _Last1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2977 );
 _Debug_range ( _First2, _Last2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 2978 );
 return ( _Rechecked ( _First2,
  _Partial_sort_copy_unchecked (
   _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
   _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) ) );
 }
#line 2986
template < class _InIt,
 class _RanIt > inline
 _RanIt partial_sort_copy ( _InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2 )
 {
 return ( :: std :: partial_sort_copy ( _First1, _Last1, _First2, _Last2,
  less < > ( ) ) );
 }
#line 2996
template < class _RanIt,
 class _Pr > inline
 void _Nth_element_unchecked ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr & _Pred )
 {
 if ( _Nth == _Last )
  return;

 for (; _ISORT_MAX < _Last - _First; )
  {
  pair < _RanIt, _RanIt > _Mid =
   _Partition_by_median_guess_unchecked ( _First, _Last, _Pred );

  if ( _Mid . second <= _Nth )
   _First = _Mid . second;
  else if ( _Mid . first <= _Nth )
   return;
  else
   _Last = _Mid . first;
  }

 _Insertion_sort_unchecked ( _First, _Last, _Pred );
 }
#line 3019
template < class _RanIt,
 class _Pr > inline
 void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Nth, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3023 );
 _Debug_range ( _Nth, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3024 );
 _Debug_pointer_if ( 2 <= _Last - _First, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3025 );
 _Nth_element_unchecked (
  _Unchecked ( _First ), _Unchecked ( _Nth ), _Unchecked ( _Last ), _Pred );
 }
#line 3031
template < class _RanIt > inline
 void nth_element ( _RanIt _First, _RanIt _Nth, _RanIt _Last )
 {
 :: std :: nth_element ( _First, _Nth, _Last, less < > ( ) );
 }
#line 3038
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Includes_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Debug_lt_pred ( _Pred, * _First2, * _First1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3045 ) )
   return ( false );
  else if ( _Pred ( * _First1, * _First2 ) )
   ++ _First1;
  else
   {
   ++ _First1;
   ++ _First2;
   }

 return ( _First2 == _Last2 );
 }
#line 3058
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 _Debug_order ( _First1, _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3064 );
 _Debug_order ( _First2, _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3065 );
 return ( _Includes_unchecked ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) );
 }
#line 3071
template < class _InIt1,
 class _InIt2 > inline
 bool includes ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 return ( :: std :: includes ( _First1, _Last1, _First2, _Last2,
  less < > ( ) ) );
 }
#line 3081
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_union_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3089 ) )
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( _Pred ( * _First2, * _First1 ) )
   {
   * _Dest ++ = * _First2;
   ++ _First2;
   }
  else
   {
   * _Dest ++ = * _First1;
   ++ _First1;
   ++ _First2;
   }
 _Dest = _Copy_no_deprecate ( _First1, _Last1, _Dest );
 return ( _Copy_no_deprecate ( _First2, _Last2, _Dest ) );
 }
#line 3109
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_union_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_order ( _First1, _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3116 );
 _Debug_order ( _First2, _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3117 );
 _Debug_pointer_if ( _First1 != _Last1 || _First2 != _Last2, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3118 );
 return ( _Rechecked ( _Dest,
  _Set_union_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 3125
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::set_union\' with parameters that may be unsafe - this call relies on the caller to check that the passed values a" "re correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked Iterato" "rs\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Set_union_no_deprecate ( _First1, _Last1, _First2, _Last2, _Dest, _Pred ) );
 }
#line 3137
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Set_union_no_deprecate ( _First1, _Last1,
   _First2, _Last2,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 3153 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return ( :: std :: set_union ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 3164
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * set_union ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: set_union ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 3177 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_intersection_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3185 ) )
   ++ _First1;
  else if ( _Pred ( * _First2, * _First1 ) )
   ++ _First2;
  else
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3191 );
   * _Dest ++ = * _First1 ++;
   ++ _First2;
   }

 return ( _Dest );
 }
#line 3199
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_intersection_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_order ( _First1, _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3206 );
 _Debug_order ( _First2, _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3207 );
 return ( _Rechecked ( _Dest,
  _Set_intersection_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 3214
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::set_intersection\' with parameters that may be unsafe - this call relies on the caller to check that the passed v" "alues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked " "Iterators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Set_intersection_no_deprecate ( _First1, _Last1, _First2, _Last2, _Dest, _Pred ) );
 }
#line 3226
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Set_intersection_no_deprecate ( _First1, _Last1,
   _First2, _Last2,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 3242 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest )
 {
 return ( :: std :: set_intersection ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 3253
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * set_intersection ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: set_intersection ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 3266 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_difference_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3275 ) )
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3277 );
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( _Pred ( * _First2, * _First1 ) )
   ++ _First2;
  else
   {
   ++ _First1;
   ++ _First2;
   }

 return ( _Copy_no_deprecate ( _First1, _Last1, _Dest ) );
 }
#line 3292
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_difference_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_order ( _First1, _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3300 );
 _Debug_order ( _First2, _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3301 );
 return ( _Rechecked ( _Dest,
  _Set_difference_no_deprecate1 ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 3308
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::set_difference\' with parameters that may be unsafe - this call relies on the caller to check that the passed val" "ues are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checked It" "erators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Set_difference_no_deprecate ( _First1, _Last1, _First2, _Last2, _Dest, _Pred ) );
 }
#line 3321
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Set_difference_no_deprecate ( _First1, _Last1,
   _First2, _Last2,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 3338 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( :: std :: set_difference ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 3350
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * set_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: set_difference ( _First1, _Last1, _First2, _Last2, _Dest,
  less < > ( ) ) );
 }
#line 3364 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_symmetric_difference_no_deprecate1 ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3373 ) )
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3375 );
   * _Dest ++ = * _First1;
   ++ _First1;
   }
  else if ( _Pred ( * _First2, * _First1 ) )
   {
   _Debug_pointer ( _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3381 );
   * _Dest ++ = * _First2;
   ++ _First2;
   }
  else
   {
   ++ _First1;
   ++ _First2;
   }
 _Dest = _Copy_no_deprecate ( _First1, _Last1, _Dest );
 return ( _Copy_no_deprecate ( _First2, _Last2, _Dest ) );
 }
#line 3394
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt _Set_symmetric_difference_no_deprecate ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr & _Pred )
 {
 _Debug_order ( _First1, _Last1, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3402 );
 _Debug_order ( _First2, _Last2, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3403 );
 return ( _Rechecked ( _Dest,
  _Set_symmetric_difference_no_deprecate1 (
  _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ),
  _Unchecked_idl0 ( _Dest ), _Pred ) ) );
 }
#line 3411
template < class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr > inline
 _OutIt set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred )
 {
 struct _Unchecked_iterators { static void __declspec ( deprecated ( "Call to \'std::set_symmetric_difference\' with parameters that may be unsafe - this call relies on the caller to check that the " "passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'" "Checked Iterators\'" ) ) _Deprecate ( false_type ) { } static void _Deprecate ( true_type ) { } }; ( _Unchecked_iterators :: _Deprecate ( _Is_checked ( _Dest ) ) );
 return ( _Set_symmetric_difference_no_deprecate (
  _First1, _Last1, _First2, _Last2, _Dest, _Pred ) );
 }
#line 3425
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize,
 class _Pr > inline
 _OutTy * set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutTy ( & _Dest ) [ _OutSize ], _Pr _Pred )
 {
 return ( _Unchecked (
  _Set_symmetric_difference_no_deprecate ( _First1, _Last1,
   _First2, _Last2,
   _Array_iterator < _OutTy, _OutSize > ( _Dest ), _Pred ) ) );
 }
#line 3442 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _InIt1,
 class _InIt2,
 class _OutIt > inline
 _OutIt set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest )
 {
 return ( :: std :: set_symmetric_difference ( _First1, _Last1, _First2, _Last2,
  _Dest, less < > ( ) ) );
 }
#line 3454
template < class _InIt1,
 class _InIt2,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * set_symmetric_difference ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: set_symmetric_difference ( _First1, _Last1, _First2, _Last2,
  _Dest, less < > ( ) ) );
 }
#line 3468 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Max_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( _Debug_lt_pred ( _Pred, * _Found, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3475 ) )
    _Found = _First;
 return ( _Found );
 }
#line 3480
template < class _FwdIt,
 class _Pr > inline
 _FwdIt max_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3484 );
 return ( _Rechecked ( _First,
  _Max_element_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 3490
template < class _FwdIt > inline
 _FwdIt max_element ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: max_element ( _First, _Last, less < > ( ) ) );
 }
#line 3497
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Min_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 _FwdIt _Found = _First;
 if ( _First != _Last )
  for (; ++ _First != _Last; )
   if ( _Debug_lt_pred ( _Pred, * _First, * _Found, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3504 ) )
    _Found = _First;
 return ( _Found );
 }
#line 3509
template < class _FwdIt,
 class _Pr > inline
 _FwdIt min_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3513 );
 return ( _Rechecked ( _First,
  _Min_element_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 3519
template < class _FwdIt > inline
 _FwdIt min_element ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: min_element ( _First, _Last, less < > ( ) ) );
 }
#line 3526
template < class _FwdIt,
 class _Pr > inline
 pair < _FwdIt, _FwdIt >
  _Minmax_element_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 pair < _FwdIt, _FwdIt > _Found ( _First, _First );

 if ( _First != _Last )
  for (; ++ _First != _Last; )
   {
   _FwdIt _Next = _First;
   if ( ++ _Next == _Last )
    {
    if ( _Debug_lt_pred ( _Pred, * _First, * _Found . first, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3539 ) )
     _Found . first = _First;
    else if ( ! _Debug_lt_pred ( _Pred, * _First, * _Found . second, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3541 ) )
     _Found . second = _First;
    }
   else
    {
    if ( _Debug_lt_pred ( _Pred, * _Next, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3546 ) )
     {
     if ( _Debug_lt_pred ( _Pred, * _Next, * _Found . first, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3548 ) )
      _Found . first = _Next;
     if ( ! _Debug_lt_pred ( _Pred, * _First, * _Found . second, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3550 ) )
      _Found . second = _First;
     }
    else
     {
     if ( _Debug_lt_pred ( _Pred, * _First, * _Found . first, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3555 ) )
      _Found . first = _First;
     if ( ! _Debug_lt_pred ( _Pred, * _Next, * _Found . second, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3557 ) )
      _Found . second = _Next;
     }
    _First = _Next;
    }
   }

 return ( _Found );
 }
#line 3567
template < class _FwdIt,
 class _Pr > inline
 pair < _FwdIt, _FwdIt >
  minmax_element ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3572 );
 return ( _Rechecked_both ( _First, _Last,
  _Minmax_element_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 3578
template < class _FwdIt > inline
 pair < _FwdIt, _FwdIt >
  minmax_element ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: minmax_element ( _First, _Last, less < > ( ) ) );
 }
#line 3586
template < class _Ty,
 class _Pr > inline
 constexpr const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right,
  _Pr _Pred )
  noexcept ( noexcept ( _Debug_lt_pred ( _Pred, _Left, _Right, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3590 ) ) )
 {
 return ( _Debug_lt_pred ( _Pred, _Left, _Right, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3592 ) ? _Right : _Left );
 }
#line 3595
template < class _Ty,
 class _Pr > inline

 _Ty ( max ) ( :: std :: initializer_list < _Ty > _Ilist, _Pr _Pred )
 {
 const _Ty * _Res = _Max_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), _Pred );
 return ( * _Res );
 }
#line 3605
template < class _Ty > inline



 constexpr const _Ty & ( max ) ( const _Ty & _Left, const _Ty & _Right )
  noexcept ( noexcept ( _Debug_lt ( _Left, _Right, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3610 ) ) )
 {
 return ( _Debug_lt ( _Left, _Right, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3612 ) ? _Right : _Left );
 }
#line 3615
template < class _Ty > inline

 _Ty ( max ) ( :: std :: initializer_list < _Ty > _Ilist )
 {
 return ( ( :: std :: max ) ( _Ilist, less < > ( ) ) );
 }
#line 3623
template < class _Ty,
 class _Pr > inline
 constexpr const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right,
  _Pr _Pred )
  noexcept ( noexcept ( _Debug_lt_pred ( _Pred, _Right, _Left, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3627 ) ) )
 {
 return ( _Debug_lt_pred ( _Pred, _Right, _Left, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3629 ) ? _Right : _Left );
 }
#line 3632
template < class _Ty,
 class _Pr > inline

 _Ty ( min ) ( :: std :: initializer_list < _Ty > _Ilist, _Pr _Pred )
 {
 const _Ty * _Res = _Min_element_unchecked ( _Ilist . begin ( ), _Ilist . end ( ), _Pred );
 return ( * _Res );
 }
#line 3642
template < class _Ty > inline



 constexpr const _Ty & ( min ) ( const _Ty & _Left, const _Ty & _Right )
  noexcept ( noexcept ( _Debug_lt ( _Right, _Left, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3647 ) ) )
 {
 return ( _Debug_lt ( _Right, _Left, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3649 ) ? _Right : _Left );
 }
#line 3652
template < class _Ty > inline

 _Ty ( min ) ( :: std :: initializer_list < _Ty > _Ilist )
 {
 return ( ( :: std :: min ) ( _Ilist, less < > ( ) ) );
 }
#line 3661
template < class _Ty,
 class _Pr > inline
 constexpr pair < const _Ty &, const _Ty & >
  minmax ( const _Ty & _Left, const _Ty & _Right, _Pr _Pred )
 {
 return ( _Pred ( _Right, _Left )
  ? pair < const _Ty &, const _Ty & > ( _Right, _Left )
  : pair < const _Ty &, const _Ty & > ( _Left, _Right ) );
 }
#line 3671
template < class _Ty,
 class _Pr > inline

 pair < _Ty, _Ty > minmax ( :: std :: initializer_list < _Ty > _Ilist,
  _Pr _Pred )
 {
 pair < const _Ty *, const _Ty * > _Res = _Minmax_element_unchecked (
  _Ilist . begin ( ), _Ilist . end ( ), _Pred );
 return ( pair < _Ty, _Ty > ( * _Res . first, * _Res . second ) );
 }
#line 3683
template < class _Ty > inline
 constexpr pair < const _Ty &, const _Ty & >
  minmax ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left
  ? pair < const _Ty &, const _Ty & > ( _Right, _Left )
  : pair < const _Ty &, const _Ty & > ( _Left, _Right ) );
 }
#line 3692
template < class _Ty > inline

 pair < _Ty, _Ty > minmax ( :: std :: initializer_list < _Ty > _Ilist )
 {
 return ( :: std :: minmax ( _Ilist, less < > ( ) ) );
 }
#line 3700
template < class _BidIt,
 class _Pr > inline
 bool _Next_permutation_unchecked ( _BidIt _First, _BidIt _Last, _Pr & _Pred )
 {
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( _Debug_lt_pred ( _Pred, * -- _Next, * _Next1, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3711 ) )
   {
   _BidIt _Mid = _Last;
   for (; ! _Debug_lt_pred ( _Pred, * _Next, * -- _Mid, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3714 ); )
    ;
   :: std :: iter_swap ( _Next, _Mid );
   _Reverse_unchecked ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   _Reverse_unchecked ( _First, _Last );
   return ( false );
   }
  }
 }
#line 3729
template < class _BidIt,
 class _Pr > inline
 bool next_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3733 );
 return ( _Next_permutation_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 3738
template < class _BidIt > inline
 bool next_permutation ( _BidIt _First, _BidIt _Last )
 {
 return ( :: std :: next_permutation ( _First, _Last, less < > ( ) ) );
 }
#line 3745
template < class _BidIt,
 class _Pr > inline
 bool _Prev_permutation_unchecked ( _BidIt _First, _BidIt _Last, _Pr & _Pred )
 {
 _BidIt _Next = _Last;
 if ( _First == _Last || _First == -- _Next )
  return ( false );

 for (;; )
  {
  _BidIt _Next1 = _Next;
  if ( _Debug_lt_pred ( _Pred, * _Next1, * -- _Next, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3756 ) )
   {
   _BidIt _Mid = _Last;
   for (; ! _Debug_lt_pred ( _Pred, * -- _Mid, * _Next, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3759 ); )
    ;
   :: std :: iter_swap ( _Next, _Mid );
   _Reverse_unchecked ( _Next1, _Last );
   return ( true );
   }

  if ( _Next == _First )
   {
   _Reverse_unchecked ( _First, _Last );
   return ( false );
   }
  }
 }
#line 3774
template < class _BidIt,
 class _Pr > inline
 bool prev_permutation ( _BidIt _First, _BidIt _Last, _Pr _Pred )
 {
 _Debug_range_ptr ( _First, _Last, _Pred, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3778 );
 return ( _Prev_permutation_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) );
 }
#line 3783
template < class _BidIt > inline
 bool prev_permutation ( _BidIt _First, _BidIt _Last )
 {
 return ( :: std :: prev_permutation ( _First, _Last, less < > ( ) ) );
 }
#line 3790
template < class _RanIt,
 class _Pr > inline
 _RanIt _Is_heap_until_unchecked ( _RanIt _First, _RanIt _Last, _Pr & _Pred )
 {
 _Iter_diff_t < _RanIt > _Size = _Last - _First;

 if ( 2 <= _Size )
  for ( _Iter_diff_t < _RanIt > _Off = 0; ++ _Off < _Size; )
   if ( _Debug_lt_pred ( _Pred, * ( _First + ( _Off - 1 ) / 2 ), * ( _First + _Off ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3799 ) )

    return ( _First + _Off );
 return ( _Last );
 }
#line 3804 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
template < class _RanIt,
 class _Pr > inline
 _RanIt is_heap_until ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3808 );
 return ( _Rechecked ( _First,
  _Is_heap_until_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 3813
template < class _RanIt,
 class _Pr > inline
 bool is_heap ( _RanIt _First, _RanIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3817 );
 return ( _Is_heap_until_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) == _Unchecked ( _Last ) );
 }
#line 3822
template < class _RanIt > inline
 _RanIt is_heap_until ( _RanIt _First, _RanIt _Last )
 {
 return ( :: std :: is_heap_until ( _First, _Last, less < > ( ) ) );
 }
#line 3828
template < class _RanIt > inline
 bool is_heap ( _RanIt _First, _RanIt _Last )
 {
 return ( :: std :: is_heap ( _First, _Last, less < > ( ) ) );
 }
#line 3835
template < class _FwdIt,
 class _Pr > inline
 _FwdIt _Is_sorted_until_unchecked ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred )
 {
 if ( _First != _Last )
  for ( _FwdIt _Next = _First; ++ _Next != _Last; ++ _First )
   if ( _Debug_lt_pred ( _Pred, * _Next, * _First, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3841 ) )
    return ( _Next );
 return ( _Last );
 }
#line 3846
template < class _FwdIt,
 class _Pr > inline
 _FwdIt is_sorted_until ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3850 );
 return ( _Rechecked ( _First,
  _Is_sorted_until_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) ) );
 }
#line 3855
template < class _FwdIt,
 class _Pr > inline
 bool is_sorted ( _FwdIt _First, _FwdIt _Last, _Pr _Pred )
 {
 _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x61" L"\x6c\x67\x6f\x72\x69\x74\x68\x6d", 3859 );
 return ( _Is_sorted_until_unchecked ( _Unchecked ( _First ), _Unchecked ( _Last ), _Pred ) == _Unchecked ( _Last ) );
 }
#line 3864
template < class _FwdIt > inline
 _FwdIt is_sorted_until ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: is_sorted_until ( _First, _Last, less < > ( ) ) );
 }
#line 3870
template < class _FwdIt > inline
 bool is_sorted ( _FwdIt _First, _FwdIt _Last )
 {
 return ( :: std :: is_sorted ( _First, _Last, less < > ( ) ) );
 }
#line 3908 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
}
#line 3910
#pragma warning(pop)
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring"
#pragma warning(push,3)
#line 3911 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\algorithm"
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#pragma warning(disable: 4127)
#line 16
#pragma warning(disable: 4251)
#line 18
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Ax = allocator < _Elem > >
 class basic_string;
#line 24
template < class _Mystr >
 class _String_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   typename _Mystr :: value_type,
   typename _Mystr :: difference_type,
   typename _Mystr :: const_pointer,
   typename _Mystr :: const_reference,
   _Iterator_base >
 {
public :
 typedef _String_const_iterator < _Mystr > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr :: value_type value_type;
 typedef typename _Mystr :: difference_type difference_type;
 typedef typename _Mystr :: const_pointer pointer;
 typedef typename _Mystr :: const_reference reference;

 _String_const_iterator ( )
  : _Ptr ( )
  {
  }

 _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Ptr ( _Parg )
  {
  this -> _Adopt ( _Pstring );
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Ptr );
  }

 reference operator * ( ) const
  {

  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  const auto _Contptr = _Mycont ? _Mycont -> _Myptr ( ) : 0;
  if ( _Mycont == 0
   || _Ptr == nullptr_t { }
   || _Unfancy ( _Ptr ) < _Contptr
   || _Contptr + _Mycont -> _Mysize <= _Unfancy ( _Ptr ) )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62" L"\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 76 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 77, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 77, 0 ); };
   }









  ;

  return ( * _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {

  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || _Ptr == nullptr_t { }
   || _Mycont -> _Myptr ( ) + _Mycont -> _Mysize <= _Unfancy ( _Ptr ) )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 106 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 107, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 107, 0 ); };
   }








  ++ _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {

  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || _Ptr == nullptr_t { }
   || _Unfancy ( _Ptr ) <= _Mycont -> _Myptr ( ) )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 136 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 137, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 137, 0 ); };
   }








  -- _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {

  if ( _Off != 0 )
   {
   const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
   const auto _Contptr = _Mycont ? _Mycont -> _Myptr ( ) : 0;
   if ( _Mycont == 0
    || _Ptr == nullptr_t { }
    || _Unfancy ( _Ptr ) + _Off < _Contptr
    || _Contptr + _Mycont -> _Mysize < _Unfancy ( _Ptr ) + _Off )
    {
    _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x2b\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20" L"\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 170 );
    { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 171, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 171, 0 ); };
    }
   }













  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


 void _Compat ( const _Myiter & _Right ) const
  {
  if ( this -> _Getcont ( ) != _Right . _Getcont ( ) )
   {
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 256 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Invalid Argument" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 257, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x49\x6e\x76\x61\x6c\x69\x64\x20" L"\x41\x72\x67\x75\x6d\x65\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 257, 0 ); };
   }
  }













 pointer _Ptr;
 };
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring"
template < class _Mystr > inline
 typename _String_const_iterator < _Mystr > :: _Unchecked_type
  _Unchecked ( _String_const_iterator < _Mystr > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 283
template < class _Mystr > inline
 _String_const_iterator < _Mystr >
  _Rechecked ( _String_const_iterator < _Mystr > & _Iter,
   typename _String_const_iterator < _Mystr >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 292
template < class _Mystr > inline
 _String_const_iterator < _Mystr > operator + (
  typename _String_const_iterator < _Mystr >
   :: difference_type _Off,
  _String_const_iterator < _Mystr > _Next )
 {
 return ( _Next += _Off );
 }
#line 302
template < class _Mystr >
 class _String_iterator
  : public _String_const_iterator < _Mystr >
 {
public :
 typedef _String_iterator < _Mystr > _Myiter;
 typedef _String_const_iterator < _Mystr > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr :: value_type value_type;
 typedef typename _Mystr :: difference_type difference_type;
 typedef typename _Mystr :: pointer pointer;
 typedef typename _Mystr :: reference reference;

 _String_iterator ( )
  {
  }

 _String_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Mybase ( _Parg, _Pstring )
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Const_cast ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 408
template < class _Mystr > inline
 typename _String_iterator < _Mystr > :: _Unchecked_type
  _Unchecked ( _String_iterator < _Mystr > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 415
template < class _Mystr > inline
 _String_iterator < _Mystr >
  _Rechecked ( _String_iterator < _Mystr > & _Iter,
   typename _String_iterator < _Mystr >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 424
template < class _Mystr > inline
 _String_iterator < _Mystr > operator + (
  typename _String_iterator < _Mystr >
   :: difference_type _Off,
  _String_iterator < _Mystr > _Next )
 {
 return ( _Next += _Off );
 }
#line 434
template< class _Value_type, class 
#line 435
_Size_type, class 
#line 436
_Difference_type, class 
#line 437
_Pointer, class 
#line 438
_Const_pointer, class 
#line 439
_Reference, class 
#line 440
_Const_reference> 
#line 441
struct _String_iter_types { 
#line 443
typedef _Value_type value_type; 
#line 444
typedef _Size_type size_type; 
#line 445
typedef _Difference_type difference_type; 
#line 446
typedef _Pointer pointer; 
#line 447
typedef _Const_pointer const_pointer; 
#line 448
typedef _Reference reference; 
#line 449
typedef _Const_reference const_reference; 
#line 450
}; 
#line 452
template< class _Ty, class 
#line 453
_Alloc0> 
#line 454
struct _String_base_types { 
#line 456
typedef _Alloc0 _Alloc; 
#line 457
typedef _String_base_types _Myt; 
#line 459
typedef _Wrap_alloc< _Alloc0>  _Alty0; 
#line 460
typedef typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other _Alty; 
#line 472
typedef typename _If< _Is_simple_alloc< typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other> ::value, _Simple_types< typename _Alty::value_type> , _String_iter_types< typename _Alty::value_type, typename _Alty::size_type, typename _Alty::difference_type, typename _Alty::pointer, typename _Alty::const_pointer, typename _Alty::reference, typename _Alty::const_reference> > ::type _Val_types; 
#line 473
}; 
#line 476
template < class _Val_types >
 class _String_val
  : public _Container_base
 {
public :
 typedef _String_val < _Val_types > _Myt;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;

 typedef _String_iterator < _Myt > iterator;
 typedef _String_const_iterator < _Myt > const_iterator;

 _String_val ( )
  : _Bx ( ),
  _Mysize ( 0 ),
  _Myres ( 0 )
  {
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof ( value_type ) < 1 ? 1
   : 16 / sizeof ( value_type ) };
 enum
  {
  _ALLOC_MASK = sizeof ( value_type ) <= 1 ? 15
   : sizeof ( value_type ) <= 2 ? 7
   : sizeof ( value_type ) <= 4 ? 3
   : sizeof ( value_type ) <= 8 ? 1 : 0 };

 value_type * _Myptr ( )
  {
  return ( this -> _BUF_SIZE <= _Myres
   ? _Unfancy ( _Bx . _Ptr )
   : _Bx . _Buf );
  }

 const value_type * _Myptr ( ) const
  {
  return ( this -> _BUF_SIZE <= _Myres
   ? _Unfancy ( _Bx . _Ptr )
   : _Bx . _Buf );
  }

 union _Bxty
  {
  _Bxty ( )
   {
   }

  ~ _Bxty ( ) noexcept
   {
   }

  value_type _Buf [ _BUF_SIZE ];
  pointer _Ptr;
  char _Alias [ _BUF_SIZE ];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };
#line 546
template < class _Alloc_types >
 class _String_alloc
 {
public :
 typedef _String_alloc < _Alloc_types > _Myt;
 typedef typename _Alloc_types :: _Alloc _Alloc;
 typedef typename _Alloc_types :: _Alty _Alty;
 typedef typename _Alloc_types :: _Val_types _Val_types;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;

 typedef _String_iterator < _String_val < _Val_types > > iterator;
 typedef _String_const_iterator < _String_val < _Val_types > > const_iterator;

 enum
  {
  _BUF_SIZE = _String_val < _Val_types > :: _BUF_SIZE
  };

 enum
  {
  _ALLOC_MASK = _String_val < _Val_types > :: _ALLOC_MASK
  };

 value_type * _Myptr ( )
  {
  return ( _Get_data ( ) . _Myptr ( ) );
  }

 const value_type * _Myptr ( ) const
  {
  return ( _Get_data ( ) . _Myptr ( ) );
  }


























 _String_alloc ( )
  : _Mypair ( _Zero_then_variadic_args_t ( ) )
  {
  _Alloc_proxy ( );
  }

 template < class _Any_alloc,
  class = enable_if_t < ! is_same < decay_t < _Any_alloc >, _Myt > :: value > >
  _String_alloc ( _Any_alloc && _Al )
  : _Mypair ( _One_then_variadic_args_t ( ),
   :: std :: forward < _Any_alloc > ( _Al ) )
  {
  _Alloc_proxy ( );
  }

 ~ _String_alloc ( ) noexcept
  {
  _Free_proxy ( );
  }

 void _Copy_alloc ( const _Alty & _Al )
  {
  _Free_proxy ( );
  _Pocca ( _Getal ( ), _Al );
  _Alloc_proxy ( );
  }

 void _Move_alloc ( _Alty & _Al )
  {
  _Free_proxy ( );
  _Pocma ( _Getal ( ), _Al );
  _Alloc_proxy ( );
  }

 void _Alloc_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Getal ( ) );
  _Myproxy ( ) = _Unfancy ( _Alproxy . allocate ( 1 ) );
  _Alproxy . construct ( _Myproxy ( ), _Container_proxy ( ) );
  _Myproxy ( ) -> _Mycont = & _Get_data ( );
  }

 void _Free_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Getal ( ) );
  _Orphan_all ( );
  _Alproxy . destroy ( _Myproxy ( ) );
  _Alproxy . deallocate ( _Alproxy . address ( * _Myproxy ( ) ), 1 );
  _Myproxy ( ) = 0;
  }

 _Iterator_base12 * * _Getpfirst ( ) const
  {
  return ( _Get_data ( ) . _Getpfirst ( ) );
  }

 _Container_proxy * & _Myproxy ( ) noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }

 _Container_proxy * const & _Myproxy ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }


 void _Orphan_all ( )
  {
  _Get_data ( ) . _Orphan_all ( );
  }

 void _Swap_all ( _Myt & _Right )
  {
  _Get_data ( ) . _Swap_all ( _Right . _Get_data ( ) );
  }

 _Alty & _Getal ( ) noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 const _Alty & _Getal ( ) const noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 _String_val < _Val_types > & _Get_data ( ) noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 const _String_val < _Val_types > & _Get_data ( ) const noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 typedef typename _String_val < _Val_types > :: _Bxty _Bxty;

 _Bxty & _Bx ( ) noexcept
  {
  return ( _Get_data ( ) . _Bx );
  }

 const _Bxty & _Bx ( ) const noexcept
  {
  return ( _Get_data ( ) . _Bx );
  }

 size_type & _Mysize ( ) noexcept
  {
  return ( _Get_data ( ) . _Mysize );
  }

 const size_type & _Mysize ( ) const noexcept
  {
  return ( _Get_data ( ) . _Mysize );
  }

 size_type & _Myres ( ) noexcept
  {
  return ( _Get_data ( ) . _Myres );
  }

 const size_type & _Myres ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myres );
  }

private :
 _Compressed_pair < _Alty, _String_val < _Val_types > > _Mypair;
 };
#line 747 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring"
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_string
  : public _String_alloc < _String_base_types < _Elem, _Alloc > >
 {
public :
 typedef basic_string < _Elem, _Traits, _Alloc > _Myt;
 typedef _String_alloc < _String_base_types < _Elem, _Alloc > > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase :: _Alty _Alty;

 typedef typename _Mybase :: value_type value_type;
 typedef typename _Mybase :: size_type size_type;
 typedef typename _Mybase :: difference_type difference_type;
 typedef typename _Mybase :: pointer pointer;
 typedef typename _Mybase :: const_pointer const_pointer;
 typedef typename _Mybase :: reference reference;
 typedef typename _Mybase :: const_reference const_reference;

 typedef typename _Mybase :: iterator iterator;
 typedef typename _Mybase :: const_iterator const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 basic_string ( const _Myt & _Right )

  : _Mybase ( _Right . _Getal ( ) . select_on_container_copy_construction ( ) )


  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }

 basic_string ( const _Myt & _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }

 basic_string ( ) noexcept ( is_nothrow_default_constructible < _Alloc > :: value )
  : _Mybase ( )
  {
  _Tidy ( );
  }

 explicit basic_string ( const _Alloc & _Al ) noexcept
  : _Mybase ( _Al )
  {
  _Tidy ( );
  }

 basic_string ( const _Myt & _Right, size_type _Roff,
  size_type _Count = npos )
  : _Mybase ( _Right . _Getal ( ) )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Myt & _Right, size_type _Roff, size_type _Count,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( const _Elem * _Ptr, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( size_type _Count, _Elem _Ch )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 basic_string ( size_type _Count, _Elem _Ch, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  basic_string ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( _Al )
  {
  _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 868 );
  _Tidy ( );
  _Construct ( _Unchecked ( _First ), _Unchecked ( _Last ), _Iter_cat_t < _Iter > ( ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, input_iterator_tag )
  {
  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, forward_iterator_tag )
  {
  size_type _Count = :: std :: distance ( _First, _Last );
  reserve ( _Count );
  _Construct ( _First, _Last, input_iterator_tag ( ) );
  }

 void _Construct ( _Elem * _First,
  _Elem * _Last, random_access_iterator_tag )
  {
  if ( _First != _Last )
   assign ( _First, _Last - _First );
  }

 void _Construct ( const _Elem * _First,
  const _Elem * _Last, random_access_iterator_tag )
  {
  if ( _First != _Last )
   assign ( _First, _Last - _First );
  }

 basic_string ( _Myt && _Right ) noexcept
  : _Mybase ( :: std :: move ( _Right . _Getal ( ) ) )
  {
  _Tidy ( );
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 basic_string ( _Myt && _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  if ( this -> _Getal ( ) != _Right . _Getal ( ) )
   assign ( _Right . begin ( ), _Right . end ( ) );
  else
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  noexcept ( _Alty :: propagate_on_container_move_assignment :: value || _Alty :: is_always_equal :: value )

  {
  if ( this != & _Right )
   {
   _Tidy ( true );

   if ( _Alty :: propagate_on_container_move_assignment :: value
    && this -> _Getal ( ) != _Right . _Getal ( ) )
    this -> _Move_alloc ( _Right . _Getal ( ) );

   if ( this -> _Getal ( ) != _Right . _Getal ( ) )
    assign ( _Right . begin ( ), _Right . end ( ) );
   else
    _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  return ( * this );
  }

 _Myt & assign ( _Myt && _Right ) noexcept
  {
  if ( this == & _Right )
   ;
  else if ( get_allocator ( ) != _Right . get_allocator ( )
   && this -> _BUF_SIZE <= _Right . _Myres ( ) )
   * this = _Right;
  else
   {
   _Tidy ( true );
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( _Right . _Myres ( ) < this -> _BUF_SIZE )
   _Traits :: move ( this -> _Bx ( ) . _Buf, _Right . _Bx ( ) . _Buf,
    _Right . _Mysize ( ) + 1 );
  else
   {
   this -> _Getal ( ) . construct ( :: std :: addressof ( this -> _Bx ( ) . _Ptr ), _Right . _Bx ( ) . _Ptr );
   _Right . _Bx ( ) . _Ptr = pointer ( );
   }
  this -> _Mysize ( ) = _Right . _Mysize ( );
  this -> _Myres ( ) = _Right . _Myres ( );
  _Right . _Tidy ( );
  }

 basic_string ( :: std :: initializer_list < _Elem > _Ilist,
  const _Alloc & _Al = allocator_type ( ) )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 _Myt & operator = ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( assign ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & operator += ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( append ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & assign ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( assign ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & append ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( append ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 iterator insert ( const_iterator _Where,
  :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( replace ( _First, _Last, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 ~ basic_string ( ) noexcept
  {
  _Tidy ( true );
  }

  static const size_type npos;

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   if ( this -> _Getal ( ) != _Right . _Getal ( )
    && _Alty :: propagate_on_container_copy_assignment :: value )
    {
    _Tidy ( true );
    this -> _Copy_alloc ( _Right . _Getal ( ) );
    }

   assign ( _Right );
   }
  return ( * this );
  }

 _Myt & operator = ( const _Elem * _Ptr )
  {
  return ( assign ( _Ptr ) );
  }

 _Myt & operator = ( _Elem _Ch )
  {
  return ( assign ( 1, _Ch ) );
  }

 _Myt & operator += ( const _Myt & _Right )
  {
  return ( append ( _Right ) );
  }

 _Myt & operator += ( const _Elem * _Ptr )
  {
  return ( append ( _Ptr ) );
  }

 _Myt & operator += ( _Elem _Ch )
  {
  return ( append ( ( size_type ) 1, _Ch ) );
  }

 _Myt & append ( const _Myt & _Right )
  {
  return ( append ( _Right, 0, npos ) );
  }

 _Myt & append ( const _Myt & _Right,
  size_type _Roff, size_type _Count = npos )
  {
  _Right . _Check_offset ( _Roff );
  _Count = _Right . _Clamp_suffix_size ( _Roff, _Count );
  if ( npos - this -> _Mysize ( ) <= _Count )
   _Xlen ( );

  const size_type _Num = this -> _Mysize ( ) + _Count;
  if ( 0 < _Count && _Grow ( _Num ) )
   {
   _Traits :: copy ( this -> _Myptr ( ) + this -> _Mysize ( ),
    _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr, size_type _Count )
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1088 );
  if ( _Inside ( _Ptr ) )
   return ( append ( * this,
    _Ptr - this -> _Myptr ( ), _Count ) );
  if ( npos - this -> _Mysize ( ) <= _Count )
   _Xlen ( );

  const size_type _Num = this -> _Mysize ( ) + _Count;
  if ( 0 < _Count && _Grow ( _Num ) )
   {
   _Traits :: copy ( this -> _Myptr ( ) + this -> _Mysize ( ), _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1106 );
  return ( append ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & append ( size_type _Count, _Elem _Ch )
  {
  if ( npos - this -> _Mysize ( ) <= _Count )
   _Xlen ( );

  const size_type _Num = this -> _Mysize ( ) + _Count;
  if ( 0 < _Count && _Grow ( _Num ) )
   {
   _Chassign ( this -> _Mysize ( ), _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   _Myt & > :: type
  append ( _Iter _First, _Iter _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const _Myt & _Right )
  {
  return ( assign ( _Right, 0, npos ) );
  }

 _Myt & assign ( const _Myt & _Right,
  size_type _Roff, size_type _Count = npos )
  {
  _Right . _Check_offset ( _Roff );
  _Count = _Right . _Clamp_suffix_size ( _Roff, _Count );

  if ( this == & _Right )
   erase ( ( size_type ) ( _Roff + _Count ) ), erase ( 0, _Roff );
  else if ( _Grow ( _Count ) )
   {
   _Traits :: copy ( this -> _Myptr ( ),
    _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Count );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr, size_type _Count )
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1166 );
  if ( _Inside ( _Ptr ) )
   return ( assign ( * this,
    _Ptr - this -> _Myptr ( ), _Count ) );

  if ( _Grow ( _Count ) )
   {
   _Traits :: copy ( this -> _Myptr ( ), _Ptr, _Count );
   _Eos ( _Count );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1181 );
  return ( assign ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & assign ( size_type _Count, _Elem _Ch )
  {
  if ( _Count == npos )
   _Xlen ( );

  if ( _Grow ( _Count ) )
   {
   _Chassign ( 0, _Count, _Ch );
   _Eos ( _Count );
   }
  return ( * this );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   _Myt & > :: type
  assign ( _Iter _First, _Iter _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & insert ( size_type _Off, const _Myt & _Right )
  {
  return ( insert ( _Off, _Right, 0, npos ) );
  }

 _Myt & insert ( size_type _Off,
  const _Myt & _Right, size_type _Roff, size_type _Count = npos )
  {
  _Check_offset ( _Off );
  _Right . _Check_offset ( _Roff );
  _Count = _Right . _Clamp_suffix_size ( _Roff, _Count );
  if ( npos - this -> _Mysize ( ) <= _Count )
   _Xlen ( );

  const size_type _Num = this -> _Mysize ( ) + _Count;
  if ( 0 < _Count && _Grow ( _Num ) )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off,
    this -> _Mysize ( ) - _Off );
   if ( this == & _Right )
    _Traits :: move ( this -> _Myptr ( ) + _Off,
     this -> _Myptr ( ) + ( _Off < _Roff ? _Roff + _Count : _Roff ),
      _Count );
   else
    _Traits :: copy ( this -> _Myptr ( ) + _Off,
     _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off,
  const _Elem * _Ptr, size_type _Count )
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1251 );
  if ( _Inside ( _Ptr ) )
   return ( insert ( _Off, * this,
    _Ptr - this -> _Myptr ( ), _Count ) );
  _Check_offset ( _Off );
  if ( npos - this -> _Mysize ( ) <= _Count )
   _Xlen ( );
  const size_type _Num = this -> _Mysize ( ) + _Count;
  if ( 0 < _Count && _Grow ( _Num ) )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off,
    this -> _Mysize ( ) - _Off );
   _Traits :: copy ( this -> _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off, const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1272 );
  return ( insert ( _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & insert ( size_type _Off,
  size_type _Count, _Elem _Ch )
  {
  _Check_offset ( _Off );
  if ( npos - this -> _Mysize ( ) <= _Count )
   _Xlen ( );
  const size_type _Num = this -> _Mysize ( ) + _Count;
  if ( 0 < _Count && _Grow ( _Num ) )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off,
    this -> _Mysize ( ) - _Off );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 iterator insert ( const_iterator _Where )
  {
  return ( insert ( _Where, _Elem ( ) ) );
  }

 iterator insert ( const_iterator _Where, _Elem _Ch )
  {
  size_type _Off = _Where - begin ( );
  insert ( _Off, 1, _Ch );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where, size_type _Count, _Elem _Ch )
  {
  size_type _Off = _Where - begin ( );
  insert ( _Off, _Count, _Ch );
  return ( begin ( ) + _Off );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   iterator > :: type
  insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  size_type _Off = _Where - begin ( );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where,
  const_pointer _First, const_pointer _Last )
  {
  size_type _Off = _Where - begin ( );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where,
  const_iterator _First, const_iterator _Last )
  {
  size_type _Off = _Where - begin ( );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 _Myt & erase ( size_type _Off = 0 )
  {
  _Check_offset ( _Off );
  _Eos ( _Off );
  return ( * this );
  }

 _Myt & erase ( size_type _Off, size_type _Count )
  {
  _Check_offset ( _Off );
  if ( this -> _Mysize ( ) - _Off <= _Count )
   _Eos ( _Off );
  else if ( 0 < _Count )
   {
   value_type * _Ptr = this -> _Myptr ( ) + _Off;
   size_type _Newsize = this -> _Mysize ( ) - _Count;
   _Traits :: move ( _Ptr, _Ptr + _Count, _Newsize - _Off );
   _Eos ( _Newsize );
   }
  return ( * this );
  }

 iterator erase ( const_iterator _Where )
  {
  size_type _Count = _Where - begin ( );
  erase ( _Count, 1 );
  return ( begin ( ) + _Count );
  }

 iterator erase ( const_iterator _First, const_iterator _Last )
  {
  _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1370 );
  size_type _Count = _First - begin ( );
  erase ( _Count, _Last - _First );
  return ( begin ( ) + _Count );
  }

 void clear ( ) noexcept
  {
  _Eos ( 0 );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Myt & _Right )
  {
  return ( replace ( _Off, _N0, _Right, 0, npos ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Myt & _Right, size_type _Roff,
   size_type _Count = npos )
  {
  _Check_offset ( _Off );
  _Right . _Check_offset ( _Roff );
  _N0 = _Clamp_suffix_size ( _Off, _N0 );
  _Count = _Right . _Clamp_suffix_size ( _Roff, _Count );
  if ( npos - _Count <= this -> _Mysize ( ) - _N0 )
   _Xlen ( );

  const size_type _Nm = this -> _Mysize ( ) - _N0 - _Off;
  const size_type _Newsize = this -> _Mysize ( ) + _Count - _N0;
  if ( this -> _Mysize ( ) < _Newsize )
   _Grow ( _Newsize );

  if ( _Count == _N0 )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    _Right . _Myptr ( ) + _Roff, _Count );
   }
  else if ( this != & _Right )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( this -> _Myptr ( ) + _Off,
    _Right . _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Count < _N0 )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + _Roff, _Count );
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   }
  else if ( _Roff <= _Off )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Off + _N0 <= _Roff )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + ( _Roff + _Count - _N0 ),
    _Count );
   }
  else
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + _Roff, _N0 );
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( this -> _Myptr ( ) + _Off + _N0,
    this -> _Myptr ( ) + _Roff + _Count,
    _Count - _N0 );
   }

  _Eos ( _Newsize );
  return ( * this );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count )
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1454 );
  if ( _Inside ( _Ptr ) )
   return ( replace ( _Off, _N0, * this,
    _Ptr - this -> _Myptr ( ),
    _Count ) );
  _Check_offset ( _Off );
  _N0 = _Clamp_suffix_size ( _Off, _N0 );
  if ( npos - _Count <= this -> _Mysize ( ) - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize ( ) - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0,
    _Nm );
  const size_type _Num = this -> _Mysize ( ) + _Count - _N0;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
     this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( this -> _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Elem * _Ptr )
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1484 );
  return ( replace ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch )
  {
  _Check_offset ( _Off );
  _N0 = _Clamp_suffix_size ( _Off, _N0 );
  if ( npos - _Count <= this -> _Mysize ( ) - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize ( ) - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0,
    _Nm );
  const size_type _Num = this -> _Mysize ( ) + _Count - _N0;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
     this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Myt & _Right )
  {
  return ( replace ( _First - begin ( ), _Last - _First, _Right ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr, size_type _Count )
  {
  return ( replace ( _First - begin ( ), _Last - _First, _Ptr, _Count ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr )
  {
  return ( replace ( _First - begin ( ), _Last - _First, _Ptr ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch )
  {
  return ( replace ( _First - begin ( ), _Last - _First, _Count, _Ch ) );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   _Myt & > :: type
  replace ( const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2 )
  {
  _Myt _Right ( _First2, _Last2 );
  replace ( _First, _Last, _Right );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _First - begin ( ), _Last - _First );
  else
   replace ( _First - begin ( ), _Last - _First,
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _First - begin ( ), _Last - _First );
  else
   replace ( _First - begin ( ), _Last - _First,
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _First - begin ( ), _Last - _First );
  else
   replace ( _First - begin ( ), _Last - _First,
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _First - begin ( ), _Last - _First );
  else
   replace ( _First - begin ( ), _Last - _First,
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 iterator begin ( ) noexcept
  {
  auto _Mydata = & this -> _Get_data ( );
  return ( iterator ( this -> _Getal ( ) . address ( * _Mydata -> _Myptr ( ) ), _Mydata ) );
  }

 const_iterator begin ( ) const noexcept
  {
  auto _Mydata = & this -> _Get_data ( );
  return ( const_iterator ( this -> _Getal ( ) . address ( * _Mydata -> _Myptr ( ) ), _Mydata ) );
  }

 iterator end ( ) noexcept
  {
  auto _Mydata = & this -> _Get_data ( );
  return ( iterator ( this -> _Getal ( ) . address ( * _Mydata -> _Myptr ( ) ) + _Mydata -> _Mysize, _Mydata ) );
  }

 const_iterator end ( ) const noexcept
  {
  auto _Mydata = & this -> _Get_data ( );
  return ( const_iterator ( this -> _Getal ( ) . address ( * _Mydata -> _Myptr ( ) ) + _Mydata -> _Mysize, _Mydata ) );
  }

 reverse_iterator rbegin ( ) noexcept
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const noexcept
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( ) noexcept
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const noexcept
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 const_iterator cbegin ( ) const noexcept
  {
  return ( begin ( ) );
  }

 const_iterator cend ( ) const noexcept
  {
  return ( end ( ) );
  }

 const_reverse_iterator crbegin ( ) const noexcept
  {
  return ( rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const noexcept
  {
  return ( rend ( ) );
  }

 void shrink_to_fit ( )
  {
  if ( ( size ( ) | this -> _ALLOC_MASK ) < capacity ( ) )
   {
   _Myt _Tmp ( * this );
   swap ( _Tmp );
   }
  }

 reference at ( size_type _Off )
  {
  _Check_offset_exclusive ( _Off );
  return ( this -> _Myptr ( ) [ _Off ] );
  }

 const_reference at ( size_type _Off ) const
  {
  _Check_offset_exclusive ( _Off );
  return ( this -> _Myptr ( ) [ _Off ] );
  }

 reference operator [ ] ( size_type _Off )
  {

  if ( this -> _Mysize ( ) < _Off )
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1682 );





  return ( this -> _Myptr ( ) [ _Off ] );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {

  if ( this -> _Mysize ( ) < _Off )
   _Debug_message ( L"\x73\x74\x72\x69\x6e\x67\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1695 );





  return ( this -> _Myptr ( ) [ _Off ] );
  }

 void push_back ( _Elem _Ch )
  {
  auto & _Dx = this -> _Get_data ( );
  auto & _Sz = _Dx . _Mysize;
  if ( _Sz == _Dx . _Myres )
   _Grow ( _Sz + 1 );
  auto _Ptr = _Dx . _Myptr ( );
  _Traits :: assign ( _Ptr [ _Sz ], _Ch );
  ++ _Sz;
  _Traits :: assign ( _Ptr [ _Sz ], _Elem ( ) );
  }

 void pop_back ( )
  {
  erase ( this -> _Mysize ( ) - 1 );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 const _Elem * c_str ( ) const noexcept
  {
  return ( this -> _Myptr ( ) );
  }

 const _Elem * data ( ) const noexcept
  {
  return ( this -> _Myptr ( ) );
  }








 size_type length ( ) const noexcept
  {
  return ( this -> _Mysize ( ) );
  }

 size_type size ( ) const noexcept
  {
  return ( this -> _Mysize ( ) );
  }

 size_type max_size ( ) const noexcept
  {
  const size_type _Num = this -> _Getal ( ) . max_size ( );
  return ( _Num <= 1 ? 1 : _Num - 1 );
  }

 void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Elem ( ) );
  }

 void resize ( size_type _Newsize, _Elem _Ch )
  {
  if ( _Newsize <= this -> _Mysize ( ) )
   _Eos ( _Newsize );
  else
   append ( _Newsize - this -> _Mysize ( ), _Ch );
  }

 size_type capacity ( ) const noexcept
  {
  return ( this -> _Myres ( ) );
  }

 void reserve ( size_type _Newcap = 0 )
  {
  if ( this -> _Mysize ( ) <= _Newcap && this -> _Myres ( ) != _Newcap )
   {
   size_type _Size = this -> _Mysize ( );
   if ( _Grow ( _Newcap, true ) )
    _Eos ( _Size );
   }
  }

 bool empty ( ) const noexcept
  {
  return ( this -> _Mysize ( ) == 0 );
  }

 __declspec ( deprecated ( "Call to \'std::basic_string::copy\' with parameters that may be unsafe - this call relies on the caller to check that the passed" " values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ \'Checke" "d Iterators\'" ) )
 size_type copy ( _Elem * _Ptr,
  size_type _Count, size_type _Off = 0 ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1811 );
  _Check_offset ( _Off );
  _Count = _Clamp_suffix_size ( _Off, _Count );
  _Traits :: copy ( _Ptr, this -> _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 size_type _Copy_s ( _Elem * _Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0 ) const
  {
  _Debug_pointer_if ( _Count != 0, _Dest, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1821 );
  _Check_offset ( _Off );
  _Count = _Clamp_suffix_size ( _Off, _Count );
  _Traits :: _Copy_s ( _Dest, _Dest_size, this -> _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 void _Swap_bx ( _Myt & _Right )
  {
  if ( this -> _BUF_SIZE <= this -> _Myres ( ) )
   if ( this -> _BUF_SIZE <= _Right . _Myres ( ) )
    _Swap_adl ( this -> _Bx ( ) . _Ptr, _Right . _Bx ( ) . _Ptr );
   else
    {
    pointer _Ptr = this -> _Bx ( ) . _Ptr;
    this -> _Getal ( ) . destroy ( :: std :: addressof ( this -> _Bx ( ) . _Ptr ) );
    _Traits :: copy ( this -> _Bx ( ) . _Buf,
     _Right . _Bx ( ) . _Buf, _Right . _Mysize ( ) + 1 );
    this -> _Getal ( ) . construct ( :: std :: addressof ( _Right . _Bx ( ) . _Ptr ), _Ptr );
    }
  else
   if ( _Right . _Myres ( ) < this -> _BUF_SIZE )
    :: std :: swap ( this -> _Bx ( ) . _Buf, _Right . _Bx ( ) . _Buf );
   else
    {
    pointer _Ptr = _Right . _Bx ( ) . _Ptr;
    this -> _Getal ( ) . destroy ( :: std :: addressof ( _Right . _Bx ( ) . _Ptr ) );
    _Traits :: copy ( _Right . _Bx ( ) . _Buf,
     this -> _Bx ( ) . _Buf, this -> _Mysize ( ) + 1 );
    this -> _Getal ( ) . construct ( :: std :: addressof ( this -> _Bx ( ) . _Ptr ), _Ptr );
    }
  }

 void swap ( _Myt & _Right )
  noexcept ( _Alty :: propagate_on_container_swap :: value || _Alty :: is_always_equal :: value )

  {
  if ( this != & _Right )
   {
   _Pocs ( this -> _Getal ( ), _Right . _Getal ( ) );
   this -> _Swap_all ( _Right );
   _Swap_bx ( _Right );
   :: std :: swap ( this -> _Mysize ( ), _Right . _Mysize ( ) );
   :: std :: swap ( this -> _Myres ( ), _Right . _Myres ( ) );
   }
  }

 size_type find ( const _Myt & _Right, size_type _Off = 0 ) const noexcept
  {
  return ( find ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1876 );
  if ( _Count == 0 && _Off <= this -> _Mysize ( ) )
   return ( _Off );

  size_type _Nm;
  if ( _Off < this -> _Mysize ( ) && _Count <= ( _Nm = this -> _Mysize ( ) - _Off ) )
   {
   const _Elem * _Uptr, * _Vptr;
   for ( _Nm -= _Count - 1, _Vptr = this -> _Myptr ( ) + _Off;
    ( _Uptr = _Traits :: find ( _Vptr, _Nm, * _Ptr ) ) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1 )
    if ( _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1896 );
  return ( find ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type rfind ( const _Myt & _Right, size_type _Off = npos ) const noexcept
  {
  return ( rfind ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type rfind ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1913 );
  if ( _Count == 0 )
   return ( _Off < this -> _Mysize ( ) ? _Off
    : this -> _Mysize ( ) );
  if ( _Count <= this -> _Mysize ( ) )
   {
   const _Elem * _Uptr = this -> _Myptr ( ) +
    ( _Off < this -> _Mysize ( ) - _Count ? _Off
     : this -> _Mysize ( ) - _Count );
   for (;; -- _Uptr )
    if ( _Traits :: eq ( * _Uptr, * _Ptr )
     && _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
    else if ( _Uptr == this -> _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type rfind ( const _Elem * _Ptr, size_type _Off = npos ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1935 );
  return ( rfind ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type rfind ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_of ( const _Myt & _Right,
  size_type _Off = 0 ) const noexcept
  {
  return ( find_first_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1953 );
  if ( 0 < _Count && _Off < this -> _Mysize ( ) )
   {
   const _Elem * const _Vptr = this -> _Myptr ( ) + this -> _Mysize ( );
   for ( const _Elem * _Uptr = this -> _Myptr ( ) + _Off;
    _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - this -> _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1969 );
  return ( find_first_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_of ( _Elem _Ch,
  size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_of ( const _Myt & _Right,
  size_type _Off = npos ) const noexcept
  {
  return ( find_last_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 1988 );
  if ( 0 < _Count && 0 < this -> _Mysize ( ) )
   {
   const _Elem * _Uptr = this -> _Myptr ( )
    + ( _Off < this -> _Mysize ( ) ? _Off : this -> _Mysize ( ) - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - this -> _Myptr ( ) );
    else if ( _Uptr == this -> _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2006 );
  return ( find_last_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_of ( _Elem _Ch,
  size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_not_of ( const _Myt & _Right,
  size_type _Off = 0 ) const noexcept
  {
  return ( find_first_not_of ( _Right . _Myptr ( ), _Off,
   _Right . size ( ) ) );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2026 );
  if ( _Off < this -> _Mysize ( ) )
   {
   const _Elem * const _Vptr = this -> _Myptr ( ) + this -> _Mysize ( );
   for ( const _Elem * _Uptr = this -> _Myptr ( ) + _Off;
    _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
   }
  return ( npos );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2041 );
  return ( find_first_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_not_of ( _Elem _Ch,
  size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_not_of ( const _Myt & _Right,
  size_type _Off = npos ) const noexcept
  {
  return ( find_last_not_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2060 );
  if ( 0 < this -> _Mysize ( ) )
   {
   const _Elem * _Uptr = this -> _Myptr ( )
    + ( _Off < this -> _Mysize ( ) ? _Off : this -> _Mysize ( ) - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
    else if ( _Uptr == this -> _Myptr ( ) )
     break;
   }
  return ( npos );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2077 );
  return ( find_last_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_not_of ( _Elem _Ch,
  size_type _Off = npos ) const
  {
  return ( find_last_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 _Myt substr ( size_type _Off = 0, size_type _Count = npos ) const
  {
  return ( _Myt ( * this, _Off, _Count, get_allocator ( ) ) );
  }

 static int _Traits_compare ( const _Elem * const _Left, const size_type _Left_size,
  const _Elem * const _Right, const size_type _Right_size )
  {
  const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;
  const int _Ans = _Traits :: compare ( _Left, _Right, _Min_size );

  if ( _Ans != 0 )
   return ( _Ans );

  if ( _Left_size < _Right_size )
   return ( - 1 );

  if ( _Left_size > _Right_size )
   return ( 1 );

  return ( 0 );
  }

 size_type _Clamp_suffix_size ( const size_type _Off, const size_type _Size ) const
  {
  const size_type _Max_effective_size = this -> _Mysize ( ) - _Off;
  if ( _Size <= _Max_effective_size )
   return ( _Size );
  else
   return ( _Max_effective_size );
  }

 int compare ( const _Myt & _Right ) const noexcept
  {
  return ( _Traits_compare ( this -> _Myptr ( ), this -> _Mysize ( ),
   _Right . _Myptr ( ), _Right . _Mysize ( ) ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Myt & _Right ) const
  {
  _Check_offset ( _Off );
  return ( _Traits_compare ( this -> _Myptr ( ) + _Off, _Clamp_suffix_size ( _Off, _N0 ),
   _Right . _Myptr ( ), _Right . _Mysize ( ) ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Myt & _Right,
  size_type _Roff, size_type _Count = npos ) const
  {
  _Check_offset ( _Off );
  _Right . _Check_offset ( _Roff );
  return ( _Traits_compare ( this -> _Myptr ( ) + _Off, _Clamp_suffix_size ( _Off, _N0 ),
   _Right . _Myptr ( ) + _Roff, _Right . _Clamp_suffix_size ( _Roff, _Count ) ) );
  }

 int compare ( const _Elem * _Ptr ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2145 );
  return ( _Traits_compare ( this -> _Myptr ( ), this -> _Mysize ( ),
   _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off, size_type _N0, const _Elem * _Ptr ) const
  {
  _Debug_pointer ( _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2152 );
  _Check_offset ( _Off );
  return ( _Traits_compare ( this -> _Myptr ( ) + _Off, _Clamp_suffix_size ( _Off, _N0 ),
   _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count ) const
  {
  _Debug_pointer_if ( _Count != 0, _Ptr, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x78" L"\x73\x74\x72\x69\x6e\x67", 2161 );
  _Check_offset ( _Off );
  return ( _Traits_compare ( this -> _Myptr ( ) + _Off, _Clamp_suffix_size ( _Off, _N0 ),
   _Ptr, _Count ) );
  }

 allocator_type get_allocator ( ) const noexcept
  {
  allocator_type _Ret ( this -> _Getal ( ) );
  return ( _Ret );
  }

 void _Chassign ( size_type _Off, size_type _Count, _Elem _Ch )
  {
  if ( _Count == 1 )
   _Traits :: assign ( * ( this -> _Myptr ( ) + _Off ), _Ch );
  else
   _Traits :: assign ( this -> _Myptr ( ) + _Off, _Count, _Ch );
  }

 void _Copy ( size_type _Newsize, size_type _Oldlen )
  {
  size_type _Newres = _Newsize | this -> _ALLOC_MASK;
  if ( max_size ( ) < _Newres )
   _Newres = _Newsize;
  else if ( this -> _Myres ( ) / 2 <= _Newres / 3 )
   ;
  else if ( this -> _Myres ( ) <= max_size ( ) - this -> _Myres ( ) / 2 )
   _Newres = this -> _Myres ( )
    + this -> _Myres ( ) / 2;
  else
   _Newres = max_size ( );

  pointer _Ptr;
  try {
   _Ptr = this -> _Getal ( ) . allocate ( _Newres + 1 );
  } catch ( ... ) {
   _Newres = _Newsize;
   try {
    _Ptr = this -> _Getal ( ) . allocate ( _Newres + 1 );
   } catch ( ... ) {
   _Tidy ( true );
   throw;
   }
  }

  if ( 0 < _Oldlen )
   _Traits :: copy ( _Unfancy ( _Ptr ), this -> _Myptr ( ),
    _Oldlen );
  _Tidy ( true );
  this -> _Getal ( ) . construct ( :: std :: addressof ( this -> _Bx ( ) . _Ptr ), _Ptr );
  this -> _Myres ( ) = _Newres;
  _Eos ( _Oldlen );
  }

 void _Eos ( size_type _Newsize )
  {
  auto & _Dx = this -> _Get_data ( );
  _Traits :: assign ( _Dx . _Myptr ( ) [ _Dx . _Mysize = _Newsize ], _Elem ( ) );
  }

 bool _Grow ( size_type _Newsize,
  bool _Trim = false )
  {
  if ( max_size ( ) < _Newsize )
   _Xlen ( );
  if ( this -> _Myres ( ) < _Newsize )
   _Copy ( _Newsize, this -> _Mysize ( ) );
  else if ( _Trim && _Newsize < this -> _BUF_SIZE )
   _Tidy ( true,
    _Newsize < this -> _Mysize ( ) ? _Newsize : this -> _Mysize ( ) );
  else if ( _Newsize == 0 )
   _Eos ( 0 );
  return ( 0 < _Newsize );
  }

 bool _Inside ( const _Elem * _Ptr )
  {
  if ( _Ptr == nullptr_t { } || _Ptr < this -> _Myptr ( )
   || this -> _Myptr ( ) + this -> _Mysize ( ) <= _Ptr )
   return ( false );
  else
   return ( true );
  }

 void _Tidy ( bool _Built = false,
  size_type _Newsize = 0 )
  {
  if ( ! _Built )
   ;
  else if ( this -> _BUF_SIZE <= this -> _Myres ( ) )
   {
   pointer _Ptr = this -> _Bx ( ) . _Ptr;
   this -> _Getal ( ) . destroy ( :: std :: addressof ( this -> _Bx ( ) . _Ptr ) );
   if ( 0 < _Newsize )
    _Traits :: copy ( this -> _Bx ( ) . _Buf,
     _Unfancy ( _Ptr ), _Newsize );
   this -> _Getal ( ) . deallocate ( _Ptr, this -> _Myres ( ) + 1 );
   }
  this -> _Myres ( ) = this -> _BUF_SIZE - 1;
  _Eos ( _Newsize );
  }

 [ [ noreturn ] ] void _Xlen ( ) const
  {
  _Xlength_error ( "string too long" );
  }

 void _Check_offset ( const size_type _Off ) const
  {
  if ( this -> _Mysize ( ) < _Off )
   _Xran ( );
  }

 void _Check_offset_exclusive ( const size_type _Off ) const
  {
  if ( this -> _Mysize ( ) <= _Off )
   _Xran ( );
  }

 [ [ noreturn ] ] void _Xran ( ) const
  {
  _Xout_of_range ( "invalid string position" );
  }
 };
#line 2288 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring"
template< class _Elem, class 
#line 2289
_Traits, class 
#line 2290
_Alloc> const typename basic_string< _Elem, _Traits, _Alloc> ::size_type 
#line 2292
basic_string< _Elem, _Traits, _Alloc> ::npos = ((typename ::std::basic_string< _Elem, _Traits, typename _String_base_types< _Elem, _Alloc> ::_Alloc> ::size_type)(-1)); 
#line 2297
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
   noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 2307
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2321
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Traits :: length ( _Left ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2335
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( 1 + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2349
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Traits :: length ( _Right ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2363
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + 1 );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2377
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 2387
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 2397
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 if ( _Right . size ( ) <= _Left . capacity ( ) - _Left . size ( )
  || _Right . capacity ( ) - _Right . size ( ) < _Left . size ( ) )
  return ( :: std :: move ( _Left . append ( _Right ) ) );
 else
  return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 2411
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem * _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 2421
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 typedef typename basic_string < _Elem, _Traits, _Alloc > :: size_type
  size_type;
 return ( :: std :: move ( _Right . insert ( ( size_type ) 0, ( size_type ) 1, _Left ) ) );
 }
#line 2433
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem * _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 2443
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem _Right )
 {
 return ( :: std :: move ( _Left . append ( 1, _Right ) ) );
 }
#line 2453
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( _Left . compare ( _Right ) == 0 );
 }
#line 2463
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) == 0 );
 }
#line 2473
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Left . compare ( _Right ) == 0 );
 }
#line 2483
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2493
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2503
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2513
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 2523
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) > 0 );
 }
#line 2533
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 2543
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( _Right < _Left );
 }
#line 2553
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2563
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Right < _Left );
 }
#line 2573
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2583
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2593
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2603
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2613
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2623
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2634
typedef basic_string< char, char_traits< char> , allocator< char> >  string; 
#line 2636
typedef basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstring; 
#line 2639
template < class _Elem,
 class _Traits,
 class _Alloc >
 struct hash < basic_string < _Elem, _Traits, _Alloc > >
 {
 typedef basic_string < _Elem, _Traits, _Alloc > argument_type;
 typedef size_t result_type;

 size_t operator ( ) ( const argument_type & _Keyval ) const
  {
  return ( _Hash_seq ( ( const unsigned char * ) _Keyval . c_str ( ),
   _Keyval . size ( ) * sizeof ( _Elem ) ) );
  }
 };
#line 2655
typedef basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> >  u16string; 
#line 2657
typedef basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> >  u32string; 
#line 2658
}
#line 2661
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
#pragma warning(push,3)
#line 2662 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\xstring"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
class logic_error : public exception { 
#line 19
public: typedef exception _Mybase; 
#line 21
explicit logic_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 23
{ 
#line 24
} 
#line 26
explicit logic_error(const char *_Message) : _Mybase(_Message) 
#line 28
{ 
#line 29
} 
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 43
class domain_error : public logic_error { 
#line 47
public: typedef logic_error _Mybase; 
#line 49
explicit domain_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 51
{ 
#line 52
} 
#line 54
explicit domain_error(const char *_Message) : _Mybase(_Message) 
#line 56
{ 
#line 57
} 
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 71
class invalid_argument : public logic_error { 
#line 75
public: typedef logic_error _Mybase; 
#line 77
explicit invalid_argument(const string &_Message) : _Mybase(_Message.c_str()) 
#line 79
{ 
#line 80
} 
#line 82
explicit invalid_argument(const char *_Message) : _Mybase(_Message) 
#line 84
{ 
#line 85
} 
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 99
class length_error : public logic_error { 
#line 103
public: typedef logic_error _Mybase; 
#line 105
explicit length_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 107
{ 
#line 108
} 
#line 110
explicit length_error(const char *_Message) : _Mybase(_Message) 
#line 112
{ 
#line 113
} 
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 127
class out_of_range : public logic_error { 
#line 131
public: typedef logic_error _Mybase; 
#line 133
explicit out_of_range(const string &_Message) : _Mybase(_Message.c_str()) 
#line 135
{ 
#line 136
} 
#line 138
explicit out_of_range(const char *_Message) : _Mybase(_Message) 
#line 140
{ 
#line 141
} 
#line 152 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 155
class runtime_error : public exception { 
#line 159
public: typedef exception _Mybase; 
#line 161
explicit runtime_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 163
{ 
#line 164
} 
#line 166
explicit runtime_error(const char *_Message) : _Mybase(_Message) 
#line 168
{ 
#line 169
} 
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 183
class overflow_error : public runtime_error { 
#line 187
public: typedef runtime_error _Mybase; 
#line 189
explicit overflow_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 191
{ 
#line 192
} 
#line 194
explicit overflow_error(const char *_Message) : _Mybase(_Message) 
#line 196
{ 
#line 197
} 
#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 211
class underflow_error : public runtime_error { 
#line 215
public: typedef runtime_error _Mybase; 
#line 217
explicit underflow_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 219
{ 
#line 220
} 
#line 222
explicit underflow_error(const char *_Message) : _Mybase(_Message) 
#line 224
{ 
#line 225
} 
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 239
class range_error : public runtime_error { 
#line 243
public: typedef runtime_error _Mybase; 
#line 245
explicit range_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 247
{ 
#line 248
} 
#line 250
explicit range_error(const char *_Message) : _Mybase(_Message) 
#line 252
{ 
#line 253
} 
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
}; 
#line 265
}
#line 267
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\deque"
#pragma warning(push,3)
#line 14
#pragma warning(disable: 4127)
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\stdexcept"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\deque"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 26
template < class _Mydeque >
 class _Deque_unchecked_const_iterator

 {
public :
 typedef _Deque_unchecked_const_iterator < _Mydeque > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mydeque :: value_type value_type;
 typedef typename _Mydeque :: size_type size_type;
 typedef typename _Mydeque :: difference_type difference_type;
 typedef typename _Mydeque :: const_pointer pointer;
 typedef typename _Mydeque :: const_reference reference;

 _Deque_unchecked_const_iterator ( )
  : _Mycont ( ),
  _Myoff ( 0 )
  {
  }

 _Deque_unchecked_const_iterator ( size_type _Off,
  const _Container_base12 * _Pdeque )
  : _Mycont ( static_cast < const _Mydeque * > ( _Pdeque ) ),
  _Myoff ( _Off )
  {
  }

 reference operator * ( ) const
  {
  size_type _Block = _Mycont -> _Getblock ( _Myoff );
  size_type _Off = _Myoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 );
  return ( _Mycont -> _Map [ _Block ] [ _Off ] );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ _Myoff;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- _Myoff;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  return ( _Right . _Myoff <= _Myoff
   ? _Myoff - _Right . _Myoff
   : - ( difference_type ) ( _Right . _Myoff - _Myoff ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  return ( _Myoff == _Right . _Myoff );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  return ( _Myoff < _Right . _Myoff );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

 const _Container_base12 * _Getcont ( ) const
  {
  return ( _Mycont );
  }

 const _Mydeque * _Mycont;
 size_type _Myoff;
 };
#line 165
template < class _Mydeque > inline
 _Deque_unchecked_const_iterator < _Mydeque > operator + (
  typename _Deque_unchecked_const_iterator < _Mydeque >
   :: difference_type _Off,
  _Deque_unchecked_const_iterator < _Mydeque > _Next )
 {
 return ( _Next += _Off );
 }
#line 175
template < class _Mydeque >
 class _Deque_unchecked_iterator
  : public _Deque_unchecked_const_iterator < _Mydeque >
 {
public :
 typedef _Deque_unchecked_iterator < _Mydeque > _Myiter;
 typedef _Deque_unchecked_const_iterator < _Mydeque > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mydeque :: value_type value_type;
 typedef typename _Mydeque :: size_type size_type;
 typedef typename _Mydeque :: difference_type difference_type;
 typedef typename _Mydeque :: pointer pointer;
 typedef typename _Mydeque :: reference reference;

 _Deque_unchecked_iterator ( )
  {
  }

 _Deque_unchecked_iterator ( size_type _Off,
  const _Container_base12 * _Pdeque )
  : _Mybase ( _Off, _Pdeque )
  {
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 270
template < class _Mydeque > inline
 _Deque_unchecked_iterator < _Mydeque > operator + (
  typename _Deque_unchecked_iterator < _Mydeque >
   :: difference_type _Off,
  _Deque_unchecked_iterator < _Mydeque > _Next )
 {
 return ( _Next += _Off );
 }
#line 280
template < class _Mydeque >
 class _Deque_const_iterator
  : public _Iterator_base12
 {
public :
 typedef _Deque_const_iterator < _Mydeque > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mydeque :: value_type value_type;
 typedef typename _Mydeque :: size_type size_type;
 typedef typename _Mydeque :: difference_type difference_type;
 typedef typename _Mydeque :: const_pointer pointer;
 typedef typename _Mydeque :: const_reference reference;

 typedef _Mydeque _Mydeque_t;
 enum { _EEN_DS = ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) };
 _Deque_const_iterator ( )
  : _Myoff ( 0 )
  {
  _Setcont ( 0 );
  }

 _Deque_const_iterator ( size_type _Off, const _Container_base12 * _Pdeque )
  : _Myoff ( _Off )
  {
  _Setcont ( ( _Mydeque * ) _Pdeque );
  }

 typedef _Deque_unchecked_const_iterator < _Mydeque > _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Myoff = _Right . _Myoff;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( _Myoff, this -> _Getcont ( ) ) );
  }

 reference operator * ( ) const
  {
  const auto _Mycont = static_cast < const _Mydeque * > ( this -> _Getcont ( ) );

  if ( _Mycont == 0
   || this -> _Myoff < _Mycont -> _Myoff
   || _Mycont -> _Myoff + _Mycont -> _Mysize <= this -> _Myoff )
  {
  _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 329 );
  { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 330, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 330, 0 ); };
  }







  ;

  size_type _Block = _Mycont -> _Getblock ( _Myoff );
  size_type _Off = _Myoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 );
  return ( _Mycont -> _Map [ _Block ] [ _Off ] );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {

  const auto _Mycont = static_cast < const _Mydeque * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || _Mycont -> _Myoff + _Mycont -> _Mysize <= this -> _Myoff )
  {
  _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65" L"", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 358 );
  { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 359, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 359, 0 ); };
  }







  ++ _Myoff;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {

  const auto _Mycont = static_cast < const _Mydeque * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || this -> _Myoff <= _Mycont -> _Myoff )
  {
  _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65" L"", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 386 );
  { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 387, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 387, 0 ); };
  }







  -- _Myoff;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {

  if ( _Off != 0 )
   {
   const auto _Mycont = static_cast < const _Mydeque * > ( this -> _Getcont ( ) );
   if ( _Mycont == 0
    || this -> _Myoff + _Off < _Mycont -> _Myoff
    || _Mycont -> _Myoff + _Mycont -> _Mysize < this -> _Myoff + _Off )
    {
    _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x2b\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72" L"\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 417 );
    { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 418, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 418, 0 ); };
    }
   }










  _Myoff += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Right . _Myoff <= this -> _Myoff
   ? this -> _Myoff - _Right . _Myoff
   : - ( difference_type ) ( _Right . _Myoff - this -> _Myoff ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Myoff == _Right . _Myoff );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Myoff < _Right . _Myoff );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


 void _Compat ( const _Myiter & _Right ) const
  {
  if ( this -> _Getcont ( ) != _Right . _Getcont ( ) )
   {
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 502 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Invalid Argument" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 503, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x49\x6e\x76\x61\x6c\x69\x64\x20" L"\x41\x72\x67\x75\x6d\x65\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 503, 0 ); };
   }
  }











 void _Setcont ( const _Mydeque * _Pdeque )
  {
  this -> _Adopt ( _Pdeque );
  }

 size_type _Myoff;
 };
#line 525 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\deque"
template < class _Mydeque > inline
 typename _Deque_const_iterator < _Mydeque > :: _Unchecked_type
  _Unchecked ( _Deque_const_iterator < _Mydeque > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 532
template < class _Mydeque > inline
 _Deque_const_iterator < _Mydeque > &
  _Rechecked ( _Deque_const_iterator < _Mydeque > & _Iter,
   typename _Deque_const_iterator < _Mydeque >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 541
template < class _Mydeque > inline
 _Deque_const_iterator < _Mydeque > operator + (
  typename _Deque_const_iterator < _Mydeque > :: difference_type _Off,
  _Deque_const_iterator < _Mydeque > _Next )
 {
 return ( _Next += _Off );
 }
#line 550
template < class _Mydeque >
 class _Deque_iterator
  : public _Deque_const_iterator < _Mydeque >
  {
public :
 typedef _Deque_iterator < _Mydeque > _Myiter;
 typedef _Deque_const_iterator < _Mydeque > _Mybase;
 typedef _Deque_unchecked_iterator < _Mydeque > _Deque_unchecked_type;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mydeque :: value_type value_type;
 typedef typename _Mydeque :: size_type size_type;
 typedef typename _Mydeque :: difference_type difference_type;
 typedef typename _Mydeque :: pointer pointer;
 typedef typename _Mydeque :: reference reference;

 _Deque_iterator ( )
  {
  }

 _Deque_iterator ( size_type _Off, const _Container_base12 * _Pdeque )
  : _Mybase ( _Off, _Pdeque )
  {
  }

 typedef _Deque_unchecked_iterator < _Mydeque > _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Myoff = _Right . _Myoff;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Myoff, this -> _Getcont ( ) ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  this -> _Myoff += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 658
template < class _Mydeque > inline
 typename _Deque_iterator < _Mydeque > :: _Unchecked_type
  _Unchecked ( _Deque_iterator < _Mydeque > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 665
template < class _Mydeque > inline
 _Deque_iterator < _Mydeque > &
  _Rechecked ( _Deque_iterator < _Mydeque > & _Iter,
   typename _Deque_iterator < _Mydeque >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 674
template < class _Mydeque > inline
 _Deque_iterator < _Mydeque > operator + (
  typename _Deque_iterator < _Mydeque > :: difference_type _Off,
  _Deque_iterator < _Mydeque > _Next )
 {
 return ( _Next += _Off );
 }
#line 683
template< class _Value_type, class 
#line 684
_Size_type, class 
#line 685
_Difference_type, class 
#line 686
_Pointer, class 
#line 687
_Const_pointer, class 
#line 688
_Reference, class 
#line 689
_Const_reference, class 
#line 690
_Mapptr_type> 
#line 691
struct _Deque_iter_types { 
#line 693
typedef _Value_type value_type; 
#line 694
typedef _Size_type size_type; 
#line 695
typedef _Difference_type difference_type; 
#line 696
typedef _Pointer pointer; 
#line 697
typedef _Const_pointer const_pointer; 
#line 698
typedef _Reference reference; 
#line 699
typedef _Const_reference const_reference; 
#line 700
typedef _Mapptr_type _Mapptr; 
#line 701
}; 
#line 703
template< class _Ty> 
#line 704
struct _Deque_simple_types : public _Simple_types< _Ty>  { 
#line 707
typedef _Ty **_Mapptr; 
#line 708
}; 
#line 710
template< class _Ty, class 
#line 711
_Alloc0> 
#line 712
struct _Deque_base_types { 
#line 714
typedef _Alloc0 _Alloc; 
#line 715
typedef _Deque_base_types _Myt; 
#line 717
typedef _Wrap_alloc< _Alloc0>  _Alty0; 
#line 718
typedef typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other _Alty; 
#line 721
typedef typename _Alty::pointer _Tptr; 
#line 722
typedef typename _Alty::template rebind< typename _Alty::pointer> ::other _Alpty; 
#line 723
typedef typename _Alpty::pointer _Mapptr; 
#line 735
typedef typename _If< _Is_simple_alloc< typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other> ::value, _Deque_simple_types< typename _Alty::value_type> , _Deque_iter_types< typename _Alty::value_type, typename _Alty::size_type, typename _Alty::difference_type, typename _Alty::pointer, typename _Alty::const_pointer, typename _Alty::reference, typename _Alty::const_reference, typename _Alpty::pointer> > ::type _Val_types; 
#line 736
}; 
#line 739
template < class _Val_types >
 class _Deque_val
  : public _Container_base12
 {
public :
 typedef _Deque_val < _Val_types > _Myt;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;
 typedef typename _Val_types :: _Mapptr _Mapptr;

 typedef _Deque_iterator < _Myt > iterator;
 typedef _Deque_const_iterator < _Myt > const_iterator;

 _Deque_val ( )
  : _Map ( ),
  _Mapsize ( 0 ),
  _Myoff ( 0 ),
  _Mysize ( 0 )
  {
  }

 size_type _Getblock ( size_type _Off ) const
  {

  return ( ( _Off / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) & ( _Mapsize - 1 ) );
  }

 _Mapptr _Map;
 size_type _Mapsize;
 size_type _Myoff;
 size_type _Mysize;
 };
#line 779
template < class _Alloc_types >
 class _Deque_alloc
 {
public :
 typedef _Deque_alloc < _Alloc_types > _Myt;
 typedef typename _Alloc_types :: _Alloc _Alloc;
 typedef typename _Alloc_types :: _Alty _Alty;
 typedef typename _Alloc_types :: _Alpty _Alpty;
 typedef typename _Alloc_types :: _Val_types _Val_types;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;
 typedef typename _Val_types :: _Mapptr _Mapptr;

 typedef _Deque_iterator < _Deque_val < _Val_types > > iterator;
 typedef _Deque_const_iterator < _Deque_val < _Val_types > > const_iterator;

 size_type _Getblock ( size_type _Off ) const
  {
  return ( _Get_data ( ) . _Getblock ( _Off ) );
  }

 _Deque_alloc ( )
  : _Mypair ( _Zero_then_variadic_args_t ( ) )
  {
  _Alloc_proxy ( );
  }

 template < class _Any_alloc,
  class = enable_if_t < ! is_same < decay_t < _Any_alloc >, _Myt > :: value > >
  _Deque_alloc ( _Any_alloc && _Al )
  : _Mypair ( _One_then_variadic_args_t ( ),
   :: std :: forward < _Any_alloc > ( _Al ) )
  {
  _Alloc_proxy ( );
  }

 ~ _Deque_alloc ( ) noexcept
  {
  _Free_proxy ( );
  }

 void _Copy_alloc ( const _Alty & _Al )
  {
  _Free_proxy ( );
  _Pocca ( _Getal ( ), _Al );
  _Alloc_proxy ( );
  }

 void _Move_alloc ( _Alty & _Al )
  {
  _Free_proxy ( );
  _Pocma ( _Getal ( ), _Al );
  _Alloc_proxy ( );
  }

 void _Alloc_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Getal ( ) );
  _Myproxy ( ) = _Unfancy ( _Alproxy . allocate ( 1 ) );
  _Alproxy . construct ( _Myproxy ( ), _Container_proxy ( ) );
  _Myproxy ( ) -> _Mycont = & _Get_data ( );
  }

 void _Free_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Getal ( ) );
  _Orphan_all ( );
  _Alproxy . destroy ( _Myproxy ( ) );
  _Alproxy . deallocate ( _Alproxy . address ( * _Myproxy ( ) ), 1 );
  _Myproxy ( ) = 0;
  }

 _Iterator_base12 * * _Getpfirst ( ) const
  {
  return ( _Get_data ( ) . _Getpfirst ( ) );
  }

 _Container_proxy * & _Myproxy ( ) noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }

 _Container_proxy * const & _Myproxy ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }

 void _Orphan_all ( )
  {
  _Get_data ( ) . _Orphan_all ( );
  }

 void _Swap_all ( _Myt & _Right )
  {
  _Get_data ( ) . _Swap_all ( _Right . _Get_data ( ) );
  }

 _Alty & _Getal ( ) noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 const _Alty & _Getal ( ) const noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 _Deque_val < _Val_types > & _Get_data ( ) noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 const _Deque_val < _Val_types > & _Get_data ( ) const noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 _Mapptr & _Map ( ) noexcept
  {
  return ( _Get_data ( ) . _Map );
  }

 const _Mapptr & _Map ( ) const noexcept
  {
  return ( _Get_data ( ) . _Map );
  }

 size_type & _Mapsize ( ) noexcept
  {
  return ( _Get_data ( ) . _Mapsize );
  }

 const size_type & _Mapsize ( ) const noexcept
  {
  return ( _Get_data ( ) . _Mapsize );
  }

 size_type & _Myoff ( ) noexcept
  {
  return ( _Get_data ( ) . _Myoff );
  }

 const size_type & _Myoff ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myoff );
  }

 size_type & _Mysize ( ) noexcept
  {
  return ( _Get_data ( ) . _Mysize );
  }

 const size_type & _Mysize ( ) const noexcept
  {
  return ( _Get_data ( ) . _Mysize );
  }

private :
 _Compressed_pair < _Alty, _Deque_val < _Val_types > > _Mypair;
 };
#line 949
template < class _Ty,
 class _Alloc = allocator < _Ty > >
 class deque
  : public _Deque_alloc < _Deque_base_types < _Ty, _Alloc > >
 {
public :
 typedef deque < _Ty, _Alloc > _Myt;
 typedef _Deque_alloc < _Deque_base_types < _Ty, _Alloc > > _Mybase;
 typedef _Alloc allocator_type;

 typedef typename _Mybase :: _Alty _Alty;
 typedef typename _Mybase :: _Alpty _Alpty;
 typedef typename _Mybase :: _Mapptr _Mapptr;

 typedef typename _Mybase :: value_type value_type;
 typedef typename _Mybase :: size_type size_type;
 typedef typename _Mybase :: difference_type difference_type;
 typedef typename _Mybase :: pointer pointer;
 typedef typename _Mybase :: const_pointer const_pointer;
 typedef typename _Mybase :: reference reference;
 typedef typename _Mybase :: const_reference const_reference;

 typedef typename _Mybase :: iterator iterator;
 typedef typename _Mybase :: const_iterator const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;
 enum { _EEN_DS = ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) };
 deque ( )
  : _Mybase ( )
  {
  }

 explicit deque ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  }

 explicit deque ( size_type _Count )
  : _Mybase ( )
  {
  resize ( _Count );
  }

 deque ( size_type _Count, const value_type & _Val )
  : _Mybase ( )
  {
  _Construct_n ( _Count, _Val );
  }

 deque ( size_type _Count, const value_type & _Val, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct_n ( _Count, _Val );
  }

 deque ( const _Myt & _Right )

  : _Mybase ( _Right . _Getal ( ) . select_on_container_copy_construction ( ) )


  {
  _Construct ( _Right . begin ( ), _Right . end ( ) );
  }

 deque ( const _Myt & _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct ( _Right . begin ( ), _Right . end ( ) );
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  deque ( _Iter _First, _Iter _Last )
  : _Mybase ( )
  {
  _Construct ( _First, _Last );
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  deque ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct ( _First, _Last );
  }

 template < class _Iter >
  void _Construct ( _Iter _First, _Iter _Last )
  {
  try {

  for (; _First != _Last; ++ _First )
   emplace_back ( * _First );

  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 void _Construct_n ( size_type _Count, const value_type & _Val )
  {
  try {
  for (; 0 < _Count; -- _Count )
   push_back ( _Val );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }





























 deque ( _Myt && _Right )
  : _Mybase ( :: std :: move ( _Right . _Getal ( ) ) )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ), true_type ( ) );
  }

 deque ( _Myt && _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  noexcept ( _Alty :: is_always_equal :: value )
  {
  if ( this != & _Right )
   {
   _Tidy ( );
   if ( _Alty :: propagate_on_container_move_assignment :: value
    && this -> _Getal ( ) != _Right . _Getal ( ) )
    this -> _Move_alloc ( _Right . _Getal ( ) );
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right, true_type )
  {
  this -> _Swap_all ( ( _Myt & ) _Right );
  this -> _Map ( ) = _Right . _Map ( );
  this -> _Mapsize ( ) = _Right . _Mapsize ( );
  this -> _Myoff ( ) = _Right . _Myoff ( );
  this -> _Mysize ( ) = _Right . _Mysize ( );

  _Right . _Map ( ) = _Mapptr ( );
  _Right . _Mapsize ( ) = 0;
  _Right . _Myoff ( ) = 0;
  _Right . _Mysize ( ) = 0;
  }

 void _Assign_rv ( _Myt && _Right, false_type )
  {
  if ( get_allocator ( ) == _Right . get_allocator ( ) )
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ), true_type ( ) );
  else
   _Construct ( :: std :: make_move_iterator ( _Right . begin ( ) ),
    :: std :: make_move_iterator ( _Right . end ( ) ) );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ),
   typename _Alty :: propagate_on_container_move_assignment ( ) );
  }


 void push_front ( value_type && _Val )
  {
  this -> _Orphan_all ( );
  if ( this -> _Myoff ( ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) == 0 && this -> _Mapsize ( ) <= ( this -> _Mysize ( ) + ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) _Growmap ( 1 ); this -> _Myoff ( ) &= this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - 1; size_type _Newoff = this -> _Myoff ( ) != 0 ? this -> _Myoff ( ) : this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ); size_type _Block = this -> _Getblock ( -- _Newoff ); if ( this -> _Map ( ) [ _Block ] == pointer ( ) ) this -> _Map ( ) [ _Block ] = this -> _Getal ( ) . allocate ( ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
  this -> _Getal ( ) . construct (
   _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ),
   :: std :: forward < value_type > ( _Val ) );
  this -> _Myoff ( ) = _Newoff; ++ this -> _Mysize ( );
  }

 void push_back ( value_type && _Val )
  {
  this -> _Orphan_all ( );
  if ( ( this -> _Myoff ( ) + this -> _Mysize ( ) ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) == 0 && this -> _Mapsize ( ) <= ( this -> _Mysize ( ) + ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) _Growmap ( 1 ); this -> _Myoff ( ) &= this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - 1; size_type _Newoff = this -> _Myoff ( ) + this -> _Mysize ( ); size_type _Block = this -> _Getblock ( _Newoff ); if ( this -> _Map ( ) [ _Block ] == pointer ( ) ) this -> _Map ( ) [ _Block ] = this -> _Getal ( ) . allocate ( ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
  this -> _Getal ( ) . construct (
   _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ),
   :: std :: forward < value_type > ( _Val ) );
  ++ this -> _Mysize ( );
  }

 iterator insert ( const_iterator _Where, _Ty && _Val )
  {
  return ( emplace ( _Where, :: std :: move ( _Val ) ) );
  }

 template < class ... _Valty >
  void emplace_front ( _Valty && ... _Val )
  {
  this -> _Orphan_all ( );
  if ( this -> _Myoff ( ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) == 0 && this -> _Mapsize ( ) <= ( this -> _Mysize ( ) + ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) _Growmap ( 1 ); this -> _Myoff ( ) &= this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - 1; size_type _Newoff = this -> _Myoff ( ) != 0 ? this -> _Myoff ( ) : this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ); size_type _Block = this -> _Getblock ( -- _Newoff ); if ( this -> _Map ( ) [ _Block ] == pointer ( ) ) this -> _Map ( ) [ _Block ] = this -> _Getal ( ) . allocate ( ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
  this -> _Getal ( ) . construct (
   _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ),
   :: std :: forward < _Valty > ( _Val ) ... );
  this -> _Myoff ( ) = _Newoff; ++ this -> _Mysize ( );
  }

 template < class ... _Valty >
  void emplace_back ( _Valty && ... _Val )
  {
  this -> _Orphan_all ( );
  if ( ( this -> _Myoff ( ) + this -> _Mysize ( ) ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) == 0 && this -> _Mapsize ( ) <= ( this -> _Mysize ( ) + ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) _Growmap ( 1 ); this -> _Myoff ( ) &= this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - 1; size_type _Newoff = this -> _Myoff ( ) + this -> _Mysize ( ); size_type _Block = this -> _Getblock ( _Newoff ); if ( this -> _Map ( ) [ _Block ] == pointer ( ) ) this -> _Map ( ) [ _Block ] = this -> _Getal ( ) . allocate ( ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
  this -> _Getal ( ) . construct (
   _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ),
   :: std :: forward < _Valty > ( _Val ) ... );
  ++ this -> _Mysize ( );
  }

 template < class ... _Valty >
  iterator emplace ( const_iterator _Where, _Valty && ... _Val )
  {
  size_type _Off = _Where - begin ( );


  if ( this -> _Mysize ( ) < _Off )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x65\x6d\x70\x6c\x61\x63\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72" L"\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1201 );


  if ( _Off <= this -> _Mysize ( ) / 2 )
   {
   emplace_front ( :: std :: forward < _Valty > ( _Val ) ... );
   :: std :: rotate ( begin ( ), begin ( ) + 1, begin ( ) + 1 + _Off );
   }
  else
   {
   emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );
   :: std :: rotate ( begin ( ) + _Off, end ( ) - 1, end ( ) );
   }
  return ( begin ( ) + _Off );
  }


 deque ( :: std :: initializer_list < value_type > _Ilist,
  const _Alloc & _Al = allocator_type ( ) )
  : _Mybase ( _Al )
  {
  _Construct ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 _Myt & operator = ( :: std :: initializer_list < value_type > _Ilist )
  {
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  return ( * this );
  }

 void assign ( :: std :: initializer_list < value_type > _Ilist )
  {
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 iterator insert ( const_iterator _Where,
  :: std :: initializer_list < value_type > _Ilist )
  {
  return ( insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 ~ deque ( ) noexcept
  {
  _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   if ( this -> _Getal ( ) != _Right . _Getal ( )
    && _Alty :: propagate_on_container_copy_assignment :: value )
    {
    _Tidy ( );
    this -> _Copy_alloc ( _Right . _Getal ( ) );
    }

   this -> _Orphan_all ( );

   if ( _Right . _Mysize ( ) == 0 )
    clear ( );
   else if ( _Right . _Mysize ( ) <= this -> _Mysize ( ) )
    {
    iterator _Mid = :: std :: copy ( _Right . begin ( ), _Right . end ( ),
     begin ( ) );
    erase ( _Mid, end ( ) );
    }
   else
    {
    const_iterator _Mid = _Right . begin ( ) + this -> _Mysize ( );
    :: std :: copy ( _Right . begin ( ), _Mid, begin ( ) );
    insert ( end ( ), _Mid, _Right . end ( ) );
    }
   }
  return ( * this );
  }

 iterator begin ( ) noexcept
  {
  return ( iterator ( this -> _Myoff ( ), & this -> _Get_data ( ) ) );
  }

 const_iterator begin ( ) const noexcept
  {
  return ( const_iterator ( this -> _Myoff ( ), & this -> _Get_data ( ) ) );
  }

 iterator end ( ) noexcept
  {
  return ( iterator ( this -> _Myoff ( ) + this -> _Mysize ( ),
   & this -> _Get_data ( ) ) );
  }

 const_iterator end ( ) const noexcept
  {
  return ( const_iterator ( this -> _Myoff ( ) + this -> _Mysize ( ),
   & this -> _Get_data ( ) ) );
  }

 iterator _Make_iter ( const_iterator _Where ) const
  {
  return ( iterator ( _Where . _Myoff, & this -> _Get_data ( ) ) );
  }

 reverse_iterator rbegin ( ) noexcept
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const noexcept
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( ) noexcept
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const noexcept
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 const_iterator cbegin ( ) const noexcept
  {
  return ( begin ( ) );
  }

 const_iterator cend ( ) const noexcept
  {
  return ( end ( ) );
  }

 const_reverse_iterator crbegin ( ) const noexcept
  {
  return ( rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const noexcept
  {
  return ( rend ( ) );
  }

 void shrink_to_fit ( )
  {
  size_type _Oldcapacity = ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) * this -> _Mapsize ( );
  size_type _Newcapacity = _Oldcapacity / 2;

  if ( _Newcapacity < ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) * 8 )
   _Newcapacity = ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) * 8;

  if ( ( empty ( ) && 0 < this -> _Mapsize ( ) )
   || ( ! empty ( )
    && size ( ) <= _Newcapacity
    && _Newcapacity < _Oldcapacity ) )
   {
   _Myt _Tmp ( :: std :: make_move_iterator ( begin ( ) ),
    :: std :: make_move_iterator ( end ( ) ) );
   swap ( _Tmp );
   }
  }

 void resize ( size_type _Newsize )
  {
  while ( this -> _Mysize ( ) < _Newsize )
   emplace_back ( );

  while ( _Newsize < this -> _Mysize ( ) )
   pop_back ( );
  }

 void resize ( size_type _Newsize, const value_type & _Val )
  {
  while ( this -> _Mysize ( ) < _Newsize )
   push_back ( _Val );
  while ( _Newsize < this -> _Mysize ( ) )
   pop_back ( );
  }

 size_type size ( ) const noexcept
  {
  return ( this -> _Mysize ( ) );
  }

 size_type max_size ( ) const noexcept
  {
  return ( this -> _Getal ( ) . max_size ( ) );
  }

 bool empty ( ) const noexcept
  {
  return ( this -> _Mysize ( ) == 0 );
  }

 allocator_type get_allocator ( ) const noexcept
  {
  allocator_type _Ret ( this -> _Getal ( ) );
  return ( _Ret );
  }

 const_reference at ( size_type _Pos ) const
  {
  if ( this -> _Mysize ( ) <= _Pos )
   _Xran ( );
  return ( * ( begin ( ) + _Pos ) );
  }

 reference at ( size_type _Pos )
  {
  if ( this -> _Mysize ( ) <= _Pos )
   _Xran ( );
  return ( * ( begin ( ) + _Pos ) );
  }

 const_reference operator [ ] ( size_type _Pos ) const
  {

  if ( this -> _Mysize ( ) <= _Pos )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1420 );


  return ( * ( begin ( ) + _Pos ) );
  }

 reference operator [ ] ( size_type _Pos )
  {

  if ( this -> _Mysize ( ) <= _Pos )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1430 );


  return ( * ( begin ( ) + _Pos ) );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_front ( const value_type & _Val )
  {
  this -> _Orphan_all ( );
  if ( this -> _Myoff ( ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) == 0 && this -> _Mapsize ( ) <= ( this -> _Mysize ( ) + ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) _Growmap ( 1 ); this -> _Myoff ( ) &= this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - 1; size_type _Newoff = this -> _Myoff ( ) != 0 ? this -> _Myoff ( ) : this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ); size_type _Block = this -> _Getblock ( -- _Newoff ); if ( this -> _Map ( ) [ _Block ] == pointer ( ) ) this -> _Map ( ) [ _Block ] = this -> _Getal ( ) . allocate ( ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
  this -> _Getal ( ) . construct (
   _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ), _Val );
  this -> _Myoff ( ) = _Newoff; ++ this -> _Mysize ( );
  }

 void pop_front ( )
  {

  if ( empty ( ) )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x65\x6d\x70\x74\x79\x20\x62\x65\x66\x6f\x72\x65\x20\x70\x6f\x70", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1469 );
  else
   {
   _Orphan_off ( this -> _Myoff ( ) );
   size_type _Block = this -> _Getblock ( this -> _Myoff ( ) );
   this -> _Getal ( ) . destroy (
    _Unfancy ( this -> _Map ( ) [ _Block ] + this -> _Myoff ( ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) );
   if ( -- this -> _Mysize ( ) == 0 )
    this -> _Myoff ( ) = 0;
   else
    ++ this -> _Myoff ( );
   }










  }

 void push_back ( const value_type & _Val )
  {
  this -> _Orphan_all ( );
  if ( ( this -> _Myoff ( ) + this -> _Mysize ( ) ) % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) == 0 && this -> _Mapsize ( ) <= ( this -> _Mysize ( ) + ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) _Growmap ( 1 ); this -> _Myoff ( ) &= this -> _Mapsize ( ) * ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - 1; size_type _Newoff = this -> _Myoff ( ) + this -> _Mysize ( ); size_type _Block = this -> _Getblock ( _Newoff ); if ( this -> _Map ( ) [ _Block ] == pointer ( ) ) this -> _Map ( ) [ _Block ] = this -> _Getal ( ) . allocate ( ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
  this -> _Getal ( ) . construct (
   _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ), _Val );
  ++ this -> _Mysize ( );
  }

 void pop_back ( )
  {

  if ( empty ( ) )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x65\x6d\x70\x74\x79\x20\x62\x65\x66\x6f\x72\x65\x20\x70\x6f\x70", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1506 );
  else
   {
   size_type _Newoff = this -> _Myoff ( ) + this -> _Mysize ( ) - 1;
   _Orphan_off ( _Newoff );
   size_type _Block = this -> _Getblock ( _Newoff );
   this -> _Getal ( ) . destroy (
    _Unfancy ( this -> _Map ( ) [ _Block ] + _Newoff % ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) ) );
   if ( -- this -> _Mysize ( ) == 0 )
    this -> _Myoff ( ) = 0;
   }









  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type
  assign ( _Iter _First, _Iter _Last )
  {
  clear ( );

  for (; _First != _Last; ++ _First )
   emplace_back ( * _First );
  }

 void assign ( size_type _Count, const value_type & _Val )
  {
  erase ( begin ( ), end ( ) );
  _Insert_n ( begin ( ), _Count, _Val );
  }

 iterator insert ( const_iterator _Where,
  const value_type & _Val )
  {
  size_type _Off = _Where - begin ( );


  if ( this -> _Mysize ( ) < _Off )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72\x61" L"\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1552 );


  if ( _Off <= this -> _Mysize ( ) / 2 )
   {
   push_front ( _Val );
   :: std :: rotate ( begin ( ), begin ( ) + 1, begin ( ) + 1 + _Off );
   }
  else
   {
   push_back ( _Val );
   :: std :: rotate ( begin ( ) + _Off, end ( ) - 1, end ( ) );
   }
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where, size_type _Count,
  const value_type & _Val )
  {
  size_type _Off = _Where - begin ( );
  _Insert_n ( _Where, _Count, _Val );
  return ( begin ( ) + _Off );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   iterator > :: type
  insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  size_type _Off = _Where - begin ( );


  if ( this -> _Mysize ( ) < _Off )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72\x61" L"\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1585 );
  _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1586 );


  size_type _Oldsize = this -> _Mysize ( );

  if ( _First == _Last )
   ;
  else if ( _Off <= this -> _Mysize ( ) / 2 )
   {
   try {
   for (; _First != _Last; ++ _First )
    push_front ( * _First );

   } catch ( ... ) {
   for (; _Oldsize < this -> _Mysize ( ); )
    pop_front ( );
   throw;
   }

   size_type _Num = this -> _Mysize ( ) - _Oldsize;
   :: std :: reverse ( begin ( ), begin ( ) + _Num );
   :: std :: rotate ( begin ( ), begin ( ) + _Num, begin ( ) + _Num + _Off );
   }
  else
   {
   try {
   for (; _First != _Last; ++ _First )
    push_back ( * _First );

   } catch ( ... ) {
   for (; _Oldsize < this -> _Mysize ( ); )
    pop_back ( );
   throw;
   }

   :: std :: rotate ( begin ( ) + _Off, begin ( ) + _Oldsize, end ( ) );
   }
  return ( begin ( ) + _Off );
  }

 iterator erase ( const_iterator _Where )
  {
  return ( erase ( _Where, _Where + 1 ) );
  }

 iterator erase ( const_iterator _First_arg,
  const_iterator _Last_arg )
  {
  iterator _First = _Make_iter ( _First_arg );
  iterator _Last = _Make_iter ( _Last_arg );


  if ( _Last < _First
   || _First < begin ( ) || end ( ) < _Last )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x65\x72\x61\x73\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72\x61\x6e" L"\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1640 );
  _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1641 );

  size_type _Off = _First - begin ( );
  size_type _Count = _Last - _First;
  bool _Moved = 0 < _Off && _Off + _Count < this -> _Mysize ( );






  if ( _Off < ( size_type ) ( end ( ) - _Last ) )
   {
   :: std :: move_backward ( begin ( ), _First, _Last );
   for (; 0 < _Count; -- _Count )
    pop_front ( );
   }
  else
   {
   :: std :: move ( _Last, end ( ), _First );
   for (; 0 < _Count; -- _Count )
    pop_back ( );
   }


  if ( _Moved )
   this -> _Orphan_all ( );


  return ( begin ( ) + _Off );
  }

 void clear ( ) noexcept
  {
  _Tidy ( );
  }

 void swap ( _Myt & _Right )
  noexcept ( _Alty :: is_always_equal :: value )
  {
  if ( this != & _Right )
   {
   _Pocs ( this -> _Getal ( ), _Right . _Getal ( ) );
   this -> _Swap_all ( _Right );
   _Swap_adl ( this -> _Map ( ), _Right . _Map ( ) );
   :: std :: swap ( this -> _Mapsize ( ), _Right . _Mapsize ( ) );
   :: std :: swap ( this -> _Myoff ( ), _Right . _Myoff ( ) );
   :: std :: swap ( this -> _Mysize ( ), _Right . _Mysize ( ) );
   }
  }

protected :
 void _Insert_n ( const_iterator _Where,
  size_type _Count, const value_type & _Val )
  {
  iterator _Mid;
  size_type _Num;
  size_type _Off = _Where - begin ( );
  size_type _Rem = this -> _Mysize ( ) - _Off;
  size_type _Oldsize = this -> _Mysize ( );


  if ( this -> _Mysize ( ) < _Off )
   _Debug_message ( L"\x64\x65\x71\x75\x65\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72\x61" L"\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x64" L"\x65\x71\x75\x65", 1704 );


  if ( _Off < _Rem )
   {
   try {
   if ( _Off < _Count )
    {
    for ( _Num = _Count - _Off; 0 < _Num; -- _Num )
     push_front ( _Val );
    for ( _Num = _Off; 0 < _Num; -- _Num )
     push_front ( begin ( ) [ _Count - 1 ] );

    _Mid = begin ( ) + _Count;
    :: std :: fill ( _Mid, _Mid + _Off,
     _Val );
    }
   else
    {
    for ( _Num = _Count; 0 < _Num; -- _Num )
     push_front ( begin ( ) [ _Count - 1 ] );

    _Mid = begin ( ) + _Count;
    value_type _Tmp = _Val;
    :: std :: move ( _Mid + _Count, _Mid + _Off,
     _Mid );
    :: std :: fill ( begin ( ) + _Off, _Mid + _Off,
     _Tmp );
    }
   } catch ( ... ) {
   for (; _Oldsize < this -> _Mysize ( ); )
    pop_front ( );
   throw;
   }
   }
  else
   {
   try {
   if ( _Rem < _Count )
    {
    for ( _Num = _Count - _Rem; 0 < _Num; -- _Num )
     push_back ( _Val );
    for ( _Num = 0; _Num < _Rem; ++ _Num )
     push_back ( begin ( ) [ _Off + _Num ] );

    _Mid = begin ( ) + _Off;
    :: std :: fill ( _Mid, _Mid + _Rem,
     _Val );
    }
   else
    {
    for ( _Num = 0; _Num < _Count; ++ _Num )
     push_back ( begin ( ) [ _Off + _Rem
      - _Count + _Num ] );

    _Mid = begin ( ) + _Off;
    value_type _Tmp = _Val;
    :: std :: move_backward ( _Mid, _Mid + _Rem - _Count,
     _Mid + _Rem );
    :: std :: fill ( _Mid, _Mid + _Count,
     _Tmp );
    }
   } catch ( ... ) {
   for (; _Oldsize < this -> _Mysize ( ); )
    pop_back ( );
   throw;
   }
   }
  }

 [ [ noreturn ] ] void _Xlen ( ) const
  {
  _Xlength_error ( "deque<T> too long" );
  }

 [ [ noreturn ] ] void _Xran ( ) const
  {
  _Xout_of_range ( "invalid deque<T> subscript" );
  }

 void _Growmap ( size_type _Count )
  {
  static_assert ( 1 < 8,
   "The _Xlen() test should always be performed." );

  typedef typename _Alpty :: pointer _Blockptr;
  _Alpty _Almap ( this -> _Getal ( ) );
  size_type _Newsize = 0 < this -> _Mapsize ( ) ? this -> _Mapsize ( ) : 1;
  while ( _Newsize - this -> _Mapsize ( ) < _Count
   || _Newsize < 8 )
   {
   if ( max_size ( ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) - _Newsize < _Newsize )
    _Xlen ( );
   _Newsize *= 2;
   }
  _Count = _Newsize - this -> _Mapsize ( );

  size_type _Myboff = this -> _Myoff ( ) / ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 );
  _Mapptr _Newmap = _Almap . allocate ( this -> _Mapsize ( ) + _Count );
  _Mapptr _Myptr = _Newmap + _Myboff;

  _Myptr = _Uninitialized_copy ( this -> _Map ( ) + _Myboff,
   this -> _Map ( ) + this -> _Mapsize ( ),
   _Myptr, _Almap );
  if ( _Myboff <= _Count )
   {
   _Myptr = _Uninitialized_copy ( this -> _Map ( ),
    this -> _Map ( ) + _Myboff,
    _Myptr, _Almap );
   _Uninitialized_default_fill_n ( _Myptr, _Count - _Myboff,
    _Almap );
   _Uninitialized_default_fill_n ( _Newmap, _Myboff,
    _Almap );
   }
  else
   {
   _Uninitialized_copy ( this -> _Map ( ),
    this -> _Map ( ) + _Count,
    _Myptr, _Almap );
   _Myptr = _Uninitialized_copy ( this -> _Map ( ) + _Count,
    this -> _Map ( ) + _Myboff,
    _Newmap, _Almap );
   _Uninitialized_default_fill_n ( _Myptr, _Count,
    _Almap );
   }

  _Destroy_range ( this -> _Map ( ) + _Myboff,
   this -> _Map ( ) + this -> _Mapsize ( ), _Almap );
  if ( this -> _Map ( ) != _Mapptr ( ) )
   _Almap . deallocate ( this -> _Map ( ),
    this -> _Mapsize ( ) );

  this -> _Map ( ) = _Newmap;
  this -> _Mapsize ( ) += _Count;
  }

 void _Tidy ( )
  {
  _Alpty _Almap ( this -> _Getal ( ) );
  while ( ! empty ( ) )
   pop_back ( );
  for ( size_type _Block = this -> _Mapsize ( ); 0 < _Block; )
   {
   if ( this -> _Map ( ) [ -- _Block ] != pointer ( ) )
    {
    this -> _Getal ( ) . deallocate ( this -> _Map ( ) [ _Block ], ( sizeof ( value_type ) <= 1 ? 16 : sizeof ( value_type ) <= 2 ? 8 : sizeof ( value_type ) <= 4 ? 4 : sizeof ( value_type ) <= 8 ? 2 : 1 ) );
    this -> _Getal ( ) . destroy ( :: std :: addressof ( this -> _Map ( ) [ _Block ] ) );
    }
   }

  if ( this -> _Map ( ) != _Mapptr ( ) )
   _Almap . deallocate ( this -> _Map ( ),
    this -> _Mapsize ( ) );
  this -> _Mapsize ( ) = 0;
  this -> _Map ( ) = _Mapptr ( );
  }


 void _Orphan_off ( size_type _Offlo ) const
  {
  size_type _Offhigh = this -> _Myoff ( ) + this -> _Mysize ( ) <= _Offlo + 1
   ? ( size_type ) ( - 1 ) : _Offlo;
  if ( _Offlo == this -> _Myoff ( ) )
   _Offlo = 0;

  _Lockit _Lock ( 3 );
  const_iterator * * _Pnext = ( const_iterator * * ) this -> _Getpfirst ( );
  if ( _Pnext != 0 )
   while ( * _Pnext != 0 )
    if ( ( * _Pnext ) -> _Myoff < _Offlo
     || _Offhigh < ( * _Pnext ) -> _Myoff )
     _Pnext = ( const_iterator * * ) ( * _Pnext ) -> _Getpnext ( );
    else
     {
     ( * _Pnext ) -> _Clrcont ( );
     * _Pnext = * ( const_iterator * * ) ( * _Pnext ) -> _Getpnext ( );
     }
  }

 };
#line 1887 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\deque"
template < class _Ty,
 class _Alloc > inline
 void swap ( deque < _Ty, _Alloc > & _Left, deque < _Ty, _Alloc > & _Right )
  noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 1895
template < class _Ty,
 class _Alloc > inline
 bool operator == ( const deque < _Ty, _Alloc > & _Left,
  const deque < _Ty, _Alloc > & _Right )
 {
 return ( _Left . size ( ) == _Right . size ( )
  && :: std :: equal ( _Left . begin ( ), _Left . end ( ), _Right . begin ( ) ) );
 }
#line 1904
template < class _Ty,
 class _Alloc > inline
 bool operator != ( const deque < _Ty, _Alloc > & _Left,
  const deque < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1912
template < class _Ty,
 class _Alloc > inline
 bool operator < ( const deque < _Ty, _Alloc > & _Left,
  const deque < _Ty, _Alloc > & _Right )
 {
 return ( :: std :: lexicographical_compare ( _Left . begin ( ), _Left . end ( ),
  _Right . begin ( ), _Right . end ( ) ) );
 }
#line 1921
template < class _Ty,
 class _Alloc > inline
 bool operator <= ( const deque < _Ty, _Alloc > & _Left,
  const deque < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1929
template < class _Ty,
 class _Alloc > inline
 bool operator > ( const deque < _Ty, _Alloc > & _Left,
  const deque < _Ty, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1937
template < class _Ty,
 class _Alloc > inline
 bool operator >= ( const deque < _Ty, _Alloc > & _Left,
  const deque < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
  }
#line 1944
}
#line 1947
#pragma warning(pop)
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
#pragma warning(push,3)
#line 14
#pragma warning(disable: 4127)
#pragma warning(disable: 4244)
#line 1948 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\deque"
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
#pragma pack ( push, 8 )
#line 17
namespace std { 
#line 21
template < class _Myvec >
 class _Vector_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   typename _Myvec :: value_type,
   typename _Myvec :: difference_type,
   typename _Myvec :: const_pointer,
   typename _Myvec :: const_reference,
   _Iterator_base >
 {
public :
 typedef _Vector_const_iterator < _Myvec > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec :: value_type value_type;
 typedef typename _Myvec :: difference_type difference_type;
 typedef typename _Myvec :: const_pointer pointer;
 typedef typename _Myvec :: const_reference reference;
 typedef typename _Myvec :: pointer _Tptr;

 _Vector_const_iterator ( )
  : _Ptr ( )
  {
  }

 _Vector_const_iterator ( _Tptr _Parg, const _Container_base * _Pvector )
  : _Ptr ( _Parg )
  {
  this -> _Adopt ( _Pvector );
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  _Ptr = _Const_cast ( _Right );
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Ptr );
  }

 reference operator * ( ) const
  {

  const auto _Mycont = static_cast < const _Myvec * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || _Ptr == _Tptr ( )
   || _Ptr < _Mycont -> _Myfirst
   || _Mycont -> _Mylast <= _Ptr )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62" L"\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 73 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 74, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 74, 0 ); };
   }








  ;

  return ( * _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {

  const auto _Mycont = static_cast < const _Myvec * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || _Ptr == nullptr_t { }
   || _Mycont -> _Mylast <= _Ptr )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 102 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 103, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 103, 0 ); };
   }








  ++ _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {

  const auto _Mycont = static_cast < const _Myvec * > ( this -> _Getcont ( ) );
  if ( _Mycont == 0
   || _Ptr == nullptr_t { }
   || _Ptr <= _Mycont -> _Myfirst )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x61\x62\x6c" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 132 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 133, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 133, 0 ); };
   }








  -- _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {

  if ( _Off != 0 )
   {
   const auto _Mycont = static_cast < const _Myvec * > ( this -> _Getcont ( ) );
   if ( _Mycont == 0
    || _Ptr + _Off < _Mycont -> _Myfirst
    || _Mycont -> _Mylast < _Ptr + _Off )
    {
    _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x2b\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20" L"\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 164 );
    { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 165, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 165, 0 ); };
    }
   }











  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


 void _Compat ( const _Myiter & _Right ) const
  {
  if ( this -> _Getcont ( ) != _Right . _Getcont ( ) )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 248 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Invalid Argument" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 249, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x49\x6e\x76\x61\x6c\x69\x64\x20" L"\x41\x72\x67\x75\x6d\x65\x6e\x74\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 249, 0 ); };
   }
  }













 _Tptr _Ptr;
 };
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Myvec > inline
 typename _Vector_const_iterator < _Myvec > :: _Unchecked_type
  _Unchecked ( _Vector_const_iterator < _Myvec > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 275
template < class _Myvec > inline
 _Vector_const_iterator < _Myvec > &
  _Rechecked ( _Vector_const_iterator < _Myvec > & _Iter,
   typename _Vector_const_iterator < _Myvec >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 284
template < class _Myvec > inline
 _Vector_const_iterator < _Myvec > operator + (
  typename _Vector_const_iterator < _Myvec > :: difference_type _Off,
  _Vector_const_iterator < _Myvec > _Next )
 {
 return ( _Next += _Off );
 }
#line 293
template < class _Myvec >
 class _Vector_iterator
  : public _Vector_const_iterator < _Myvec >
 {
public :
 typedef _Vector_iterator < _Myvec > _Myiter;
 typedef _Vector_const_iterator < _Myvec > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec :: value_type value_type;
 typedef typename _Myvec :: difference_type difference_type;
 typedef typename _Myvec :: pointer pointer;
 typedef typename _Myvec :: reference reference;

 _Vector_iterator ( )
  {
  }

 _Vector_iterator ( pointer _Parg, const _Container_base * _Pvector )
  : _Mybase ( _Parg, _Pvector )
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( this -> _Ptr );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 399
template < class _Myvec > inline
 typename _Vector_iterator < _Myvec > :: _Unchecked_type
  _Unchecked ( _Vector_iterator < _Myvec > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 406
template < class _Myvec > inline
 _Vector_iterator < _Myvec > &
  _Rechecked ( _Vector_iterator < _Myvec > & _Iter,
   typename _Vector_iterator < _Myvec >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 415
template < class _Myvec > inline
 _Vector_iterator < _Myvec > operator + (
  typename _Vector_iterator < _Myvec > :: difference_type _Off,
  _Vector_iterator < _Myvec > _Next )
 {
 return ( _Next += _Off );
 }
#line 424
template< class _Value_type, class 
#line 425
_Size_type, class 
#line 426
_Difference_type, class 
#line 427
_Pointer, class 
#line 428
_Const_pointer, class 
#line 429
_Reference, class 
#line 430
_Const_reference> 
#line 431
struct _Vec_iter_types { 
#line 433
typedef _Value_type value_type; 
#line 434
typedef _Size_type size_type; 
#line 435
typedef _Difference_type difference_type; 
#line 436
typedef _Pointer pointer; 
#line 437
typedef _Const_pointer const_pointer; 
#line 438
typedef _Reference reference; 
#line 439
typedef _Const_reference const_reference; 
#line 440
}; 
#line 442
template< class _Ty, class 
#line 443
_Alloc0> 
#line 444
struct _Vec_base_types { 
#line 446
typedef _Alloc0 _Alloc; 
#line 447
typedef _Vec_base_types _Myt; 
#line 449
typedef _Wrap_alloc< _Alloc0>  _Alty0; 
#line 450
typedef typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other _Alty; 
#line 462
typedef typename _If< _Is_simple_alloc< typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other> ::value, _Simple_types< typename _Alty::value_type> , _Vec_iter_types< typename _Alty::value_type, typename _Alty::size_type, typename _Alty::difference_type, typename _Alty::pointer, typename _Alty::const_pointer, typename _Alty::reference, typename _Alty::const_reference> > ::type _Val_types; 
#line 463
}; 
#line 466
template < class _Val_types >
 class _Vector_val
  : public _Container_base
 {
public :
 typedef _Vector_val < _Val_types > _Myt;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;

 typedef _Vector_iterator < _Myt > iterator;
 typedef _Vector_const_iterator < _Myt > const_iterator;

 _Vector_val ( )
  : _Myfirst ( ),
  _Mylast ( ),
  _Myend ( )
  {
  }

 pointer _Myfirst;
 pointer _Mylast;
 pointer _Myend;
 };
#line 497
template < class _Alloc_types >
 class _Vector_alloc
 {
public :
 typedef _Vector_alloc < _Alloc_types > _Myt;
 typedef typename _Alloc_types :: _Alloc _Alloc;
 typedef typename _Alloc_types :: _Alty _Alty;
 typedef typename _Alloc_types :: _Val_types _Val_types;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;

 typedef _Vector_iterator < _Vector_val < _Val_types > > iterator;
 typedef _Vector_const_iterator < _Vector_val < _Val_types > > const_iterator;


























 _Vector_alloc ( )
  : _Mypair ( _Zero_then_variadic_args_t ( ) )
  {
  _Alloc_proxy ( );
  }

 template < class _Any_alloc,
  class = enable_if_t < ! is_same < decay_t < _Any_alloc >, _Myt > :: value > >
  _Vector_alloc ( _Any_alloc && _Al )
  : _Mypair ( _One_then_variadic_args_t ( ),
   :: std :: forward < _Any_alloc > ( _Al ) )
  {
  _Alloc_proxy ( );
  }

 ~ _Vector_alloc ( ) noexcept
  {
  _Free_proxy ( );
  }

 void _Copy_alloc ( const _Alty & _Al )
  {
  _Free_proxy ( );
  _Pocca ( _Getal ( ), _Al );
  _Alloc_proxy ( );
  }

 void _Move_alloc ( _Alty & _Al )
  {
  _Free_proxy ( );
  _Pocma ( _Getal ( ), _Al );
  _Alloc_proxy ( );
  }

 void _Alloc_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Getal ( ) );
  _Myproxy ( ) = _Unfancy ( _Alproxy . allocate ( 1 ) );
  _Alproxy . construct ( _Myproxy ( ), _Container_proxy ( ) );
  _Myproxy ( ) -> _Mycont = & _Get_data ( );
  }

 void _Free_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Getal ( ) );
  _Orphan_all ( );
  _Alproxy . destroy ( _Myproxy ( ) );
  _Alproxy . deallocate ( _Alproxy . address ( * _Myproxy ( ) ), 1 );
  _Myproxy ( ) = 0;
  }

 _Iterator_base12 * * _Getpfirst ( ) const
  {
  return ( _Get_data ( ) . _Getpfirst ( ) );
  }

 _Container_proxy * & _Myproxy ( ) noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }

 _Container_proxy * const & _Myproxy ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }


 void _Orphan_all ( )
  {
  _Get_data ( ) . _Orphan_all ( );
  }

 void _Swap_all ( _Myt & _Right )
  {
  _Get_data ( ) . _Swap_all ( _Right . _Get_data ( ) );
  }

 _Alty & _Getal ( ) noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 const _Alty & _Getal ( ) const noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 _Vector_val < _Val_types > & _Get_data ( ) noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 const _Vector_val < _Val_types > & _Get_data ( ) const noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 pointer & _Myfirst ( ) noexcept
  {
  return ( _Get_data ( ) . _Myfirst );
  }

 const pointer & _Myfirst ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myfirst );
  }

 pointer & _Mylast ( ) noexcept
  {
  return ( _Get_data ( ) . _Mylast );
  }

 const pointer & _Mylast ( ) const noexcept
  {
  return ( _Get_data ( ) . _Mylast );
  }

 pointer & _Myend ( ) noexcept
  {
  return ( _Get_data ( ) . _Myend );
  }

 const pointer & _Myend ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myend );
  }

private :
 _Compressed_pair < _Alty, _Vector_val < _Val_types > > _Mypair;
 };
#line 676 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Ty,
 class _Alloc = allocator < _Ty > >
 class vector
  : public _Vector_alloc < _Vec_base_types < _Ty, _Alloc > >
 {
public :
 typedef vector < _Ty, _Alloc > _Myt;
 typedef _Vector_alloc < _Vec_base_types < _Ty, _Alloc > > _Mybase;
 typedef _Alloc allocator_type;

 typedef typename _Mybase :: _Alty _Alty;

 typedef typename _Mybase :: value_type value_type;
 typedef typename _Mybase :: size_type size_type;
 typedef typename _Mybase :: difference_type difference_type;
 typedef typename _Mybase :: pointer pointer;
 typedef typename _Mybase :: const_pointer const_pointer;
 typedef typename _Mybase :: reference reference;
 typedef typename _Mybase :: const_reference const_reference;




 typedef typename _Mybase :: iterator iterator;
 typedef typename _Mybase :: const_iterator const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 vector ( ) noexcept ( is_nothrow_default_constructible < _Alloc > :: value )
  : _Mybase ( )
  {
  }

 explicit vector ( const _Alloc & _Al ) noexcept
  : _Mybase ( _Al )
  {
  }

 explicit vector ( size_type _Count )
  : _Mybase ( )
  {
  if ( _Buy ( _Count ) )
   {
   try {
   _Uninitialized_default_fill_n ( this -> _Myfirst ( ), _Count,
    this -> _Getal ( ) );
   this -> _Mylast ( ) += _Count;
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   }
  }

 vector ( size_type _Count, const value_type & _Val )
  : _Mybase ( )
  {
  _Construct_n ( _Count, :: std :: addressof ( _Val ) );
  }

 vector ( size_type _Count, const value_type & _Val, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct_n ( _Count, :: std :: addressof ( _Val ) );
  }

 vector ( const _Myt & _Right )

  : _Mybase ( _Right . _Getal ( ) . select_on_container_copy_construction ( ) )


  {
  if ( _Buy ( _Right . size ( ) ) )
   try {
   this -> _Mylast ( ) = _Ucopy ( _Right . begin ( ), _Right . end ( ),
    this -> _Myfirst ( ) );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
  }

 vector ( const _Myt & _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  if ( _Buy ( _Right . size ( ) ) )
   try {
   this -> _Mylast ( ) = _Ucopy ( _Right . begin ( ), _Right . end ( ),
    this -> _Myfirst ( ) );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  vector ( _Iter _First, _Iter _Last )
  : _Mybase ( )
  {
  _Construct ( _First, _Last );
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  vector ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct ( _First, _Last );
  }

 template < class _Iter >
  void _Construct ( _Iter _First, _Iter _Last )
  {
  _Construct ( _First, _Last, _Iter_cat_t < _Iter > ( ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _First, _Iter _Last,
   input_iterator_tag )
  {
  try {

  for (; _First != _Last; ++ _First )
   emplace_back ( * _First );

  } catch ( ... ) {
  _Tidy ( );
  throw;
  }
  }

 template < class _Iter >
  void _Construct ( _Iter _First, _Iter _Last,
   forward_iterator_tag )
  {
  if ( _Buy ( :: std :: distance ( _First, _Last ) ) )
   {
   try {
   this -> _Mylast ( ) = _Ucopy ( _First, _Last, this -> _Myfirst ( ) );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   }
  }

 void _Construct_n ( size_type _Count, const value_type * _Pval )
  {
  if ( _Buy ( _Count ) )
   {
   try {
   this -> _Mylast ( ) = _Ufill ( this -> _Myfirst ( ), _Count, _Pval );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   }
  }

 vector ( _Myt && _Right ) noexcept
  : _Mybase ( :: std :: move ( _Right . _Getal ( ) ) )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ), true_type ( ) );
  }

 vector ( _Myt && _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  noexcept ( _Alty :: propagate_on_container_move_assignment :: value || _Alty :: is_always_equal :: value )

  {
  if ( this != & _Right )
   {
   _Tidy ( );
   if ( _Alty :: propagate_on_container_move_assignment :: value
    && this -> _Getal ( ) != _Right . _Getal ( ) )
    this -> _Move_alloc ( _Right . _Getal ( ) );

   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right, true_type )
  {
  this -> _Swap_all ( ( _Myt & ) _Right );
  this -> _Myfirst ( ) = _Right . _Myfirst ( );
  this -> _Mylast ( ) = _Right . _Mylast ( );
  this -> _Myend ( ) = _Right . _Myend ( );

  _Right . _Myfirst ( ) = pointer ( );
  _Right . _Mylast ( ) = pointer ( );
  _Right . _Myend ( ) = pointer ( );
  }

 void _Assign_rv ( _Myt && _Right, false_type )
  {
  if ( get_allocator ( ) == _Right . get_allocator ( ) )
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ), true_type ( ) );
  else
   _Construct ( :: std :: make_move_iterator ( _Right . begin ( ) ),
    :: std :: make_move_iterator ( _Right . end ( ) ) );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ),
   typename _Alty :: propagate_on_container_move_assignment ( ) );
  }


 void push_back ( value_type && _Val )
  {
  if ( _Inside ( :: std :: addressof ( _Val ) ) )
   {
   size_type _Idx = :: std :: addressof ( _Val ) - _Unfancy ( this -> _Myfirst ( ) );
   if ( this -> _Mylast ( ) == this -> _Myend ( ) )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast ( ), this -> _Mylast ( ) );
   this -> _Getal ( ) . construct ( _Unfancy ( this -> _Mylast ( ) ),
    :: std :: forward < value_type > ( this -> _Myfirst ( ) [ _Idx ] ) );
   ++ this -> _Mylast ( );
   }
  else
   {
   if ( this -> _Mylast ( ) == this -> _Myend ( ) )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast ( ), this -> _Mylast ( ) );
   this -> _Getal ( ) . construct ( _Unfancy ( this -> _Mylast ( ) ),
    :: std :: forward < value_type > ( _Val ) );
   ++ this -> _Mylast ( );
   }
  }

 iterator insert ( const_iterator _Where, _Ty && _Val )
  {
  return ( emplace ( _Where, :: std :: move ( _Val ) ) );
  }

 template < class ... _Valty >
  void emplace_back ( _Valty && ... _Val )
  {
  if ( this -> _Mylast ( ) == this -> _Myend ( ) )
   _Reserve ( 1 );
  _Orphan_range ( this -> _Mylast ( ), this -> _Mylast ( ) );
  this -> _Getal ( ) . construct ( _Unfancy ( this -> _Mylast ( ) ),
   :: std :: forward < _Valty > ( _Val ) ... );
  ++ this -> _Mylast ( );
  }

 template < class ... _Valty >
  iterator emplace ( const_iterator _Where, _Valty && ... _Val )
  {
  size_type _Off = ( _Where ) . _Ptr - this -> _Myfirst ( );


  if ( size ( ) < _Off )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x65\x6d\x70\x6c\x61\x63\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20" L"\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 941 );


  emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );
  :: std :: rotate ( begin ( ) + _Off, end ( ) - 1, end ( ) );
  return ( begin ( ) + _Off );
  }


 vector ( :: std :: initializer_list < value_type > _Ilist,
  const _Alloc & _Al = allocator_type ( ) )
  : _Mybase ( _Al )
  {
  _Construct ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 _Myt & operator = ( :: std :: initializer_list < value_type > _Ilist )
  {
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  return ( * this );
  }

 void assign ( :: std :: initializer_list < value_type > _Ilist )
  {
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 iterator insert ( const_iterator _Where,
  :: std :: initializer_list < value_type > _Ilist )
  {
  return ( insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 ~ vector ( ) noexcept
  {
  _Tidy ( );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   if ( this -> _Getal ( ) != _Right . _Getal ( )
    && _Alty :: propagate_on_container_copy_assignment :: value )
    {
    _Tidy ( );
    this -> _Copy_alloc ( _Right . _Getal ( ) );
    }

   this -> _Orphan_all ( );

   if ( _Right . empty ( ) )
    clear ( );
   else if ( _Right . size ( ) <= size ( ) )
    {
    pointer _Ptr = _Copy_unchecked ( _Right . _Myfirst ( ),
     _Right . _Mylast ( ), this -> _Myfirst ( ) );
    _Destroy ( _Ptr, this -> _Mylast ( ) );
    this -> _Mylast ( ) = this -> _Myfirst ( ) + _Right . size ( );
    }
   else if ( _Right . size ( ) <= capacity ( ) )
    {
    pointer _Ptr = _Right . _Myfirst ( ) + size ( );
    _Copy_unchecked ( _Right . _Myfirst ( ),
     _Ptr, this -> _Myfirst ( ) );
    this -> _Mylast ( ) = _Ucopy ( _Ptr, _Right . _Mylast ( ),
     this -> _Mylast ( ) );
    }
   else
    {
    if ( this -> _Myfirst ( ) != pointer ( ) )
     {
     _Destroy ( this -> _Myfirst ( ), this -> _Mylast ( ) );
     this -> _Getal ( ) . deallocate ( this -> _Myfirst ( ),
      this -> _Myend ( ) - this -> _Myfirst ( ) );
     }
    if ( _Buy ( _Right . size ( ) ) )
     try {
     this -> _Mylast ( ) =
      _Ucopy ( _Right . _Myfirst ( ), _Right . _Mylast ( ),
      this -> _Myfirst ( ) );
     } catch ( ... ) {
     _Tidy ( );
     throw;
     }
    }
   }
  return ( * this );
  }

 void reserve ( size_type _Count )
  {
  if ( capacity ( ) < _Count )
   {
   if ( max_size ( ) < _Count )
    _Xlen ( );
   _Reallocate ( _Count );
   }
  }

 size_type capacity ( ) const noexcept
  {
  return ( this -> _Myend ( ) - this -> _Myfirst ( ) );
  }

 size_type _Unused_capacity ( ) const noexcept
  {
  return ( this -> _Myend ( ) - this -> _Mylast ( ) );
  }

 size_type _Has_unused_capacity ( ) const noexcept
  {
  return ( this -> _Myend ( ) != this -> _Mylast ( ) );
  }

 iterator begin ( ) noexcept
  {
  return ( iterator ( this -> _Myfirst ( ), & this -> _Get_data ( ) ) );
  }

 const_iterator begin ( ) const noexcept
  {
  return ( const_iterator ( this -> _Myfirst ( ), & this -> _Get_data ( ) ) );
  }

 iterator end ( ) noexcept
  {
  return ( iterator ( this -> _Mylast ( ), & this -> _Get_data ( ) ) );
  }

 const_iterator end ( ) const noexcept
  {
  return ( const_iterator ( this -> _Mylast ( ), & this -> _Get_data ( ) ) );
  }

 iterator _Make_iter ( const_iterator _Where ) const
  {
  return ( iterator ( _Where . _Ptr, & this -> _Get_data ( ) ) );
  }

 reverse_iterator rbegin ( ) noexcept
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const noexcept
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( ) noexcept
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const noexcept
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 const_iterator cbegin ( ) const noexcept
  {
  return ( begin ( ) );
  }

 const_iterator cend ( ) const noexcept
  {
  return ( end ( ) );
  }

 const_reverse_iterator crbegin ( ) const noexcept
  {
  return ( rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const noexcept
  {
  return ( rend ( ) );
  }

 void shrink_to_fit ( )
  {
  if ( _Has_unused_capacity ( ) )
   {
   if ( empty ( ) )
    _Tidy ( );
   else
    _Reallocate ( size ( ) );
   }
  }

 void resize ( size_type _Newsize )
  {
  if ( _Newsize < size ( ) )
   _Pop_back_n ( size ( ) - _Newsize );
  else if ( size ( ) < _Newsize )
   {
   _Reserve ( _Newsize - size ( ) );
   try {
   _Uninitialized_default_fill_n ( this -> _Mylast ( ), _Newsize - size ( ),
    this -> _Getal ( ) );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   this -> _Mylast ( ) += _Newsize - size ( );
   }
  }

 void resize ( size_type _Newsize, const value_type & _Val )
  {
  if ( _Newsize < size ( ) )
   _Pop_back_n ( size ( ) - _Newsize );
  else if ( size ( ) < _Newsize )
   {
   const value_type * _Ptr = :: std :: addressof ( _Val );

   if ( _Inside ( _Ptr ) )
    {
    const difference_type _Idx = _Ptr
     - _Unfancy ( this -> _Myfirst ( ) );
    _Reserve ( _Newsize - size ( ) );
    _Ptr = _Unfancy ( this -> _Myfirst ( ) ) + _Idx;
    }
   else
    _Reserve ( _Newsize - size ( ) );

   try {
   _Ufill ( this -> _Mylast ( ), _Newsize - size ( ), _Ptr );
   } catch ( ... ) {
   _Tidy ( );
   throw;
   }
   this -> _Mylast ( ) += _Newsize - size ( );
   }
  }

 size_type size ( ) const noexcept
  {
  return ( this -> _Mylast ( ) - this -> _Myfirst ( ) );
  }

 size_type max_size ( ) const noexcept
  {
  return ( this -> _Getal ( ) . max_size ( ) );
  }

 bool empty ( ) const noexcept
  {
  return ( this -> _Myfirst ( ) == this -> _Mylast ( ) );
  }

 _Alloc get_allocator ( ) const noexcept
  {
  _Alloc _Ret ( this -> _Getal ( ) );
  return ( _Ret );
  }

 const_reference at ( size_type _Pos ) const
  {
  if ( size ( ) <= _Pos )
   _Xran ( );
  return ( * ( this -> _Myfirst ( ) + _Pos ) );
  }

 reference at ( size_type _Pos )
  {
  if ( size ( ) <= _Pos )
   _Xran ( );
  return ( * ( this -> _Myfirst ( ) + _Pos ) );
  }

 const_reference operator [ ] ( size_type _Pos ) const
  {

  if ( size ( ) <= _Pos )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1218 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1219, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1219, 0 ); };
   }





  return ( * ( this -> _Myfirst ( ) + _Pos ) );
  }

 reference operator [ ] ( size_type _Pos )
  {

  if ( size ( ) <= _Pos )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1234 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1235, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1235, 0 ); };
   }





  return ( * ( this -> _Myfirst ( ) + _Pos ) );
  }

 _Ty * data ( ) noexcept
  {
  return ( _Unfancy ( this -> _Myfirst ( ) ) );
  }

 const _Ty * data ( ) const noexcept
  {
  return ( _Unfancy ( this -> _Myfirst ( ) ) );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_back ( const value_type & _Val )
  {
  if ( _Inside ( :: std :: addressof ( _Val ) ) )
   {
   size_type _Idx = :: std :: addressof ( _Val ) - _Unfancy ( this -> _Myfirst ( ) );
   if ( this -> _Mylast ( ) == this -> _Myend ( ) )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast ( ), this -> _Mylast ( ) );
   this -> _Getal ( ) . construct ( _Unfancy ( this -> _Mylast ( ) ),
    this -> _Myfirst ( ) [ _Idx ] );
   ++ this -> _Mylast ( );
   }
  else
   {
   if ( this -> _Mylast ( ) == this -> _Myend ( ) )
    _Reserve ( 1 );
   _Orphan_range ( this -> _Mylast ( ), this -> _Mylast ( ) );
   this -> _Getal ( ) . construct ( _Unfancy ( this -> _Mylast ( ) ),
    _Val );
   ++ this -> _Mylast ( );
   }
  }


 void pop_back ( )
  {
  if ( empty ( ) )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x65\x6d\x70\x74\x79\x20\x62\x65\x66\x6f\x72\x65\x20\x70\x6f\x70", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1302 );
  else
   {
   _Orphan_range ( this -> _Mylast ( ) - 1, this -> _Mylast ( ) );
   this -> _Getal ( ) . destroy ( _Unfancy ( this -> _Mylast ( ) - 1 ) );
   -- this -> _Mylast ( );
   }
  }









 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type
  assign ( _Iter _First, _Iter _Last )
  {
  clear ( );
  _Assign ( _First, _Last, _Iter_cat_t < _Iter > ( ) );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last,
   input_iterator_tag )
  {
  for (; _First != _Last; ++ _First )
   emplace_back ( * _First );
  }

 template < class _Iter >
  void _Assign ( _Iter _First, _Iter _Last,
   forward_iterator_tag )
  {
  size_type _Newsize = :: std :: distance ( _First, _Last );

  if ( capacity ( ) < _Newsize )
   {
   size_type _Newcapacity = _Grow_to ( _Newsize );
   _Tidy ( );
   _Buy ( _Newcapacity );
   }

  this -> _Mylast ( ) = _Ucopy ( _First, _Last, this -> _Myfirst ( ) );
  }

 void assign ( size_type _Count, const value_type & _Val )
  {
  clear ( );
  insert ( begin ( ), _Count, _Val );
  }

 iterator insert ( const_iterator _Where, const _Ty & _Val )
  {
  return ( _Insert_n ( _Where, ( size_type ) 1, _Val ) );
  }

 iterator insert ( const_iterator _Where, size_type _Count,
  const _Ty & _Val )
  {
  return ( _Insert_n ( _Where, _Count, _Val ) );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   iterator > :: type
  insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  size_type _Off = ( _Where ) . _Ptr - this -> _Myfirst ( );
  _Insert ( _Where, _First, _Last, _Iter_cat_t < _Iter > ( ) );
  return ( begin ( ) + _Off );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last,
    input_iterator_tag )
  {
  size_type _Off = ( _Where ) . _Ptr - this -> _Myfirst ( );


  if ( size ( ) < _Off )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72" L"\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1388 );


  if ( _First != _Last )
   {
   size_type _Oldsize = size ( );

   try {
   for (; _First != _Last; ++ _First )
    push_back ( * _First );

   } catch ( ... ) {
   erase ( begin ( ) + _Oldsize, end ( ) );
   throw;
   }

   :: std :: rotate ( begin ( ) + _Off, begin ( ) + _Oldsize, end ( ) );
   }
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last,
    forward_iterator_tag )
  {

  if ( _Where . _Getcont ( ) != & this -> _Get_data ( )
   || ( _Where ) . _Ptr < this -> _Myfirst ( )
   || this -> _Mylast ( ) < ( _Where ) . _Ptr )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72" L"\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1417 );
  _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1418 );


  size_type _Count = :: std :: distance ( _First, _Last );
  if ( _Count == 0 )
   ;
  else if ( _Unused_capacity ( ) < _Count )
   {
   if ( max_size ( ) - size ( ) < _Count )
    _Xlen ( );

   size_type _Capacity = _Grow_to ( size ( ) + _Count );
   pointer _Newvec = this -> _Getal ( ) . allocate ( _Capacity );
   pointer _Ptr = _Newvec;

   try {
   _Ptr = _Umove ( this -> _Myfirst ( ), ( _Where ) . _Ptr,
    _Newvec );
   _Ptr = _Ucopy ( _First, _Last, _Ptr );
   _Umove ( ( _Where ) . _Ptr, this -> _Mylast ( ),
    _Ptr );
   } catch ( ... ) {
   _Destroy ( _Newvec, _Ptr );
   this -> _Getal ( ) . deallocate ( _Newvec, _Capacity );
   throw;
   }

   _Count += size ( );
   if ( this -> _Myfirst ( ) != pointer ( ) )
    {
    _Destroy ( this -> _Myfirst ( ), this -> _Mylast ( ) );
    this -> _Getal ( ) . deallocate ( this -> _Myfirst ( ),
     this -> _Myend ( ) - this -> _Myfirst ( ) );
    }

   this -> _Orphan_all ( );
   this -> _Myend ( ) = _Newvec + _Capacity;
   this -> _Mylast ( ) = _Newvec + _Count;
   this -> _Myfirst ( ) = _Newvec;
   }
  else
   {
   _Ucopy ( _First, _Last, this -> _Mylast ( ) );
   :: std :: rotate ( ( _Where ) . _Ptr, this -> _Mylast ( ),
    this -> _Mylast ( ) + _Count );
   this -> _Mylast ( ) += _Count;
   _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast ( ) );
   }
  }


 iterator erase ( const_iterator _Where )
  {
  if ( _Where . _Getcont ( ) != & this -> _Get_data ( )
   || ( _Where ) . _Ptr < this -> _Myfirst ( )
   || this -> _Mylast ( ) <= ( _Where ) . _Ptr )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x65\x72\x61\x73\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72\x61" L"\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1474 );
  _Move_unchecked ( ( _Where ) . _Ptr + 1, this -> _Mylast ( ), ( _Where ) . _Ptr );
  _Destroy ( this -> _Mylast ( ) - 1, this -> _Mylast ( ) );
  _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast ( ) );
  -- this -> _Mylast ( );
  return ( _Make_iter ( _Where ) );
  }












 iterator erase ( const_iterator _First_arg,
  const_iterator _Last_arg )
  {
  if ( _First_arg == begin ( ) && _Last_arg == end ( ) )
   clear ( );
  else if ( _First_arg != _Last_arg )
   {
   iterator _First = _Make_iter ( _First_arg );
   iterator _Last = _Make_iter ( _Last_arg );

   if ( _First != _Last )
    {

    if ( _Last < _First || _First . _Getcont ( ) != & this -> _Get_data ( )
     || ( _First ) . _Ptr < this -> _Myfirst ( )
     || this -> _Mylast ( ) < ( _Last ) . _Ptr )
     _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x65\x72\x61\x73\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72\x61" L"\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1509 );
    pointer _Ptr = _Move_unchecked ( ( _Last ) . _Ptr, this -> _Mylast ( ),
     ( _First ) . _Ptr );
    _Orphan_range ( ( _First ) . _Ptr, this -> _Mylast ( ) );






    _Destroy ( _Ptr, this -> _Mylast ( ) );
    this -> _Mylast ( ) = _Ptr;
    }
   }
  return ( _Make_iter ( _First_arg ) );
  }

 void _Pop_back_n ( size_type _Count )
  {
  pointer _Ptr = this -> _Mylast ( ) - _Count;


  _Orphan_range ( _Ptr, this -> _Mylast ( ) );


  _Destroy ( _Ptr, this -> _Mylast ( ) );
  this -> _Mylast ( ) = _Ptr;
  }

 void clear ( ) noexcept
  {
  this -> _Orphan_all ( );
  _Destroy ( this -> _Myfirst ( ), this -> _Mylast ( ) );
  this -> _Mylast ( ) = this -> _Myfirst ( );
  }

 void swap ( _Myt & _Right )
  noexcept ( _Alty :: propagate_on_container_swap :: value || _Alty :: is_always_equal :: value )

  {
  if ( this != & _Right )
   {
   _Pocs ( this -> _Getal ( ), _Right . _Getal ( ) );
   this -> _Swap_all ( _Right );
   _Swap_adl ( this -> _Myfirst ( ), _Right . _Myfirst ( ) );
   _Swap_adl ( this -> _Mylast ( ), _Right . _Mylast ( ) );
   _Swap_adl ( this -> _Myend ( ), _Right . _Myend ( ) );
   }
  }

protected :
 bool _Buy ( size_type _Capacity )
  {
  this -> _Myfirst ( ) = pointer ( );
  this -> _Mylast ( ) = pointer ( );
  this -> _Myend ( ) = pointer ( );

  if ( _Capacity == 0 )
   return ( false );
  else if ( max_size ( ) < _Capacity )
   _Xlen ( );
  else
   {
   this -> _Myfirst ( ) = this -> _Getal ( ) . allocate ( _Capacity );
   this -> _Mylast ( ) = this -> _Myfirst ( );
   this -> _Myend ( ) = this -> _Myfirst ( ) + _Capacity;
   }
  return ( true );
  }

 void _Destroy ( pointer _First, pointer _Last )
  {
  _Destroy_range ( _First, _Last, this -> _Getal ( ) );
  }

 size_type _Grow_to ( size_type _Count ) const
  {
  size_type _Capacity = capacity ( );

  _Capacity = max_size ( ) - _Capacity / 2 < _Capacity
   ? 0 : _Capacity + _Capacity / 2;
  if ( _Capacity < _Count )
   _Capacity = _Count;
  return ( _Capacity );
  }

 bool _Inside ( const value_type * _Ptr ) const
  {
  return ( _Ptr < _Unfancy ( this -> _Mylast ( ) ) && _Unfancy ( this -> _Myfirst ( ) ) <= _Ptr );
  }

 void _Reallocate ( size_type _Count )
  {
  pointer _Ptr = this -> _Getal ( ) . allocate ( _Count );

  try {
  _Umove ( this -> _Myfirst ( ), this -> _Mylast ( ), _Ptr );
  } catch ( ... ) {
  this -> _Getal ( ) . deallocate ( _Ptr, _Count );
  throw;
  }

  size_type _Size = size ( );
  if ( this -> _Myfirst ( ) != pointer ( ) )
   {
   _Destroy ( this -> _Myfirst ( ), this -> _Mylast ( ) );
   this -> _Getal ( ) . deallocate ( this -> _Myfirst ( ),
    this -> _Myend ( ) - this -> _Myfirst ( ) );
   }

  this -> _Orphan_all ( );
  this -> _Myend ( ) = _Ptr + _Count;
  this -> _Mylast ( ) = _Ptr + _Size;
  this -> _Myfirst ( ) = _Ptr;
  }

 void _Reserve ( size_type _Count )
  {
  if ( _Unused_capacity ( ) < _Count )
   {
   if ( max_size ( ) - size ( ) < _Count )
    _Xlen ( );
   _Reallocate ( _Grow_to ( size ( ) + _Count ) );
   }
  }

 void _Tidy ( )
  {
  if ( this -> _Myfirst ( ) != pointer ( ) )
   {
   this -> _Orphan_all ( );
   _Destroy ( this -> _Myfirst ( ), this -> _Mylast ( ) );
   this -> _Getal ( ) . deallocate ( this -> _Myfirst ( ),
    this -> _Myend ( ) - this -> _Myfirst ( ) );
   this -> _Myfirst ( ) = pointer ( );
   this -> _Mylast ( ) = pointer ( );
   this -> _Myend ( ) = pointer ( );
   }
  }

 template < class _Iter >
  pointer _Ucopy ( _Iter _First, _Iter _Last, pointer _Ptr )
  {
  return ( _Uninitialized_copy ( _First, _Last,
   _Ptr, this -> _Getal ( ) ) );
  }

 template < class _Iter >
  pointer _Umove ( _Iter _First, _Iter _Last, pointer _Ptr )
  {
  return ( _Uninitialized_move ( _First, _Last,
   _Ptr, this -> _Getal ( ) ) );
  }

 iterator _Insert_n ( const_iterator _Where,
  size_type _Count, const value_type & _Val )
  {

  if ( _Where . _Getcont ( ) != & this -> _Get_data ( )
   || ( _Where ) . _Ptr < this -> _Myfirst ( )
   || this -> _Mylast ( ) < ( _Where ) . _Ptr )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73\x69\x64\x65\x20\x72" L"\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1670 );


  size_type _Off = ( _Where ) . _Ptr - this -> _Myfirst ( );
  if ( _Count == 0 )
   ;
  else if ( _Unused_capacity ( ) < _Count )
   {
   if ( max_size ( ) - size ( ) < _Count )
    _Xlen ( );

   size_type _Capacity = _Grow_to ( size ( ) + _Count );
   pointer _Newvec = this -> _Getal ( ) . allocate ( _Capacity );
   size_type _Whereoff = ( _Where ) . _Ptr - this -> _Myfirst ( );
   int _Ncopied = 0;

   try {
   _Ufill ( _Newvec + _Whereoff, _Count,
    :: std :: addressof ( _Val ) );
   ++ _Ncopied;
   _Umove ( this -> _Myfirst ( ), ( _Where ) . _Ptr,
    _Newvec );
   ++ _Ncopied;
   _Umove ( ( _Where ) . _Ptr, this -> _Mylast ( ),
    _Newvec + ( _Whereoff + _Count ) );
   } catch ( ... ) {
   if ( 1 < _Ncopied )
    _Destroy ( _Newvec, _Newvec + _Whereoff );
   if ( 0 < _Ncopied )
    _Destroy ( _Newvec + _Whereoff, _Newvec + _Whereoff + _Count );
   this -> _Getal ( ) . deallocate ( _Newvec, _Capacity );
   throw;
   }

   _Count += size ( );
   if ( this -> _Myfirst ( ) != pointer ( ) )
    {
    _Destroy ( this -> _Myfirst ( ), this -> _Mylast ( ) );
    this -> _Getal ( ) . deallocate ( this -> _Myfirst ( ),
     this -> _Myend ( ) - this -> _Myfirst ( ) );
    }

   this -> _Orphan_all ( );
   this -> _Myend ( ) = _Newvec + _Capacity;
   this -> _Mylast ( ) = _Newvec + _Count;
   this -> _Myfirst ( ) = _Newvec;
   }
  else if ( ( size_type ) ( this -> _Mylast ( ) - ( _Where ) . _Ptr )
   < _Count )
   {
   value_type _Tmp = _Val;

   _Umove ( ( _Where ) . _Ptr, this -> _Mylast ( ),
    ( _Where ) . _Ptr + _Count );

   try {
   _Ufill ( this -> _Mylast ( ),
    _Count - ( this -> _Mylast ( ) - ( _Where ) . _Ptr ),
    :: std :: addressof ( _Tmp ) );
   } catch ( ... ) {
   _Destroy ( ( _Where ) . _Ptr + _Count,
    this -> _Mylast ( ) + _Count );
   throw;
   }

   this -> _Mylast ( ) += _Count;
   _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast ( ) );
   :: std :: fill ( ( _Where ) . _Ptr, this -> _Mylast ( ) - _Count,
    _Tmp );
   }
  else
   {
   value_type _Tmp = _Val;

   pointer _Oldend = this -> _Mylast ( );
   this -> _Mylast ( ) = _Umove ( _Oldend - _Count, _Oldend,
    this -> _Mylast ( ) );

   _Orphan_range ( ( _Where ) . _Ptr, this -> _Mylast ( ) );
   _Move_backward_unchecked ( ( _Where ) . _Ptr, _Oldend - _Count,
    _Oldend );
   :: std :: fill ( ( _Where ) . _Ptr,
    ( _Where ) . _Ptr + _Count, _Tmp );
   }
  return ( begin ( ) + _Off );
  }

 pointer _Ufill ( pointer _Ptr, size_type _Count, const value_type * _Pval )
  {
  _Uninitialized_fill_n ( _Ptr, _Count, _Pval, this -> _Getal ( ) );
  return ( _Ptr + _Count );
  }

 [ [ noreturn ] ] void _Xlen ( ) const
  {
  _Xlength_error ( "vector<T> too long" );
  }

 [ [ noreturn ] ] void _Xran ( ) const
  {
  _Xout_of_range ( "invalid vector<T> subscript" );
  }


 void _Orphan_range ( pointer _First, pointer _Last ) const
  {
  _Lockit _Lock ( 3 );
  const_iterator * * _Pnext = ( const_iterator * * ) this -> _Getpfirst ( );
  if ( _Pnext != 0 )
   {
   while ( * _Pnext != 0 )
    if ( ( * _Pnext ) -> _Ptr < _First || _Last < ( * _Pnext ) -> _Ptr )
     _Pnext = ( const_iterator * * ) ( * _Pnext ) -> _Getpnext ( );
    else
     {
     ( * _Pnext ) -> _Clrcont ( );
     * _Pnext = * ( const_iterator * * ) ( * _Pnext ) -> _Getpnext ( );
     }
   }
  }






 };
#line 1800 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Ty,
 class _Alloc > inline
 void swap ( vector < _Ty, _Alloc > & _Left, vector < _Ty, _Alloc > & _Right )
  noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 1808
template < class _Ty,
 class _Alloc > inline
 bool operator == ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( _Left . size ( ) == _Right . size ( )
  && :: std :: equal ( _Left . begin ( ), _Left . end ( ), _Right . begin ( ) ) );
 }
#line 1817
template < class _Ty,
 class _Alloc > inline
 bool operator != ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1825
template < class _Ty,
 class _Alloc > inline
 bool operator < ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( :: std :: lexicographical_compare ( _Left . begin ( ), _Left . end ( ),
  _Right . begin ( ), _Right . end ( ) ) );
 }
#line 1834
template < class _Ty,
 class _Alloc > inline
 bool operator > ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1842
template < class _Ty,
 class _Alloc > inline
 bool operator <= ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1850
template < class _Ty,
 class _Alloc > inline
 bool operator >= ( const vector < _Ty, _Alloc > & _Left,
  const vector < _Ty, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1861
typedef unsigned _Vbase; 
#line 1862
const int _VBITS = ((8) * sizeof(_Vbase)); 
#line 1865
template < class _Alloc >
 class _Vb_iter_base
  : public _Iterator012 < random_access_iterator_tag,
   bool,
   typename _Alloc :: difference_type,
   bool *,
   bool,
   _Iterator_base >
 {
public :
 typedef typename _Alloc :: size_type _Sizet;
 typedef vector < bool, _Alloc > _Mycont;

 _Vb_iter_base ( )
  : _Myptr ( 0 ), _Myoff ( 0 )
  {
  }

 _Vb_iter_base ( const _Vbase * _Ptr, _Sizet _Off,
  const _Container_base * _Mypvbool )
  : _Myptr ( _Ptr ), _Myoff ( _Off )
  {
  this -> _Adopt ( _Mypvbool );
  }

 void _Advance ( _Sizet _Off )
  {
  _Myoff += _Off;
  _Myptr += _Myoff / _VBITS;
  _Myoff %= _VBITS;
  }

 int _Valid ( _Sizet _Inc ) const
  {

  const auto _Cont = static_cast < const _Mycont * > ( this -> _Getcont ( ) );
  _Sizet _Mysize = _Cont -> _Mysize;

  _Inc += _Myoff;
  _Inc += _VBITS * ( _Myptr - _Cont -> _Myvec . data ( ) );
  return ( _Inc < _Mysize ? - 1 : _Inc == _Mysize ? 0 : + 1 );





  }

 const _Vbase * _Myptr;
 _Sizet _Myoff;
 };
#line 1918 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Alloc >
 class _Vb_reference
  : public _Vb_iter_base < _Alloc >
 {
 typedef _Vb_iter_base < _Alloc > _Mybase;
 typedef _Vb_reference < _Alloc > _Mytype;

 _Vb_reference ( ) noexcept
  {
  }

public :
 _Vb_reference ( const _Mybase & _Right )
  : _Mybase ( _Right . _Myptr, _Right . _Myoff, _Right . _Getcont ( ) )
  {
  }

 _Mytype & operator = ( const _Mytype & _Right ) noexcept
  {
  return ( * this = bool ( _Right ) );
  }

 _Mytype & operator = ( bool _Val ) noexcept
  {
  if ( _Val )
   * ( _Vbase * ) _Getptr ( ) |= _Mask ( );
  else
   * ( _Vbase * ) _Getptr ( ) &= ( ~ _Mask ( ) );
  return ( * this );
  }

 void flip ( ) noexcept
  {
  * ( _Vbase * ) _Getptr ( ) ^= _Mask ( );
  }

 operator bool ( ) const noexcept
  {
  return ( ( * _Getptr ( ) & _Mask ( ) ) != 0 );
  }

 const _Vbase * _Getptr ( ) const
  {

  if ( this -> _Getcont ( ) == 0
   || this -> _Myptr == 0
   || 0 <= this -> _Valid ( 0 ) )
   {
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65" L"\x72\x65\x6e\x63\x61\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1966 );
   { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1967, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 1967, 0 ); };
   }






  return ( this -> _Myptr );
  }

protected :
 _Vbase _Mask ( ) const
  {
  return ( ( _Vbase ) ( 1 ) << this -> _Myoff );
  }
 };
#line 1985 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Alloc > inline
 void swap ( _Vb_reference < _Alloc > _Left,
  _Vb_reference < _Alloc > _Right )
 {
 bool _Val = _Left;
 _Left = _Right;
 _Right = _Val;
 }
#line 1995
template < class _Alloc >
 class _Vb_const_iterator
  : public _Vb_iter_base < _Alloc >
 {
public :
 typedef _Vb_iter_base < _Alloc > _Mybase;
 typedef _Vb_const_iterator < _Alloc > _Mytype;

 typedef _Vb_reference < _Alloc > _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef const_reference * pointer;
 typedef const_reference reference;

 _Vb_const_iterator ( )
  {
  }

 _Vb_const_iterator ( const _Vbase * _Ptr, const _Container_base * _Mypvbool )
  : _Mybase ( _Ptr, 0, _Mypvbool )
  {
  }

 const_reference operator * ( ) const
  {
  return ( _Reft ( * this ) );
  }

 _Mytype & operator ++ ( )
  {
  _Inc ( );
  return ( * this );
  }

 _Mytype operator ++ ( int )
  {
  _Mytype _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Mytype & operator -- ( )
  {
  _Dec ( );
  return ( * this );
  }

 _Mytype operator -- ( int )
  {
  _Mytype _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Mytype & operator += ( difference_type _Off )
  {
  if ( _Off < 0 && this -> _Myoff < 0 - ( size_type ) _Off )
   {
   this -> _Myoff += _Off;
   this -> _Myptr -= 1 + ( ( size_type ) ( - 1 ) - this -> _Myoff ) / _VBITS;
   this -> _Myoff %= _VBITS;
   }
  else
   {
   this -> _Myoff += _Off;
   this -> _Myptr += this -> _Myoff / _VBITS;
   this -> _Myoff %= _VBITS;
   }
  return ( * this );
  }

 _Mytype operator + ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Mytype & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Mytype operator - ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - (
  const _Mytype & _Right ) const
  {
  _Compat ( _Right );
  return ( _VBITS * ( this -> _Myptr - _Right . _Myptr )
   + ( difference_type ) this -> _Myoff
   - ( difference_type ) _Right . _Myoff );
  }

 const_reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Mytype & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Myptr == _Right . _Myptr
   && this -> _Myoff == _Right . _Myoff );
  }

 bool operator != ( const _Mytype & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Mytype & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Myptr < _Right . _Myptr
   || ( this -> _Myptr == _Right . _Myptr
    && this -> _Myoff < _Right . _Myoff ) );
  }

 bool operator > ( const _Mytype & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Mytype & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Mytype & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }


 void _Compat ( const _Mytype & _Right ) const
  {
  if ( this -> _Getcont ( ) != _Right . _Getcont ( ) )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69" L"\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2140 );
  }













 void _Dec ( )
  {
  if ( this -> _Myoff != 0 )
   -- this -> _Myoff;
  else
   {

   if ( this -> _Getcont ( ) == 0 || 0 < this -> _Valid ( ( size_type ) - 1 ) )
    {
    _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d" L"\x65\x6e\x74\x61\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2164 );
    { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2165, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2165, 0 ); };
    }






   this -> _Myoff = _VBITS - 1;
   -- this -> _Myptr;
   }
  }

 void _Inc ( )
  {
  if ( this -> _Myoff < _VBITS - 1 )
   ++ this -> _Myoff;
  else
   {

   if ( this -> _Getcont ( ) == 0 || 0 < this -> _Valid ( 1 ) )
    {
    _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d" L"\x65\x6e\x74\x61\x62\x6c\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2187 );
    { ( void ) ( ( ! ! ( ( "Standard C++ Libraries Out of Range" && 0 ) ) ) || ( 1 != _CrtDbgReportW ( 2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2188, 0, L"\x25\x6c\x73", L"\x22\x53\x74\x61\x6e\x64\x61\x72\x64\x20\x43\x2b\x2b\x20\x4c\x69\x62\x72\x61\x72\x69\x65\x73\x20\x4f\x75\x74\x20\x6f\x66\x20\x52" L"\x61\x6e\x67\x65\x22\x20\x26\x26\x20\x30" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2188, 0 ); };
    }






   this -> _Myoff = 0;
   ++ this -> _Myptr;
   }
  }
 };
#line 2202 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Alloc > inline
 _Vb_const_iterator < _Alloc > operator + (
  typename _Alloc :: difference_type _Off,
  _Vb_const_iterator < _Alloc > _Right )
  {
  return ( _Right += _Off );
  }
#line 2210
template< class _Alloc> 
#line 2211
struct _Is_checked_helper< _Vb_const_iterator< _Alloc> , void>  : public true_type { 
#line 2214
}; 
#line 2217
template < class _Alloc >
 class _Vb_iterator
  : public _Vb_const_iterator < _Alloc >
 {
public :
 typedef _Vb_const_iterator < _Alloc > _Mybase;
 typedef _Vb_iterator < _Alloc > _Mytype;

 typedef _Vb_reference < _Alloc > _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef bool value_type;
 typedef typename _Alloc :: size_type size_type;
 typedef typename _Alloc :: difference_type difference_type;
 typedef _Reft * pointer;
 typedef _Reft reference;

 _Vb_iterator ( )
  {
  }

 _Vb_iterator ( _Vbase * _Ptr, _Container_base * _Mypvbool )
  : _Mybase ( _Ptr, _Mypvbool )
  {
  }

 reference operator * ( ) const
  {
  return ( _Reft ( * this ) );
  }

 _Mytype & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Mytype operator ++ ( int )
  {
  _Mytype _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Mytype & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Mytype operator -- ( int )
  {
  _Mytype _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Mytype & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Mytype operator + ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Mytype & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Mytype operator - ( difference_type _Off ) const
  {
  _Mytype _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 2309
template < class _Alloc > inline
 _Vb_iterator < _Alloc > operator + ( typename _Alloc :: difference_type _Off,
  _Vb_iterator < _Alloc > _Right )
  {
  return ( _Right += _Off );
  }
#line 2316
template< class _Alloc> 
#line 2317
struct _Is_checked_helper< _Vb_iterator< _Alloc> , void>  : public true_type { 
#line 2320
}; 
#line 2323
template < class _Alloc >
 class _Vb_val
  : public _Container_base
 {
public :
 typedef vector < _Vbase, _Alloc > _Vectype;
 typedef typename _Vectype :: _Alty _Alty;
 typedef typename _Alty :: size_type size_type;

 _Vb_val ( size_type _Count, const bool & _Val )
  : _Myvec ( _Nw ( _Count ), ( _Vbase ) ( _Val ? - 1 : 0 ) )
  {
  _Alloc_proxy ( );
  _Mysize = 0;
  }

 _Vb_val ( size_type _Count, const bool & _Val, const _Alloc & _Al )
  : _Myvec ( _Nw ( _Count ), ( _Vbase ) ( _Val ? - 1 : 0 ), _Al )
  {
  _Alloc_proxy ( );
  _Mysize = 0;
  }

 _Vb_val ( const _Vb_val & _Right )
  : _Myvec ( _Right . _Myvec ),
   _Mysize ( _Right . _Mysize )
  {
  _Alloc_proxy ( );
  }

 _Vb_val ( const _Vb_val & _Right, const _Alloc & _Al )
  : _Myvec ( _Right . _Myvec, _Al ),
   _Mysize ( _Right . _Mysize )
  {
  _Alloc_proxy ( );
  }

 _Vb_val ( _Vb_val && _Right )
  : _Myvec ( :: std :: forward < _Vectype > ( _Right . _Myvec ) ),
   _Mysize ( _Right . _Mysize )
  {
  _Right . _Mysize = 0;
  _Alloc_proxy ( );
  }

 _Vb_val ( _Vb_val && _Right, const _Alloc & _Al )
  : _Myvec ( :: std :: forward < _Vectype > ( _Right . _Myvec ), _Al ),
   _Mysize ( _Right . _Mysize )
  {
  _Right . _Mysize = 0;
  _Alloc_proxy ( );
  }

 ~ _Vb_val ( ) noexcept
  {
  _Free_proxy ( );
  }











 void _Alloc_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Myvec . _Getal ( ) );
  this -> _Myproxy = _Unfancy ( _Alproxy . allocate ( 1 ) );
  _Alproxy . construct ( this -> _Myproxy, _Container_proxy ( ) );
  this -> _Myproxy -> _Mycont = this;
  }

 void _Free_proxy ( )
  {
  typename _Alty :: template rebind < _Container_proxy > :: other
   _Alproxy ( _Myvec . _Getal ( ) );
  this -> _Orphan_all ( );
  _Alproxy . destroy ( this -> _Myproxy );
  _Alproxy . deallocate ( _Alproxy . address ( * this -> _Myproxy ), 1 );
  this -> _Myproxy = 0;
  }


 static size_type _Nw ( size_type _Count )
  {
  return ( ( _Count + _VBITS - 1 ) / _VBITS );
  }

 _Vectype _Myvec;
 typename _Alty :: size_type _Mysize;
 };
#line 2422 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Alloc >
 class vector < bool, _Alloc >
  : public _Vb_val < _Alloc >
 {
public :
 typedef vector < bool, _Alloc > _Myt;
 typedef _Vb_val < _Alloc > _Mybase;
 typedef typename _Mybase :: _Alty _Alty;
 typedef typename _Mybase :: _Vectype _Vectype;

 typedef typename _Alty :: size_type size_type;
 typedef typename _Alty :: difference_type difference_type;
 typedef bool _Ty;
 typedef _Alloc allocator_type;

 typedef _Vb_reference < _Alty > reference;
 typedef bool const_reference;
 typedef bool value_type;

 typedef reference _Reft;
 typedef _Vb_const_iterator < _Alty > const_iterator;
 typedef _Vb_iterator < _Alty > iterator;

 typedef iterator pointer;
 typedef const_iterator const_pointer;
 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 static const int _VBITS = :: std :: _VBITS;
 enum { _EEN_VBITS = _VBITS };
 vector ( )
  : _Mybase ( 0, false )
  {
  }

 explicit vector ( const _Alloc & _Al )
  : _Mybase ( 0, false, _Al )
  {
  }

 explicit vector ( size_type _Count, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( _Count, false, _Al )
  {
  _Trim ( _Count );
  }

 vector ( size_type _Count, const bool & _Val, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( _Count, _Val, _Al )
  {
  _Trim ( _Count );
  }

 vector ( const _Myt & _Right )
  : _Mybase ( _Right )
  {
  }

 vector ( const _Myt & _Right, const _Alloc & _Al )
  : _Mybase ( _Right, _Al )
  {
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  vector ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( 0, false, _Al )
  {
  _BConstruct ( _First, _Last );
  }

 template < class _Iter >
  void _BConstruct ( _Iter _First, _Iter _Last )
  {
  insert ( begin ( ), _First, _Last );
  }

 vector ( _Myt && _Right )
  : _Mybase ( :: std :: forward < _Myt > ( _Right ) )
  {
  }

 vector ( _Myt && _Right, const _Alloc & _Al )
  : _Mybase ( :: std :: forward < _Myt > ( _Right ), _Al )
  {
  }

 _Myt & operator = ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   clear ( );

   if ( _Alty :: propagate_on_container_move_assignment :: value
    && this -> get_allocator ( ) != _Right . get_allocator ( ) )
    {
    this -> _Free_proxy ( );
    this -> _Myvec = :: std :: move ( _Right . _Myvec );
    this -> _Alloc_proxy ( );
    }
   else
    this -> _Myvec = :: std :: move ( _Right . _Myvec );


   this -> _Mysize = _Right . _Mysize;
   _Right . _Mysize = 0;
   }
  return ( * this );
  }

 template < class ... _Valty >
  void emplace_back ( _Valty && ... _Val )
  {
  bool _Tmp ( :: std :: forward < _Valty > ( _Val ) ... );
  push_back ( _Tmp );
  }

 template < class ... _Valty >
  iterator emplace ( const_iterator _Where, _Valty && ... _Val )
  {
  bool _Tmp ( :: std :: forward < _Valty > ( _Val ) ... );
  return ( insert ( _Where, _Tmp ) );
  }


 vector ( :: std :: initializer_list < bool > _Ilist,
   const _Alloc & _Al = allocator_type ( ) )
  : _Mybase ( 0, false, _Al )
  {
  insert ( begin ( ), _Ilist . begin ( ), _Ilist . end ( ) );
  }

 _Myt & operator = ( :: std :: initializer_list < bool > _Ilist )
  {
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  return ( * this );
  }

 void assign ( :: std :: initializer_list < bool > _Ilist )
  {
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 iterator insert ( const_iterator _Where,
   :: std :: initializer_list < bool > _Ilist )
  {
  return ( insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 ~ vector ( ) noexcept
  {
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  this -> _Mysize = _Right . _Mysize;
  this -> _Myvec = _Right . _Myvec;
  return ( * this );
  }

 void reserve ( size_type _Count )
  {
  this -> _Myvec . reserve ( this -> _Nw ( _Count ) );
  }

 size_type capacity ( ) const noexcept
  {
  return ( this -> _Myvec . capacity ( ) * _VBITS );
  }

 iterator begin ( ) noexcept
  {
  return ( iterator ( this -> _Myvec . data ( ), this ) );
  }

 const_iterator begin ( ) const noexcept
  {
  return ( const_iterator ( this -> _Myvec . data ( ), this ) );
  }

 iterator end ( ) noexcept
  {
  iterator _Tmp = begin ( );
  if ( 0 < this -> _Mysize )
   _Tmp += this -> _Mysize;
  return ( _Tmp );
  }

 const_iterator end ( ) const noexcept
  {
  const_iterator _Tmp = begin ( );
  if ( 0 < this -> _Mysize )
   _Tmp += this -> _Mysize;
  return ( _Tmp );
  }

 const_iterator cbegin ( ) const noexcept
  {
  return ( begin ( ) );
  }

 const_iterator cend ( ) const noexcept
  {
  return ( end ( ) );
  }

 const_reverse_iterator crbegin ( ) const noexcept
  {
  return ( rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const noexcept
  {
  return ( rend ( ) );
  }

 void shrink_to_fit ( )
  {
  if ( this -> _Myvec . _Has_unused_capacity ( ) )
   {
   _Myt _Tmp ( * this );
   swap ( _Tmp );
   }
  }

 iterator _Make_iter ( const_iterator _Where )
  {
  iterator _Tmp = begin ( );
  if ( 0 < this -> _Mysize )
   _Tmp += _Where - begin ( );
  return ( _Tmp );
  }

 reverse_iterator rbegin ( ) noexcept
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const noexcept
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( ) noexcept
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const noexcept
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 void resize ( size_type _Newsize, bool _Val = false )
  {
  if ( size ( ) < _Newsize )
   _Insert_n ( end ( ), _Newsize - size ( ), _Val );
  else if ( _Newsize < size ( ) )
   erase ( begin ( ) + _Newsize, end ( ) );
  }

 size_type size ( ) const noexcept
  {
  return ( this -> _Mysize );
  }

 size_type max_size ( ) const noexcept
  {
  const size_type _Maxsize = this -> _Myvec . max_size ( );
  return ( _Maxsize < ( size_type ) ( - 1 ) / _VBITS
   ? _Maxsize * _VBITS : ( size_type ) ( - 1 ) );
  }

 bool empty ( ) const noexcept
  {
  return ( size ( ) == 0 );
  }

 _Alloc get_allocator ( ) const noexcept
  {
  _Alloc _Ret ( this -> _Myvec . get_allocator ( ) );
  return ( _Ret );
  }

 const_reference at ( size_type _Off ) const
  {
  if ( size ( ) <= _Off )
   _Xran ( );
  return ( ( * this ) [ _Off ] );
  }

 reference at ( size_type _Off )
  {
  if ( size ( ) <= _Off )
   _Xran ( );
  return ( ( * this ) [ _Off ] );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {
  const_iterator _It = begin ( );
  _It . _Advance ( _Off );
  return ( * _It );
  }

 reference operator [ ] ( size_type _Off )
  {
  iterator _It = begin ( );
  _It . _Advance ( _Off );
  return ( * _It );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 void push_back ( const bool & _Val )
  {
  insert ( end ( ), _Val );
  }

 void pop_back ( )
  {
  erase ( end ( ) - 1 );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type
  assign ( _Iter _First, _Iter _Last )
  {
  erase ( begin ( ), end ( ) );
  insert ( begin ( ), _First, _Last );
  }

 void assign ( size_type _Count, const bool & _Val )
  {
  erase ( begin ( ), end ( ) );
  _Insert_n ( begin ( ), _Count, _Val );
  }

 iterator insert ( const_iterator _Where, const bool & _Val )
  {
  return ( _Insert_n ( _Where, ( size_type ) 1, _Val ) );
  }

 iterator insert ( const_iterator _Where, size_type _Count,
  const bool & _Val )
  {
  return ( _Insert_n ( _Where, _Count, _Val ) );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   iterator > :: type
  insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  size_type _Off = _Where - begin ( );
  _Insert ( _Where, _First, _Last, _Iter_cat_t < _Iter > ( ) );
  return ( begin ( ) + _Off );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last,
    input_iterator_tag )
  {
  size_type _Off = _Where - begin ( );

  for (; _First != _Last; ++ _First, ( void ) ++ _Off )
   insert ( begin ( ) + _Off, * _First );
  }

 template < class _Iter >
  void _Insert ( const_iterator _Where,
   _Iter _First, _Iter _Last,
   forward_iterator_tag )
  {
  _Debug_range ( _First, _Last, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2816 );
  size_type _Count = :: std :: distance ( _First, _Last );
  size_type _Off = _Insert_x ( _Where, _Count );
  :: std :: copy ( _First, _Last, begin ( ) + _Off );
  }

 iterator erase ( const_iterator _Where_arg )
  {
  iterator _Where = _Make_iter ( _Where_arg );
  size_type _Off = _Where - begin ( );


  if ( end ( ) <= _Where )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x65\x72\x61\x73\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73" L"\x69\x64\x65\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2829 );
  :: std :: copy ( _Where + 1, end ( ), _Where );
  _Orphan_range ( _Off, this -> _Mysize );





  _Trim ( this -> _Mysize - 1 );
  return ( begin ( ) + _Off );
  }

 iterator erase ( const_iterator _First_arg,
  const_iterator _Last_arg )
  {
  iterator _First = _Make_iter ( _First_arg );
  iterator _Last = _Make_iter ( _Last_arg );
  size_type _Off = _First - begin ( );

  if ( _First != _Last )
   {

   if ( _Last < _First || end ( ) < _Last )
    _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x65\x72\x61\x73\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74\x73" L"\x69\x64\x65\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2852 );
   iterator _Next = :: std :: copy ( _Last, end ( ), _First );
   size_type _Newsize = _Next - begin ( );
   _Orphan_range ( _Newsize, this -> _Mysize );
   _Trim ( _Newsize );





   }
  return ( begin ( ) + _Off );
  }

 void clear ( ) noexcept
  {
  erase ( begin ( ), end ( ) );
  }

 void flip ( ) noexcept
  {
  for ( typename _Vectype :: iterator _Next = this -> _Myvec . begin ( );
   _Next != this -> _Myvec . end ( ); ++ _Next )
   * _Next = ( _Vbase ) ~ * _Next;
  _Trim ( this -> _Mysize );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   this -> _Swap_all ( _Right );
   this -> _Myvec . swap ( _Right . _Myvec );
   :: std :: swap ( this -> _Mysize, _Right . _Mysize );
   }
  }

 static void swap ( reference _Left, reference _Right ) noexcept
  {
  bool _Val = _Left;

  _Left = _Right;
  _Right = _Val;
  }

 size_t hash ( ) const
  {
  return ( _Hash_seq ( ( const unsigned char * ) this -> _Myvec . data ( ),
   this -> _Myvec . size ( ) * sizeof ( _Vbase ) ) );
  }

 iterator _Insert_n ( const_iterator _Where,
  size_type _Count, const bool & _Val )
  {
  size_type _Off = _Insert_x ( _Where, _Count );
  :: std :: fill ( begin ( ) + _Off, begin ( ) + ( _Off + _Count ), _Val );
  return ( begin ( ) + _Off );
  }

 size_type _Insert_x ( const_iterator _Where, size_type _Count )
  {
  size_type _Off = _Where - begin ( );


  if ( end ( ) < _Where )
   _Debug_message ( L"\x76\x65\x63\x74\x6f\x72\x3c\x62\x6f\x6f\x6c\x3e\x20\x69\x6e\x73\x65\x72\x74\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x6f\x75\x74" L"\x73\x69\x64\x65\x20\x72\x61\x6e\x67\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x20\x31\x34\x2e\x30\x5c\x56\x43\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c\x76" L"\x65\x63\x74\x6f\x72", 2917 );
  bool _Realloc = capacity ( ) - size ( ) < _Count;


  if ( _Count == 0 )
   ;
  else if ( max_size ( ) - size ( ) < _Count )
   _Xlen ( );
  else
   {
   this -> _Myvec . resize ( this -> _Nw ( size ( ) + _Count ), 0 );
   if ( empty ( ) )
    this -> _Mysize += _Count;
   else
    {
    iterator _Oldend = end ( );
    this -> _Mysize += _Count;
    :: std :: copy_backward ( begin ( ) + _Off, _Oldend, end ( ) );
    }


   _Orphan_range ( _Realloc ? 0 : _Off, this -> _Mysize );

   }
  return ( _Off );
  }


 void _Orphan_range ( size_type _Offlo, size_type _Offhi ) const
  {
  typedef _Vb_iter_base < _Alty > _Myiterbase;

  _Lockit _Lock ( 3 );
  auto _Base = const_cast < _Vbase * > ( this -> _Myvec . data ( ) );

  const_iterator * * _Pnext = ( const_iterator * * ) this -> _Getpfirst ( );
  if ( _Pnext != 0 )
   while ( * _Pnext != 0 )
    {
    size_type _Off = _VBITS * ( ( * _Pnext ) -> _Myptr - _Base )
     + ( * _Pnext ) -> _Myoff;
    if ( _Off < _Offlo || _Offhi < _Off )
     _Pnext = ( const_iterator * * ) ( * _Pnext ) -> _Getpnext ( );
    else
     {
     ( * _Pnext ) -> _Clrcont ( );
     * _Pnext = * ( const_iterator * * ) ( * _Pnext ) -> _Getpnext ( );
     }
    }
  }







 void _Trim ( size_type _Size )
  {
  if ( max_size ( ) < _Size )
   _Xlen ( );
  size_type _Words = this -> _Nw ( _Size );

  if ( _Words < this -> _Myvec . size ( ) )
   this -> _Myvec . erase ( this -> _Myvec . begin ( ) + _Words,
    this -> _Myvec . end ( ) );
  this -> _Mysize = _Size;
  _Size %= _VBITS;
  if ( 0 < _Size )
   this -> _Myvec [ _Words - 1 ] &= ( ( _Vbase ) ( 1 ) << _Size ) - 1;
  }

 [ [ noreturn ] ] void _Xlen ( ) const
  {
  _Xlength_error ( "vector<bool> too long" );
  }

 [ [ noreturn ] ] void _Xran ( ) const
  {
  _Xout_of_range ( "invalid vector<bool> subscript" );
  }
 };
#line 3000 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
template < class _Alloc > inline
 bool operator == ( const vector < bool, _Alloc > & _Left,
  const vector < bool, _Alloc > & _Right )
 {
 return ( _Left . size ( ) == _Right . size ( )
  && :: std :: equal ( _Left . _Myvec . begin ( ), _Left . _Myvec . end ( ),
   _Right . _Myvec . begin ( ) ) );
 }
#line 3009
template < class _Alloc > inline
 bool operator != ( const vector < bool, _Alloc > & _Left,
  const vector < bool, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 3017
template < class _Alloc >
 struct hash < vector < bool, _Alloc > >
 {
 typedef vector < bool, _Alloc > argument_type;
 typedef size_t result_type;

 size_t operator ( ) ( const argument_type & _Keyval ) const
  {
  return ( _Keyval . hash ( ) );
  }
 };
#line 3028
}
#line 3031
#pragma warning(pop)
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\queue"
#pragma warning(push,3)
#line 3032 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\vector"
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\queue"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 16
template < class _Ty,
 class _Container = deque < _Ty > >
 class queue
 {
public :
 typedef queue < _Ty, _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: value_type value_type;
 typedef typename _Container :: size_type size_type;
 typedef typename _Container :: reference reference;
 typedef typename _Container :: const_reference const_reference;

 queue ( )
  : c ( )
  {
  }

 queue ( const _Myt & _Right )
  : c ( _Right . c )
  {
  }

 explicit queue ( const _Container & _Cont )
  : c ( _Cont )
  {
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  c = _Right . c;
  return ( * this );
  }


 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  explicit queue ( const _Alloc & _Al )
  : c ( _Al )
  {
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  queue ( const _Container & _Cont, const _Alloc & _Al )
  : c ( _Cont, _Al )
  {
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  queue ( const _Myt & _Right, const _Alloc & _Al )
  : c ( _Right . c, _Al )
  {
  }

 queue ( _Myt && _Right )
  noexcept ( is_nothrow_move_constructible < _Container > :: value )
  : c ( :: std :: move ( _Right . c ) )
  {
  }

 explicit queue ( _Container && _Cont )
  : c ( :: std :: move ( _Cont ) )
  {
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  queue ( _Container && _Cont, const _Alloc & _Al )
  : c ( :: std :: move ( _Cont ), _Al )
  {
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
    void > :: type >
  queue ( _Myt && _Right, const _Alloc & _Al )
  : c ( :: std :: move ( _Right . c ), _Al )
  {
  }

 _Myt & operator = ( _Myt && _Right )
  noexcept ( is_nothrow_move_assignable < _Container > :: value )
  {
  c = :: std :: move ( _Right . c );
  return ( * this );
  }

 void push ( value_type && _Val )
  {
  c . push_back ( :: std :: move ( _Val ) );
  }

 template < class ... _Valty >
  void emplace ( _Valty && ... _Val )
  {
  c . emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );
  }


 bool empty ( ) const
  {
  return ( c . empty ( ) );
  }

 size_type size ( ) const
  {
  return ( c . size ( ) );
  }

 reference front ( )
  {
  return ( c . front ( ) );
  }

 const_reference front ( ) const
  {
  return ( c . front ( ) );
  }

 reference back ( )
  {
  return ( c . back ( ) );
  }

 const_reference back ( ) const
  {
  return ( c . back ( ) );
  }

 void push ( const value_type & _Val )
  {
  c . push_back ( _Val );
  }

 void pop ( )
  {
  c . pop_front ( );
  }

 const _Container & _Get_container ( ) const
  {
  return ( c );
  }

protected :
 _Container c;

public :
 void swap ( _Myt & _Right )
  noexcept ( _Is_nothrow_swappable < _Container > :: value )
  {
  _Swap_adl ( c, _Right . c );
  }
 };
#line 177
template < class _Ty,
 class _Container,
 class = enable_if_t < _Is_swappable < _Container > :: value > > inline
 void swap ( queue < _Ty, _Container > & _Left,
  queue < _Ty, _Container > & _Right )
   noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 187
template < class _Ty,
 class _Container > inline
 bool operator == ( const queue < _Ty, _Container > & _Left,
  const queue < _Ty, _Container > & _Right )
 {
 return ( _Left . _Get_container ( ) == _Right . _Get_container ( ) );
 }
#line 195
template < class _Ty,
 class _Container > inline
 bool operator != ( const queue < _Ty, _Container > & _Left,
  const queue < _Ty, _Container > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 203
template < class _Ty,
 class _Container > inline
 bool operator < ( const queue < _Ty, _Container > & _Left,
  const queue < _Ty, _Container > & _Right )
 {
 return ( _Left . _Get_container ( ) < _Right . _Get_container ( ) );
 }
#line 211
template < class _Ty,
 class _Container > inline
 bool operator > ( const queue < _Ty, _Container > & _Left,
  const queue < _Ty, _Container > & _Right )
 {
 return ( _Right < _Left );
 }
#line 219
template < class _Ty,
 class _Container > inline
 bool operator <= ( const queue < _Ty, _Container > & _Left,
  const queue < _Ty, _Container > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 227
template < class _Ty,
 class _Container > inline
 bool operator >= ( const queue < _Ty, _Container > & _Left,
  const queue < _Ty, _Container > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 236
template < class _Ty,
 class _Container = vector < _Ty >,
 class _Pr = less < typename _Container :: value_type > >
 class priority_queue
 {
public :
 typedef priority_queue < _Ty, _Container, _Pr > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: value_type value_type;
 typedef typename _Container :: size_type size_type;
 typedef typename _Container :: reference reference;
 typedef typename _Container :: const_reference const_reference;

 priority_queue ( )
  : c ( ), comp ( )
  {
  }

 priority_queue ( const _Myt & _Right )
  : c ( _Right . c ), comp ( _Right . comp )
  {
  }

 explicit priority_queue ( const _Pr & _Pred )
  : c ( ), comp ( _Pred )
  {
  }

 priority_queue ( const _Pr & _Pred, const _Container & _Cont )
  : c ( _Cont ), comp ( _Pred )
  {
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _InIt >
  priority_queue ( _InIt _First, _InIt _Last )
  : c ( _First, _Last ), comp ( )
  {
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _InIt >
  priority_queue ( _InIt _First, _InIt _Last, const _Pr & _Pred )
  : c ( _First, _Last ), comp ( _Pred )
  {
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _InIt >
  priority_queue ( _InIt _First, _InIt _Last, const _Pr & _Pred,
   const _Container & _Cont )
  : c ( _Cont ), comp ( _Pred )
  {
  c . insert ( c . end ( ), _First, _Last );
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  c = _Right . c;
  comp = _Right . comp;
  return ( * this );
  }


 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  explicit priority_queue ( const _Alloc & _Al )
  : c ( _Al )
  {
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  priority_queue ( const _Pr & _Pred, const _Alloc & _Al )
  : c ( _Al ), comp ( _Pred )
  {
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  priority_queue ( const _Pr & _Pred, const _Container & _Cont,
   const _Alloc & _Al )
  : c ( _Cont, _Al ), comp ( _Pred )
  {
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  priority_queue ( const _Myt & _Right, const _Alloc & _Al )
  : c ( _Right . c, _Al ), comp ( _Right . comp )
  {
  }

 priority_queue ( _Myt && _Right )
  noexcept ( is_nothrow_move_constructible < _Container > :: value && is_nothrow_move_constructible < _Pr > :: value )

  : c ( :: std :: move ( _Right . c ) ), comp ( :: std :: move ( _Right . comp ) )
  {
  }

 priority_queue ( const _Pr & _Pred, _Container && _Cont )
  : c ( :: std :: move ( _Cont ) ), comp ( _Pred )
  {
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _InIt >
  priority_queue ( _InIt _First, _InIt _Last, const _Pr & _Pred,
   _Container && _Cont )
  : c ( :: std :: move ( _Cont ) ), comp ( _Pred )
  {
  c . insert ( c . end ( ), _First, _Last );
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
   void > :: type >
  priority_queue ( const _Pr & _Pred, _Container && _Cont,
   const _Alloc & _Al )
  : c ( :: std :: move ( _Cont ), _Al ), comp ( _Pred )
  {
  make_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class _Alloc,
  class = typename enable_if < uses_allocator < _Container, _Alloc > :: value,
    void > :: type >
  priority_queue ( _Myt && _Right, const _Alloc & _Al )
  : c ( :: std :: move ( _Right . c ), _Al ), comp ( :: std :: move ( _Right . comp ) )
  {
  }

 _Myt & operator = ( _Myt && _Right )
  noexcept ( is_nothrow_move_assignable < _Container > :: value && is_nothrow_move_assignable < _Pr > :: value )

  {
  c = :: std :: move ( _Right . c );
  comp = :: std :: move ( _Right . comp );
  return ( * this );
  }

 void push ( value_type && _Val )
  {
  c . push_back ( :: std :: move ( _Val ) );
  push_heap ( c . begin ( ), c . end ( ), comp );
  }

 template < class ... _Valty >
  void emplace ( _Valty && ... _Val )
  {
  c . emplace_back ( :: std :: forward < _Valty > ( _Val ) ... );
  push_heap ( c . begin ( ), c . end ( ), comp );
  }


 bool empty ( ) const
  {
  return ( c . empty ( ) );
  }

 size_type size ( ) const
  {
  return ( c . size ( ) );
  }

 const_reference top ( ) const
  {
  return ( c . front ( ) );
  }

 void push ( const value_type & _Val )
  {
  c . push_back ( _Val );
  push_heap ( c . begin ( ), c . end ( ), comp );
  }

 void pop ( )
  {
  pop_heap ( c . begin ( ), c . end ( ), comp );
  c . pop_back ( );
  }

protected :
 _Container c;
 _Pr comp;

public :
 void swap ( _Myt & _Right )
  noexcept ( _Is_nothrow_swappable < _Container > :: value && _Is_nothrow_swappable < _Pr > :: value )

  {
  _Swap_adl ( c, _Right . c );
  _Swap_adl ( comp, _Right . comp );
  }
 };
#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\include\\queue"
template < class _Ty,
 class _Container,
 class _Pr,
 class = enable_if_t < _Is_swappable < _Container > :: value && _Is_swappable < _Pr > :: value > > inline
 void swap ( priority_queue < _Ty, _Container, _Pr > & _Left,
  priority_queue < _Ty, _Container, _Pr > & _Right )
   noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 450
}
#line 452
namespace std { 
#line 453
template< class _Ty, class 
#line 454
_Container, class 
#line 455
_Alloc> 
#line 456
struct uses_allocator< queue< _Ty, _Container> , _Alloc>  : public uses_allocator< _Container, _Alloc>  { 
#line 459
}; 
#line 461
template< class _Ty, class 
#line 462
_Container, class 
#line 463
_Pr, class 
#line 464
_Alloc> 
#line 465
struct uses_allocator< priority_queue< _Ty, _Container, _Pr> , _Alloc>  : public uses_allocator< _Container, _Alloc>  { 
#line 468
}; 
#line 469
}
#line 472
#pragma warning(pop)
#pragma pack ( pop )
#line 3 "c:\\users\\nein\\source\\repos\\push_relabel_cuda\\flow_test\\flowgraph.h"
struct flowGraph { 
#line 4
struct edge { 
#line 5
int to, cap; 
#line 6
int rev; 
#line 7
}; 
#line 8
int source; 
#line 9
int sink; 
#line 11
std::vector< std::vector< edge> >  Graph; 
#line 12
void set_vertex(int n); 
#line 13
void add_edge(int from, int to, int cap); 
#line 14
void set_source_and_sink(int s, int t); 
#line 15
}; 
#line 18
struct droneGraph : public flowGraph { 
#line 20
private: int X, Y, Z, T; 
#line 21
int idx(int x, int y, int z, int t); 
#line 22
int in(int idx); 
#line 23
int out(int idx); 
#line 25
public: droneGraph(int x, int y, int z, int t); 
#line 26
void set_startpoint(int x, int y, int z); 
#line 27
void set_endpoint(int x, int y, int z); 
#line 28
}; 
#line 29
struct point { 
#line 30
int x, y, z; 
#line 31
}; 
#line 5 "c:\\users\\nein\\source\\repos\\push_relabel_cuda\\flow_test\\pushrelabel.h"
std::pair< flowGraph, int>  push_relabel_cuda(flowGraph graph_h); 
#line 14 "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu"
using std::vector;
#line 15
using std::pair;
#line 16
using edge = flowGraph::edge; 
#line 21
inline void cudaAssert(cudaError_t code, const char *file, int line, bool 
#line 22
abort = true) 
#line 23
{ 
#line 24
if (code != (cudaSuccess)) 
#line 25
{ 
#line 26
fprintf(__acrt_iob_func(2), "CUDA Error: %s at %s:%d\n", cudaGetErrorString(code), file, line); 
#line 28
if (abort) { exit(code); }  
#line 29
}  
#line 30
} 
#line 42 "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu"
static dim3 threadsPerBlock(1024, 1, 1); 
#line 46
 __noinline__ void push_relabel_kernel(edge *graph, int *startIdx, int *height, int *excessFlow, int n, int s, int t) ;
#if 0
#line 46
{ 
#line 47
int index = ((__device_builtin_variable_blockDim.x) * (__device_builtin_variable_blockIdx.x)) + (__device_builtin_variable_threadIdx.x); 
#line 49
int u = index; 
#line 50
if ((((u < 0) || (u >= n)) || (u == t)) || (u == s)) { return; }  
#line 52
int cycle = 150; 
#line 53
for (int _ = 0; _ < cycle; _++) { 
#line 54
int curExcess = excessFlow[u]; 
#line 55
if ((curExcess > 0) && ((height[u]) < n)) { 
#line 56
int curLowestNeighbor = (-1); 
#line 57
int neighborMinHeight = ((int)__longlong_as_double(9218868437227405312Ui64)) / 2; 
#line 60
int size = (startIdx[u + 1]) - (startIdx[u]); 
#line 61
for (int i = 0; i < size; i++) { 
#line 62
const edge &e = graph[(startIdx[u]) + i]; 
#line 63
int to = e.to; 
#line 64
int tempHeight = height[to]; 
#line 65
if ((neighborMinHeight > tempHeight) && ((e.cap) > 0)) { 
#line 66
neighborMinHeight = tempHeight; 
#line 67
curLowestNeighbor = i; 
#line 68
}  
#line 69
}  
#line 71
if (((height[u]) > neighborMinHeight) && (curLowestNeighbor != (-1))) { 
#line 72
int delta = (curExcess < ((graph[(startIdx[u]) + curLowestNeighbor]).cap)) ? curExcess : ((graph[(startIdx[u]) + curLowestNeighbor]).cap); ; 
#line 73
int v = (graph[(startIdx[u]) + curLowestNeighbor]).to; 
#line 74
int rev = (graph[(startIdx[u]) + curLowestNeighbor]).rev; 
#line 75
atomicAdd(&((graph[(startIdx[v]) + rev]).cap), delta); 
#line 76
atomicSub(&((graph[(startIdx[u]) + curLowestNeighbor]).cap), delta); 
#line 77
atomicAdd(&(excessFlow[v]), delta); 
#line 78
atomicSub(&(excessFlow[u]), delta); 
#line 79
} else 
#line 80
{ 
#line 81
(height[u]) = (neighborMinHeight + 1); 
#line 82
}  
#line 83
}  
#line 84
}  
#line 85
} 
#endif
#line 88 "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu"
void global_relabel_cpu(edge *graph, int *startIdx, int *height, int *excessFlow, int *excessTotal, bool *marked, int n, int s, int t) { 
#line 90
for (int u = 0; u < n; u++) { 
#line 91
for (int i = startIdx[u]; i < (startIdx[u + 1]); i++) { 
#line 92
edge &e = graph[i]; 
#line 93
int v = e.to; 
#line 94
edge &rev = graph[(startIdx[v]) + (e.rev)]; 
#line 95
if ((height[u]) > ((height[v]) + 1)) { 
#line 96
(excessFlow[u]) -= (e.cap); 
#line 97
(excessFlow[v]) += (e.cap); 
#line 98
(rev.cap) += (e.cap); 
#line 99
(e.cap) = 0; 
#line 100
}  
#line 101
}  
#line 102
}  
#line 104
std::queue< int>  que; 
#line 105
que.push(t); 
#line 106
std::fill(height, height + n, n); 
#line 107
(height[t]) = 0; 
#line 109
while (!que.empty()) { 
#line 110
int idx = que.front(); 
#line 111
que.pop(); 
#line 113
for (int i = startIdx[idx]; i < (startIdx[idx + 1]); i++) { 
#line 114
edge &e = graph[i]; 
#line 115
int v = e.to; 
#line 116
int cap = (graph[(startIdx[v]) + (e.rev)]).cap; 
#line 117
if ((cap > 0) && ((height[v]) > ((height[idx]) + 1))) { 
#line 118
(height[v]) = ((height[idx]) + 1); 
#line 119
que.push(v); 
#line 120
}  
#line 121
}  
#line 122
}  
#line 125
for (int i = 0; i < n; i++) { 
#line 126
if ((!(marked[i])) && ((height[i]) == n)) { 
#line 127
(marked[i]) = true; 
#line 128
(*excessTotal) -= (excessFlow[i]); 
#line 129
(excessFlow[i]) = 0; 
#line 130
}  
#line 131
}  
#line 132
} 
#line 135
void init_flow(flowGraph *graph, int *height, int *excessFlow, int *excessTotal, bool *marked, int n, int s, int t) { 
#line 136
for (int i = 0; i < n; i++) { 
#line 137
(height[i]) = 0; 
#line 138
(excessFlow[i]) = 0; 
#line 139
(marked[i]) = (0); 
#line 140
}  
#line 141
(height[s]) = n; 
#line 143
for (edge &ori : (graph->Graph)[s]) { 
#line 144
int to = ori.to; 
#line 145
edge &rev = ((graph->Graph)[to])[ori.rev]; 
#line 146
int cap = ori.cap; 
#line 148
(ori.cap) -= cap; 
#line 149
(rev.cap) += cap; 
#line 150
(excessFlow[to]) += cap; 
#line 151
(*excessTotal) += cap; 
#line 152
}  
#line 153
} 
#line 156
std::pair< flowGraph, int>  push_relabel_cuda(flowGraph graph) { 
#line 157
int n = (graph.Graph).size(); 
#line 158
int source = graph.source; 
#line 159
int sink = graph.sink; 
#line 162
int *excessFlow_h = (int *)malloc(sizeof(int) * n); 
#line 163
int *height_h = (int *)malloc(sizeof(int) * n); 
#line 164
int *startIdx_h = (int *)malloc(sizeof(int) * (n + 1)); 
#line 165
edge *graph_h; 
#line 166
bool *marked = (bool *)malloc(sizeof(bool) * n); 
#line 167
int excessTotal = 0; 
#line 170
int *excessFlow_d; 
#line 171
int *height_d; 
#line 172
edge *graph_d; 
#line 173
int *startIdx_d; 
#line 175
{ cudaAssert(cudaMalloc((void **)(&excessFlow_d), sizeof(int) * n), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 175); } ; 
#line 176
{ cudaAssert(cudaMalloc((void **)(&height_d), sizeof(int) * n), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 176); } ; 
#line 177
{ cudaAssert(cudaMalloc((void **)(&startIdx_d), sizeof(int) * (n + 1)), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 177); } ; 
#line 179
int sum = 0; 
#line 181
(startIdx_h[0]) = 0; 
#line 182
for (int i = 0; i < n; i++) { 
#line 183
sum += (graph.Graph)[i].size(); 
#line 184
(startIdx_h[i + 1]) = sum; 
#line 185
}  
#line 186
{ cudaAssert(cudaMemcpy(startIdx_d, startIdx_h, sizeof(int) * (n + 1), cudaMemcpyHostToDevice), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 186); } ; 
#line 188
graph_h = ((edge *)malloc(sizeof(edge) * sum)); 
#line 189
{ cudaAssert(cudaMalloc((void **)(&graph_d), sizeof(edge) * sum), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 189); } ; 
#line 192
init_flow(&graph, height_h, excessFlow_h, &excessTotal, marked, n, source, sink); 
#line 195
for (int i = 0; i < n; i++) { 
#line 196
for (int j = 0; j < (graph.Graph)[i].size(); j++) { 
#line 197
(graph_h[(startIdx_h[i]) + j]) = ((graph.Graph)[i])[j]; 
#line 198
}  
#line 199
}  
#line 200
{ cudaAssert(cudaMemcpy(graph_d, graph_h, sizeof(edge) * sum, cudaMemcpyHostToDevice), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 200); } ; 
#line 201
{ cudaAssert(cudaMemcpy(excessFlow_d, excessFlow_h, sizeof(int) * n, cudaMemcpyHostToDevice), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 201); } ; 
#line 203
while (((excessFlow_h[source]) + (excessFlow_h[sink])) < excessTotal) { 
#line 206
cudaMemcpy(height_d, height_h, sizeof(int) * n, cudaMemcpyHostToDevice); 
#line 209
int numBlocks = ((n + (threadsPerBlock.x)) - (1)) / (threadsPerBlock.x); 
#line 210
(cudaConfigureCall(numBlocks, threadsPerBlock)) ? (void)0 : push_relabel_kernel(graph_d, startIdx_d, height_d, excessFlow_d, n, source, sink); 
#line 213
{ cudaAssert(cudaMemcpy(graph_h, graph_d, sizeof(edge) * sum, cudaMemcpyDeviceToHost), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 213); } ; 
#line 214
{ cudaAssert(cudaMemcpy(height_h, height_d, sizeof(int) * n, cudaMemcpyDeviceToHost), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 214); } ; 
#line 215
{ cudaAssert(cudaMemcpy(excessFlow_h, excessFlow_d, sizeof(int) * n, cudaMemcpyDeviceToHost), "C:/Users/nein/source/repos/push_relabel_cuda/flow_test/pushrelabel.cu", 215); } ; 
#line 218
global_relabel_cpu(graph_h, startIdx_h, height_h, excessFlow_h, &excessTotal, marked, n, source, sink); 
#line 220
}  
#line 222
for (int i = 0; i < n; i++) { 
#line 223
for (int j = 0; j < ((startIdx_h[i + 1]) - (startIdx_h[i])); j++) { 
#line 224
(((graph.Graph)[i])[j].cap) = ((graph_h[(startIdx_h[i]) + j]).cap); 
#line 225
}  
#line 226
}  
#line 228
return {graph, excessFlow_h[sink]}; 
#line 229
} 
#line 1 "pushrelabel.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__19_pushrelabel_cpp1_ii_45def1c0
#line 1 "pushrelabel.cudafe1.stub.c"
#include "pushrelabel.cudafe1.stub.c"
#line 1 "pushrelabel.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
